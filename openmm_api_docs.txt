Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++.html:
OpenMM C++ APIÂ¶ The C++ API provides information about the classes and methods available in OpenMM for C++ developers. OpenMM uses an object-oriented API that makes all its functionality available through a small number of classes. Core classesÂ¶ OpenMM::SystemÂ¶ A System specifies generic properties of the molecular system to be simulated: the number of particles it contains, the mass of each one, the size of the periodic box, and so on. The interactions between the particles are specified through a set of Force objects that are added to the System. Force field specific parameters, such as particle charges, are stored in these Force objects, not as direct properties of the System. OpenMM::ContextÂ¶ A Context stores all of the state information for a simulation: particle positions and velocities, as well as arbitrary parameters defined by the Forces in the System. It is possible to create multiple Contexts for a single System, and thus have multiple simulations of that System in progress at the same time. Context does not provide methods for accessing state variables directly; they must be read via a State object. OpenMM::StateÂ¶ A State object must be constructed before data can be read from a simulation. State variables are not accessible directly via a Context in order to make explicit the precise time that a variable reflects. A State is created by calling a method on a Context and stores only the information requested at invocation. OpenMM::PlatformÂ¶ A Platform is a single implementation of OpenMM at a low level. This allows the same high level API documented here to be used on all sorts of compute hardware, from GPUs to supercomputers. A Platform implements some set of kernels, which define which operations it supports. Writing a new Platform allows OpenMM to be ported to new hardware or to be implemented in a new way without rewriting the entire application. ForcesÂ¶ Force objects define the behavior of the particles in a System. The Force class is actually slightly more general than its name suggests. A Force can, indeed, apply forces to particles, but it can also directly modify particle positions and velocities in arbitrary ways. Some thermostats and barostats, for example, can be implemented as Force classes. Examples of Force subclasses include HarmonicBondForce, NonbondedForce, and MonteCarloBarostat. Forces The Force abstract class Common bonded and non-bonded forces AMOEBA forces Pseudo-forces Customizing Force IntegratorsÂ¶ An Integrator implements an algorithm for advancing the simulation through time. They provide a Context a means of stepping the simulation forward, and must be coupled to a Context to function. Examples of Integrator subclasses include LangevinIntegrator, VerletIntegrator, and BrownianIntegrator. Integrators The Integrator abstract class General purpose integrators Drude integrators Ring Polymer Molecular Dynamics integrators Customizing Integrator ExtrasÂ¶ OpenMMâs public API includes a few more classes that support the above. Extra classes Tabulated functions Virtual Sites Serialization Other classes

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_extras.html:
Extra classesÂ¶ Tabulated functionsÂ¶ These classes use table of values to define a mathematical function and can be used by various custom forces. The TabulatedFunction class is an abstract class that the other classes extend. TabulatedFunction Continuous1DFunction Continuous2DFunction Continuous3DFunction Discrete1DFunction Discrete2DFunction Discrete3DFunction Virtual SitesÂ¶ A virtual site is a particle whose position is computed directly from the positions of other particles. The VirtualSite class is an abstract class that the other classes extend. VirtualSite LocalCoordinatesSite OutOfPlaneSite ThreeParticleAverageSite TwoParticleAverageSite SerializationÂ¶ These classes are used to serialize other objects, allowing them to be stored on disk. SerializationNode SerializationProxy XmlSerializer Other classesÂ¶ These classes donât fit neatly into the other categories, but that is not to say that they arenât important! LocalEnergyMinimizer MinimizationReporter NoseHooverChain OpenMMException Vec3

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_forces.html:
ForcesÂ¶ The Force abstract classÂ¶ The Force objects added to a System define the behavior of the particles. Force is an abstract class; subclasses implement specific behaviors. Classes that extend Force may implement actual physical forces, or any number of processes that either actually apply forces to particles or directly modify their positions or momenta. Force Common bonded and non-bonded forcesÂ¶ These classes implement forces that are widely used in biomolecular simulation. CMAPTorsionForce DrudeForce GBSAOBCForce GayBerneForce HarmonicAngleForce HarmonicBondForce NonbondedForce PeriodicTorsionForce RBTorsionForce AMOEBA forcesÂ¶ These forces are used to implement the polarizable AMOEBA force fields. AmoebaGeneralizedKirkwoodForce AmoebaMultipoleForce AmoebaTorsionTorsionForce AmoebaVdwForce AmoebaWcaDispersionForce HippoNonbondedForce Pseudo-forcesÂ¶ These inherit from Force, but do not describe physical forces. They are used to implement thermostats or barostats, or otherwise modify the simulation from step to step. They are conceptually closer to modifications to the integrator, but providing them as a Force simplifies implementation and allows them to be combined in arbitrary ways. AndersenThermostat ATMForce CMMotionRemover MonteCarloAnisotropicBarostat MonteCarloBarostat MonteCarloFlexibleBarostat MonteCarloMembraneBarostat RMSDForce RPMDMonteCarloBarostat Customizing ForceÂ¶ OpenMM provides a number of classes that make it easier to implement custom forces for common scenarios. These classes implement constructors that take an algebraic expression as a string. The class is instantiated (not extended) to provide a Force object that efficiently implements the provided expression. CustomAngleForce CustomBondForce CustomCVForce CustomCentroidBondForce CustomCompoundBondForce CustomExternalForce CustomGBForce CustomHbondForce CustomManyParticleForce CustomNonbondedForce CustomTorsionForce

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_generated_Context.html:
ContextÂ¶ class ContextÂ¶ A Context stores the complete state of a simulation. More specifically, it includes: The current time The position of each particle The velocity of each particle The values of configurable parameters defined by Force objects in the System You can retrieve a snapshot of the current state at any time by calling getState(). This allows you to record the state of the simulation at various points, either for analysis or for checkpointing. getState() can also be used to retrieve the current forces on each particle and the current energy of the System. Public Functions Context(const System &system, Integrator &integrator)Â¶ Construct a new Context in which to run a simulation. Parameters system â the System which will be simulated integrator â the Integrator which will be used to simulate the System Context(const System &system, Integrator &integrator, Platform &platform)Â¶ Construct a new Context in which to run a simulation, explicitly specifying what Platform should be used to perform calculations. Parameters system â the System which will be simulated integrator â the Integrator which will be used to simulate the System platform â the Platform to use for calculations Context(const System &system, Integrator &integrator, Platform &platform, const std::map<std::string, std::string> &properties)Â¶ Construct a new Context in which to run a simulation, explicitly specifying what Platform should be used to perform calculations and the values of platform-specific properties. Parameters system â the System which will be simulated integrator â the Integrator which will be used to simulate the System platform â the Platform to use for calculations properties â a set of values for platform-specific properties. Keys are the property names. const System &getSystem() constÂ¶ Get System being simulated in this context. const Integrator &getIntegrator() constÂ¶ Get Integrator being used to by this context. Integrator &getIntegrator()Â¶ Get Integrator being used to by this context. const Platform &getPlatform() constÂ¶ Get the Platform being used for calculations. Platform &getPlatform()Â¶ Get the Platform being used for calculations. State getState(int types, bool enforcePeriodicBox = false, int groups = 0xFFFFFFFF) constÂ¶ Get a State object recording the current state information stored in this context. Parameters types â the set of data types which should be stored in the State object. This should be a union of DataType values, e.g. (State::Positions | State::Velocities). enforcePeriodicBox â if false, the position of each particle will be whatever position is stored in the Context, regardless of periodic boundary conditions. If true, particle positions will be translated so the center of every molecule lies in the same periodic box. groups â a set of bit flags for which force groups to include when computing forces and energies. Group i will be included if (groups&(1<<i)) != 0. The default value includes all groups. void setState(const State &state)Â¶ Copy information from a State object into this Context. This restores the Context to approximately the same state it was in when the State was created. If the State does not include a piece of information (e.g. positions or velocities), that aspect of the Context is left unchanged. Even when all possible information is included in the State, the effect of calling this method is still less complete than loadCheckpoint(). For example, it does not restore the internal states of random number generators. On the other hand, it has the advantage of not being hardware specific. double getTime() constÂ¶ Get the current time of the simulation (in picoseconds). void setTime(double time)Â¶ Set the current time of the simulation (in picoseconds). long long getStepCount() constÂ¶ Get the current step count. void setStepCount(long long count)Â¶ Set the current step count. void setPositions(const std::vector<Vec3> &positions)Â¶ Set the positions of all particles in the System (measured in nm). This method simply sets the positions without checking to see whether they satisfy distance constraints. If you want constraints to be enforced, call applyConstraints() after setting the positions. Parameters positions â a vector whose length equals the number of particles in the System. The iâth element contains the position of the iâth particle. void setVelocities(const std::vector<Vec3> &velocities)Â¶ Set the velocities of all particles in the System (measured in nm/picosecond). Parameters velocities â a vector whose length equals the number of particles in the System. The iâth element contains the velocity of the iâth particle. void setVelocitiesToTemperature(double temperature, int randomSeed = osrngseed())Â¶ Set the velocities of all particles in the System to random values chosen from a Boltzmann distribution at a given temperature. Parameters temperature â the temperature for which to select the velocities (measured in Kelvin) randomSeed â the random number seed to use when selecting velocities const std::map<std::string, double> &getParameters() constÂ¶ Get all adjustable parameters that have been defined by Force objects in the System, along with their current values. double getParameter(const std::string &name) constÂ¶ Get the value of an adjustable parameter defined by a Force object in the System. Parameters name â the name of the parameter to get void setParameter(const std::string &name, double value)Â¶ Set the value of an adjustable parameter defined by a Force object in the System. Parameters name â the name of the parameter to set value â the value of the parameter void setPeriodicBoxVectors(const Vec3 &a, const Vec3 &b, const Vec3 &c)Â¶ Set the vectors defining the axes of the periodic box (measured in nm). They will affect any Force that uses periodic boundary conditions. Triclinic boxes are supported, but the vectors must satisfy certain requirements. In particular, a must point in the x direction, b must point âmostlyâ in the y direction, and c must point âmostlyâ in the z direction. See the documentation for details. Parameters a â the vector defining the first edge of the periodic box b â the vector defining the second edge of the periodic box c â the vector defining the third edge of the periodic box void applyConstraints(double tol)Â¶ Update the positions of particles so that all distance constraints are satisfied. This also recomputes the locations of all virtual sites. Parameters tol â the distance tolerance within which constraints must be satisfied. void applyVelocityConstraints(double tol)Â¶ Update the velocities of particles so the net velocity of each constrained distance is zero. Parameters tol â the velocity tolerance within which constraints must be satisfied. void computeVirtualSites()Â¶ Recompute the locations of all virtual sites. There is rarely a reason to call this, since virtual sites are also updated by applyConstraints(). This is only for the rare situations when you want to enforce virtual sites but not constraints. void reinitialize(bool preserveState = false)Â¶ When a Context is created, it caches information about the System being simulated and the Force objects contained in it. This means that, if the System or Forces are then modified, the Context does not see the changes. Call reinitialize() to force the Context to rebuild its internal representation of the System and pick up any changes that have been made. This is an expensive operation, so you should try to avoid calling it too frequently. Most Force classes have an updateParametersInContext() method that provides a less expensive way of updating certain types of information. However, this method is the only way to make some types of changes, so it is sometimes necessary to call it. By default, reinitializing a Context causes all state information (positions, velocities, etc.) to be discarded. You can optionally tell it to try to preserve state information. It does this by internally creating a checkpoint, then reinitializing the Context, then loading the checkpoint. Be aware that if the System has changed in a way that prevents the checkpoint from being loaded (such as changing the number of particles), this will throw an exception and the state information will be lost. void createCheckpoint(std::ostream &stream)Â¶ Create a checkpoint recording the current state of the Context. This should be treated as an opaque block of binary data. See loadCheckpoint() for more details. Parameters stream â an output stream the checkpoint data should be written to void loadCheckpoint(std::istream &stream)Â¶ Load a checkpoint that was written by createCheckpoint(). A checkpoint contains not only publicly visible data such as the particle positions and velocities, but also internal data such as the states of random number generators. Ideally, loading a checkpoint should restore the Context to an identical state to when it was written, such that continuing the simulation will produce an identical trajectory. This is not strictly guaranteed to be true, however, and should not be relied on. For most purposes, however, the internal state should be close enough to be reasonably considered equivalent. A checkpoint contains data that is highly specific to the Context from which it was created. It depends on the details of the System, the Platform being used, and the hardware and software of the computer it was created on. If you try to load it on a computer with different hardware, or for a System that is different in any way, loading is likely to fail. Checkpoints created with different versions of OpenMM are also often incompatible. If a checkpoint cannot be loaded, that is signaled by throwing an exception. Parameters stream â an input stream the checkpoint data should be read from const std::vector<std::vector<int>> &getMolecules() constÂ¶ Get a description of how the particles in the system are grouped into molecules. Two particles are in the same molecule if they are connected by constraints or bonds, where every Force object can define bonds in whatever way are appropriate to that force. Each element lists the indices of all particles in a single molecule. Every particle is guaranteed to belong to exactly one molecule.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_generated_HarmonicBondForce.html:
HarmonicBondForceÂ¶ class HarmonicBondForce : public OpenMM::ForceÂ¶ This class implements an interaction between pairs of particles that varies harmonically with the distance between them. To use it, create a HarmonicBondForce object then call addBond() once for each bond. After a bond has been added, you can modify its force field parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). Public Functions HarmonicBondForce()Â¶ Create a HarmonicBondForce. inline int getNumBonds() constÂ¶ Get the number of harmonic bond stretch terms in the potential function int addBond(int particle1, int particle2, double length, double k)Â¶ Add a bond term to the force field. Parameters particle1 â the index of the first particle connected by the bond particle2 â the index of the second particle connected by the bond length â the equilibrium length of the bond, measured in nm k â the harmonic force constant for the bond, measured in kJ/mol/nm^2 Returns the index of the bond that was added void getBondParameters(int index, int &particle1, int &particle2, double &length, double &k) constÂ¶ Get the force field parameters for a bond term. Parameters index â the index of the bond for which to get parameters particle1 â [out] the index of the first particle connected by the bond particle2 â [out] the index of the second particle connected by the bond length â [out] the equilibrium length of the bond, measured in nm k â [out] the harmonic force constant for the bond, measured in kJ/mol/nm^2 void setBondParameters(int index, int particle1, int particle2, double length, double k)Â¶ Set the force field parameters for a bond term. Parameters index â the index of the bond for which to set parameters particle1 â the index of the first particle connected by the bond particle2 â the index of the second particle connected by the bond length â the equilibrium length of the bond, measured in nm k â the harmonic force constant for the bond, measured in kJ/mol/nm^2 void updateParametersInContext(Context &context)Â¶ Update the per-bond parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-bond parameters. The set of particles involved in a bond cannot be changed, nor can new bonds be added. void setUsesPeriodicBoundaryConditions(bool periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. virtual bool usesPeriodicBoundaryConditions() constÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_generated_LangevinIntegrator.html:
LangevinIntegratorÂ¶ class LangevinIntegrator : public OpenMM::IntegratorÂ¶ This is an Integrator which simulates a System using Langevin dynamics. Public Functions LangevinIntegrator(double temperature, double frictionCoeff, double stepSize)Â¶ Create a LangevinIntegrator. Parameters temperature â the temperature of the heat bath (in Kelvin) frictionCoeff â the friction coefficient which couples the system to the heat bath (in inverse picoseconds) stepSize â the step size with which to integrate the system (in picoseconds) inline double getTemperature() constÂ¶ Get the temperature of the heat bath (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin void setTemperature(double temp)Â¶ Set the temperature of the heat bath (in Kelvin). Parameters temp â the temperature of the heat bath, measured in Kelvin inline double getFriction() constÂ¶ Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Returns the friction coefficient, measured in 1/ps void setFriction(double coeff)Â¶ Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Parameters coeff â the friction coefficient, measured in 1/ps inline int getRandomNumberSeed() constÂ¶ Get the random number seed. See setRandomNumberSeed() for details. inline void setRandomNumberSeed(int seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. virtual void step(int steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps â the number of time steps to take

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_generated_MonteCarloBarostat.html:
MonteCarloBarostatÂ¶ class MonteCarloBarostat : public OpenMM::ForceÂ¶ This class uses a Monte Carlo algorithm to adjust the size of the periodic box, simulating the effect of constant pressure. This class assumes the simulation is also being run at constant temperature, and requires you to specify the system temperature (since it affects the acceptance probability for Monte Carlo moves). It does not actually perform temperature regulation, however. You must use another mechanism along with it to maintain the temperature, such as LangevinIntegrator or AndersenThermostat. Public Functions MonteCarloBarostat(double defaultPressure, double defaultTemperature, int frequency = 25)Â¶ Create a MonteCarloBarostat. Parameters defaultPressure â the default pressure acting on the system (in bar) defaultTemperature â the default temperature at which the system is being maintained (in Kelvin) frequency â the frequency at which Monte Carlo pressure changes should be attempted (in time steps) inline double getDefaultPressure() constÂ¶ Get the default pressure acting on the system (in bar). Returns the default pressure acting on the system, measured in bar. void setDefaultPressure(double pressure)Â¶ Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist. Parameters pressure â the default pressure acting on the system, measured in bar. inline int getFrequency() constÂ¶ Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. void setFrequency(int freq)Â¶ Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. inline double getDefaultTemperature() constÂ¶ Get the default temperature at which the system is being maintained, measured in Kelvin. void setDefaultTemperature(double temp)Â¶ Set the default temperature at which the system is being maintained. This will affect any new Contexts you create, but not ones that already exist. Parameters temp â the system temperature, measured in Kelvin. inline int getRandomNumberSeed() constÂ¶ Get the random number seed. See setRandomNumberSeed() for details. inline void setRandomNumberSeed(int seed)Â¶ Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. inline virtual bool usesPeriodicBoundaryConditions() constÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Public Static Functions static inline const std::string &Pressure()Â¶ This is the name of the parameter which stores the current pressure acting on the system (in bar). static inline const std::string &Temperature()Â¶ This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin)

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_generated_NonbondedForce.html:
NonbondedForceÂ¶ class NonbondedForce : public OpenMM::ForceÂ¶ This class implements nonbonded interactions between particles, including a Coulomb force to represent electrostatics and a Lennard-Jones force to represent van der Waals interactions. It optionally supports periodic boundary conditions and cutoffs for long range interactions. Lennard-Jones interactions are calculated with the Lorentz-Berthelot combining rule: it uses the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles. To use this class, create a NonbondedForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define nonbonded parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). NonbondedForce also lets you specify âexceptionsâ, particular pairs of particles whose interactions should be computed based on different parameters than those defined for the individual particles. This can be used to completely exclude certain interactions from the force calculation, or to alter how they interact with each other. Many molecular force fields omit Coulomb and Lennard-Jones interactions between particles separated by one or two bonds, while using modified parameters for those separated by three bonds (known as â1-4 interactionsâ). This class provides a convenience method for this case called createExceptionsFromBonds(). You pass to it a list of bonds and the scale factors to use for 1-4 interactions. It identifies all pairs of particles which are separated by 1, 2, or 3 bonds, then automatically creates exceptions for them. When using a cutoff, by default Lennard-Jones interactions are sharply truncated at the cutoff distance. Optionally you can instead use a switching function to make the interaction smoothly go to zero over a finite distance range. To enable this, call setUseSwitchingFunction(). You must also call setSwitchingDistance() to specify the distance at which the interaction should begin to decrease. The switching distance must be less than the cutoff distance. Another optional feature of this class (enabled by default) is to add a contribution to the energy which approximates the effect of all Lennard-Jones interactions beyond the cutoff in a periodic system. When running a simulation at constant pressure, this can improve the quality of the result. Call setUseDispersionCorrection() to set whether this should be used. In some applications, it is useful to be able to inexpensively change the parameters of small groups of particles. Usually this is done to interpolate between two sets of parameters. For example, a titratable group might have two states it can exist in, each described by a different set of parameters for the atoms that make up the group. You might then want to smoothly interpolate between the two states. This is done by first calling addGlobalParameter() to define a Context parameter, then addParticleParameterOffset() to create a âparameter offsetâ that depends on the Context parameter. Each offset defines the following: A Context parameter used to interpolate between the states. A single particle whose parameters are influenced by the Context parameter. Three scale factors (chargeScale, sigmaScale, and epsilonScale) that specify how the Context parameter affects the particle. The âeffectiveâ parameters for a particle (those used to compute forces) are given by charge = baseCharge + param*chargeScale sigma = baseSigma + param*sigmaScale epsilon = baseEpsilon + param*epsilonScale where the âbaseâ values are the ones specified by addParticle() and âoaramâ is the current value of the Context parameter. A single Context parameter can apply offsets to multiple particles, and multiple parameters can be used to apply offsets to the same particle. Parameters can also be used to modify exceptions in exactly the same way by calling addExceptionParameterOffset(). Public Types enum NonbondedMethodÂ¶ This is an enumeration of the different methods that may be used for handling long range nonbonded forces. Values: enumerator NoCutoffÂ¶ No cutoff is applied to nonbonded interactions. The full set of N^2 interactions is computed exactly. This necessarily means that periodic boundary conditions cannot be used. This is the default. enumerator CutoffNonPeriodicÂ¶ Interactions beyond the cutoff distance are ignored. Coulomb interactions closer than the cutoff distance are modified using the reaction field method. enumerator CutoffPeriodicÂ¶ Periodic boundary conditions are used, so that each particle interacts only with the nearest periodic copy of each other particle. Interactions beyond the cutoff distance are ignored. Coulomb interactions closer than the cutoff distance are modified using the reaction field method. enumerator EwaldÂ¶ Periodic boundary conditions are used, and Ewald summation is used to compute the Coulomb interaction of each particle with all periodic copies of every other particle. enumerator PMEÂ¶ Periodic boundary conditions are used, and Particle-Mesh Ewald (PME) summation is used to compute the Coulomb interaction of each particle with all periodic copies of every other particle. enumerator LJPMEÂ¶ Periodic boundary conditions are used, and Particle-Mesh Ewald (PME) summation is used to compute the interaction of each particle with all periodic copies of every other particle for both Coulomb and Lennard-Jones. No switching is used for either interaction. Public Functions NonbondedForce()Â¶ Create a NonbondedForce. inline int getNumParticles() constÂ¶ Get the number of particles for which force field parameters have been defined. inline int getNumExceptions() constÂ¶ Get the number of special interactions that should be calculated differently from other interactions. inline int getNumGlobalParameters() constÂ¶ Get the number of global parameters that have been added. inline int getNumParticleParameterOffsets() constÂ¶ Get the number of particles parameter offsets that have been added. inline int getNumExceptionParameterOffsets() constÂ¶ Get the number of exception parameter offsets that have been added. NonbondedMethod getNonbondedMethod() constÂ¶ Get the method used for handling long range nonbonded interactions. void setNonbondedMethod(NonbondedMethod method)Â¶ Set the method used for handling long range nonbonded interactions. double getCutoffDistance() constÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm void setCutoffDistance(double distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance â the cutoff distance, measured in nm bool getUseSwitchingFunction() constÂ¶ Get whether a switching function is applied to the Lennard-Jones interaction. If the nonbonded method is set to NoCutoff, this option is ignored. void setUseSwitchingFunction(bool use)Â¶ Set whether a switching function is applied to the Lennard-Jones interaction. If the nonbonded method is set to NoCutoff, this option is ignored. double getSwitchingDistance() constÂ¶ Get the distance at which the switching function begins to reduce the Lennard-Jones interaction. This must be less than the cutoff distance. void setSwitchingDistance(double distance)Â¶ Set the distance at which the switching function begins to reduce the Lennard-Jones interaction. This must be less than the cutoff distance. double getReactionFieldDielectric() constÂ¶ Get the dielectric constant to use for the solvent in the reaction field approximation. void setReactionFieldDielectric(double dielectric)Â¶ Set the dielectric constant to use for the solvent in the reaction field approximation. double getEwaldErrorTolerance() constÂ¶ Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however. For PME calculations, if setPMEParameters() is used to set alpha to something other than 0, this value is ignored. void setEwaldErrorTolerance(double tol)Â¶ Set the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however. For PME calculations, if setPMEParameters() is used to set alpha to something other than 0, this value is ignored. void getPMEParameters(double &alpha, int &nx, int &ny, int &nz) constÂ¶ Get the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha â [out] the separation parameter nx â [out] the number of grid points along the X axis ny â [out] the number of grid points along the Y axis nz â [out] the number of grid points along the Z axis void getLJPMEParameters(double &alpha, int &nx, int &ny, int &nz) constÂ¶ Get the parameters to use for dispersion term in LJ-PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha â [out] the separation parameter nx â [out] the number of dispersion grid points along the X axis ny â [out] the number of dispersion grid points along the Y axis nz â [out] the number of dispersion grid points along the Z axis void setPMEParameters(double alpha, int nx, int ny, int nz)Â¶ Set the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha â the separation parameter nx â the number of grid points along the X axis ny â the number of grid points along the Y axis nz â the number of grid points along the Z axis void setLJPMEParameters(double alpha, int nx, int ny, int nz)Â¶ Set the parameters to use for the dispersion term in LJPME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha â the separation parameter nx â the number of grid points along the X axis ny â the number of grid points along the Y axis nz â the number of grid points along the Z axis void getPMEParametersInContext(const Context &context, double &alpha, int &nx, int &ny, int &nz) constÂ¶ Get the parameters being used for PME in a particular Context. Because some platforms have restrictions on the allowed grid sizes, the values that are actually used may be slightly different from those specified with setPMEParameters(), or the standard values calculated based on the Ewald error tolerance. See the manual for details. Parameters context â the Context for which to get the parameters alpha â [out] the separation parameter nx â [out] the number of grid points along the X axis ny â [out] the number of grid points along the Y axis nz â [out] the number of grid points along the Z axis void getLJPMEParametersInContext(const Context &context, double &alpha, int &nx, int &ny, int &nz) constÂ¶ Get the PME parameters being used for the dispersion term for LJPME in a particular Context. Because some platforms have restrictions on the allowed grid sizes, the values that are actually used may be slightly different from those specified with setPMEParameters(), or the standard values calculated based on the Ewald error tolerance. See the manual for details. Parameters context â the Context for which to get the parameters alpha â [out] the separation parameter nx â [out] the number of grid points along the X axis ny â [out] the number of grid points along the Y axis nz â [out] the number of grid points along the Z axis int addParticle(double charge, double sigma, double epsilon)Â¶ Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. For calculating the Lennard-Jones interaction between two particles, the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles is used (the Lorentz-Berthelot combining rule). Parameters charge â the charge of the particle, measured in units of the proton charge sigma â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol Returns the index of the particle that was added void getParticleParameters(int index, double &charge, double &sigma, double &epsilon) constÂ¶ Get the nonbonded force parameters for a particle. Parameters index â the index of the particle for which to get parameters charge â [out] the charge of the particle, measured in units of the proton charge sigma â [out] the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon â [out] the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol void setParticleParameters(int index, double charge, double sigma, double epsilon)Â¶ Set the nonbonded force parameters for a particle. When calculating the Lennard-Jones interaction between two particles, it uses the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles (the Lorentz-Berthelot combining rule). Parameters index â the index of the particle for which to set parameters charge â the charge of the particle, measured in units of the proton charge sigma â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol int addException(int particle1, int particle2, double chargeProd, double sigma, double epsilon, bool replace = false)Â¶ Add an interaction to the list of exceptions that should be calculated differently from other interactions. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations. Regardless of the NonbondedMethod used by this Force, cutoffs are never applied to exceptions. That is because they are primarily used for 1-4 interactions, which are really a type of bonded interaction and are parametrized together with the other bonded interactions. In many cases, you can use createExceptionsFromBonds() rather than adding each exception explicitly. Parameters particle1 â the index of the first particle involved in the interaction particle2 â the index of the second particle involved in the interaction chargeProd â the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared sigma â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol replace â determines the behavior if there is already an exception for the same two particles. If true, the existing one is replaced. If false, an exception is thrown. Returns the index of the exception that was added void getExceptionParameters(int index, int &particle1, int &particle2, double &chargeProd, double &sigma, double &epsilon) constÂ¶ Get the force field parameters for an interaction that should be calculated differently from others. Parameters index â the index of the interaction for which to get parameters particle1 â [out] the index of the first particle involved in the interaction particle2 â [out] the index of the second particle involved in the interaction chargeProd â [out] the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared sigma â [out] the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon â [out] the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol void setExceptionParameters(int index, int particle1, int particle2, double chargeProd, double sigma, double epsilon)Â¶ Set the force field parameters for an interaction that should be calculated differently from others. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations. Regardless of the NonbondedMethod used by this Force, cutoffs are never applied to exceptions. That is because they are primarily used for 1-4 interactions, which are really a type of bonded interaction and are parametrized together with the other bonded interactions. Parameters index â the index of the interaction for which to get parameters particle1 â the index of the first particle involved in the interaction particle2 â the index of the second particle involved in the interaction chargeProd â the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared sigma â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol void createExceptionsFromBonds(const std::vector<std::pair<int, int>> &bonds, double coulomb14Scale, double lj14Scale)Â¶ Identify exceptions based on the molecular topology. Particles which are separated by one or two bonds are set to not interact at all, while pairs of particles separated by three bonds (known as â1-4 interactionsâ) have their Coulomb and Lennard-Jones interactions reduced by a fixed factor. Parameters bonds â the set of bonds based on which to construct exceptions. Each element specifies the indices of two particles that are bonded to each other. coulomb14Scale â pairs of particles separated by three bonds will have the strength of their Coulomb interaction multiplied by this factor lj14Scale â pairs of particles separated by three bonds will have the strength of their Lennard-Jones interaction multiplied by this factor int addGlobalParameter(const std::string &name, double defaultValue)Â¶ Add a new global parameter that parameter offsets may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name â the name of the parameter defaultValue â the default value of the parameter Returns the index of the parameter that was added const std::string &getGlobalParameterName(int index) constÂ¶ Get the name of a global parameter. Parameters index â the index of the parameter for which to get the name Returns the parameter name void setGlobalParameterName(int index, const std::string &name)Â¶ Set the name of a global parameter. Parameters index â the index of the parameter for which to set the name name â the name of the parameter double getGlobalParameterDefaultValue(int index) constÂ¶ Get the default value of a global parameter. Parameters index â the index of the parameter for which to get the default value Returns the parameter default value void setGlobalParameterDefaultValue(int index, double defaultValue)Â¶ Set the default value of a global parameter. Parameters index â the index of the parameter for which to set the default value defaultValue â the default value of the parameter int addParticleParameterOffset(const std::string &parameter, int particleIndex, double chargeScale, double sigmaScale, double epsilonScale)Â¶ Add an offset to the per-particle parameters of a particular particle, based on a global parameter. Parameters parameter â the name of the global parameter. It must have already been added with addGlobalParameter(). Its value can be modified at any time by calling Context::setParameter(). particleIndex â the index of the particle whose parameters are affected chargeScale â this value multiplied by the parameter value is added to the particleâs charge sigmaScale â this value multiplied by the parameter value is added to the particleâs sigma epsilonScale â this value multiplied by the parameter value is added to the particleâs epsilon Returns the index of the offset that was added void getParticleParameterOffset(int index, std::string &parameter, int &particleIndex, double &chargeScale, double &sigmaScale, double &epsilonScale) constÂ¶ Get the offset added to the per-particle parameters of a particular particle, based on a global parameter. Parameters index â the index of the offset to query, as returned by addParticleParameterOffset() parameter â the name of the global parameter particleIndex â the index of the particle whose parameters are affected chargeScale â this value multiplied by the parameter value is added to the particleâs charge sigmaScale â this value multiplied by the parameter value is added to the particleâs sigma epsilonScale â this value multiplied by the parameter value is added to the particleâs epsilon void setParticleParameterOffset(int index, const std::string &parameter, int particleIndex, double chargeScale, double sigmaScale, double epsilonScale)Â¶ Set the offset added to the per-particle parameters of a particular particle, based on a global parameter. Parameters index â the index of the offset to modify, as returned by addParticleParameterOffset() parameter â the name of the global parameter. It must have already been added with addGlobalParameter(). Its value can be modified at any time by calling Context::setParameter(). particleIndex â the index of the particle whose parameters are affected chargeScale â this value multiplied by the parameter value is added to the particleâs charge sigmaScale â this value multiplied by the parameter value is added to the particleâs sigma epsilonScale â this value multiplied by the parameter value is added to the particleâs epsilon int addExceptionParameterOffset(const std::string &parameter, int exceptionIndex, double chargeProdScale, double sigmaScale, double epsilonScale)Â¶ Add an offset to the parameters of a particular exception, based on a global parameter. Parameters parameter â the name of the global parameter. It must have already been added with addGlobalParameter(). Its value can be modified at any time by calling Context::setParameter(). exceptionIndex â the index of the exception whose parameters are affected chargeProdScale â this value multiplied by the parameter value is added to the exceptionâs charge product sigmaScale â this value multiplied by the parameter value is added to the exceptionâs sigma epsilonScale â this value multiplied by the parameter value is added to the exceptionâs epsilon Returns the index of the offset that was added void getExceptionParameterOffset(int index, std::string &parameter, int &exceptionIndex, double &chargeProdScale, double &sigmaScale, double &epsilonScale) constÂ¶ Get the offset added to the parameters of a particular exception, based on a global parameter. Parameters index â the index of the offset to query, as returned by addExceptionParameterOffset() parameter â the name of the global parameter exceptionIndex â the index of the exception whose parameters are affected chargeProdScale â this value multiplied by the parameter value is added to the exceptionâs charge product sigmaScale â this value multiplied by the parameter value is added to the exceptionâs sigma epsilonScale â this value multiplied by the parameter value is added to the exceptionâs epsilon void setExceptionParameterOffset(int index, const std::string &parameter, int exceptionIndex, double chargeProdScale, double sigmaScale, double epsilonScale)Â¶ Set the offset added to the parameters of a particular exception, based on a global parameter. Parameters index â the index of the offset to modify, as returned by addExceptionParameterOffset() parameter â the name of the global parameter. It must have already been added with addGlobalParameter(). Its value can be modified at any time by calling Context::setParameter(). exceptionIndex â the index of the exception whose parameters are affected chargeProdScale â this value multiplied by the parameter value is added to the exceptionâs charge product sigmaScale â this value multiplied by the parameter value is added to the exceptionâs sigma epsilonScale â this value multiplied by the parameter value is added to the exceptionâs epsilon inline bool getUseDispersionCorrection() constÂ¶ Get whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results. inline void setUseDispersionCorrection(bool useCorrection)Â¶ Set whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results. int getReciprocalSpaceForceGroup() constÂ¶ Get the force group that reciprocal space interactions for Ewald or PME are included in. This allows multiple time step integrators to evaluate direct and reciprocal space interactions at different intervals: getForceGroup() specifies the group for direct space, and getReciprocalSpaceForceGroup() specifies the group for reciprocal space. If this is -1 (the default value), the same force group is used for reciprocal space as for direct space. void setReciprocalSpaceForceGroup(int group)Â¶ Set the force group that reciprocal space interactions for Ewald or PME are included in. This allows multiple time step integrators to evaluate direct and reciprocal space interactions at different intervals: setForceGroup() specifies the group for direct space, and setReciprocalSpaceForceGroup() specifies the group for reciprocal space. If this is -1 (the default value), the same force group is used for reciprocal space as for direct space. Parameters group â the group index. Legal values are between 0 and 31 (inclusive), or -1 to use the same force group that is specified for direct space. bool getIncludeDirectSpace() constÂ¶ Get whether to include direct space interactions when calculating forces and energies. This is useful if you want to completely replace the direct space calculation, typically with a CustomNonbondedForce that computes it in a nonstandard way, while still using this object for the reciprocal space calculation. void setIncludeDirectSpace(bool include)Â¶ Set whether to include direct space interactions when calculating forces and energies. This is useful if you want to completely replace the direct space calculation, typically with a CustomNonbondedForce that computes it in a nonstandard way, while still using this object for the reciprocal space calculation. void updateParametersInContext(Context &context)Â¶ Update the particle and exception parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() and setExceptionParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the parameters of particles and exceptions. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, only the chargeProd, sigma, and epsilon values of an exception can be changed; the pair of particles involved in the exception cannot change. Finally, this method cannot be used to add new particles or exceptions, only to change the parameters of existing ones. inline virtual bool usesPeriodicBoundaryConditions() constÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise bool getExceptionsUsePeriodicBoundaryConditions() constÂ¶ Get whether periodic boundary conditions should be applied to exceptions. Usually this is not appropriate, because exceptions are normally used to represent bonded interactions (1-2, 1-3, and 1-4 pairs), but there are situations when it does make sense. For example, you may want to simulate an infinite chain where one end of a molecule is bonded to the opposite end of the next periodic copy. Regardless of this value, periodic boundary conditions are only applied to exceptions if they also are applied to other interactions. If the nonbonded method is NoCutoff or CutoffNonPeriodic, this value is ignored. Also note that cutoffs are never applied to exceptions, again because they are normally used to represent bonded interactions. void setExceptionsUsePeriodicBoundaryConditions(bool periodic)Â¶ Set whether periodic boundary conditions should be applied to exceptions. Usually this is not appropriate, because exceptions are normally used to represent bonded interactions (1-2, 1-3, and 1-4 pairs), but there are situations when it does make sense. For example, you may want to simulate an infinite chain where one end of a molecule is bonded to the opposite end of the next periodic copy. Regardless of this value, periodic boundary conditions are only applied to exceptions if they also get applied to other interactions. If the nonbonded method is NoCutoff or CutoffNonPeriodic, this value is ignored. Also note that cutoffs are never applied to exceptions, again because they are normally used to represent bonded interactions.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_generated_Platform.html:
PlatformÂ¶ class PlatformÂ¶ A Platform defines an implementation of all the kernels needed to perform some calculation. More precisely, a Platform object acts as a registry for a set of KernelFactory objects which together implement the kernels. The Platform class, in turn, provides a static registry of all available Platform objects. To get a Platform object, call Platform& platform = Platform::findPlatform(kernelNames); passing in the names of all kernels that will be required for the calculation you plan to perform. It will return the fastest available Platform which provides implementations of all the specified kernels. You can then call createKernel() to construct particular kernels as needed. Public Functions virtual const std::string &getName() const = 0Â¶ Get the name of this platform. This should be a unique identifier which can be used to recognized it. virtual double getSpeed() const = 0Â¶ Get an estimate of how fast this Platform class is. This need not be precise. It only is expected to return an order or magnitude estimate of the relative performance of different Platform classes. An unoptimized reference implementation should return 1.0, and all other Platforms should return a larger value that is an estimate of how many times faster they are than the reference implementation. virtual bool supportsDoublePrecision() const = 0Â¶ Get whether this Platform supports double precision arithmetic. If this returns false, the platform is permitted to represent double precision values internally as single precision. Deprecated: This method is not well defined, and is too simplistic to describe the actual behavior of some Platforms, such as ones that offer multiple precision modes. It will be removed in a future release. const std::vector<std::string> &getPropertyNames() constÂ¶ Get the names of all Platform-specific properties this Platform supports. virtual const std::string &getPropertyValue(const Context &context, const std::string &property) constÂ¶ Get the value of a Platform-specific property for a Context. Parameters context â the Context for which to get the property property â the name of the property to get Returns the value of the property virtual void setPropertyValue(Context &context, const std::string &property, const std::string &value) constÂ¶ Set the value of a Platform-specific property for a Context. Parameters context â the Context for which to set the property property â the name of the property to set value â the value to set for the property const std::string &getPropertyDefaultValue(const std::string &property) constÂ¶ Get the default value of a Platform-specific property. This is the value that will be used for newly created Contexts. Parameters property â the name of the property to get Returns the default value of the property void setPropertyDefaultValue(const std::string &property, const std::string &value)Â¶ Set the default value of a Platform-specific property. This is the value that will be used for newly created Contexts. Parameters property â the name of the property to set value â the value to set for the property virtual void contextCreated(ContextImpl &context, const std::map<std::string, std::string> &properties) constÂ¶ This is called whenever a new Context is created. It gives the Platform a chance to initialize the context and store platform-specific data in it. Parameters context â the newly created context properties â a set of values for platform-specific properties. Keys are the property names. virtual void linkedContextCreated(ContextImpl &context, ContextImpl &originalContext) constÂ¶ This is called whenever a new Context is created using ContextImpl::createLinkedContext(). It gives the Platform a chance to initialize the context and store platform-specific data in it. Parameters context â the newly created context originalContext â the original context it is linked to virtual void contextDestroyed(ContextImpl &context) constÂ¶ This is called whenever a Context is deleted. It gives the Platform a chance to clean up any platform-specific data that was stored in it. void registerKernelFactory(const std::string &name, KernelFactory *factory)Â¶ Register a KernelFactory which should be used to create Kernels with a particular name. The Platform takes over ownership of the factory, and will delete it when the Platform itself is deleted. Parameters name â the kernel name for which the factory should be used factory â the factory to use for creating Kernels with the specified name bool supportsKernels(const std::vector<std::string> &kernelNames) constÂ¶ Determine whether this Platforms provides implementations of a set of kernels. Parameters kernelNames â the names of the kernels of interests Returns true if this Platform provides implementations of all the kernels in the list, false if there are any which it does not support Kernel createKernel(const std::string &name, ContextImpl &context) constÂ¶ Create a Kernel object. If you call this method multiple times for different contexts with the same name, the returned Kernels are independent and do not interact with each other. This means that it is possible to have multiple simulations in progress at one time without them interfering. If no KernelFactory has been registered for the specified name, this will throw an exception. Parameters name â the name of the Kernel to get context â the context for which to create a Kernel Returns a newly created Kernel object Public Static Functions static void registerPlatform(Platform *platform)Â¶ Register a new Platform. static int getNumPlatforms()Â¶ Get the number of Platforms that have been registered. static Platform &getPlatform(int index)Â¶ Get a registered Platform by index. static std::vector<std::string> getPluginLoadFailures()Â¶ Get any failures caused during the last call to loadPluginsFromDirectory static Platform &getPlatformByName(const std::string &name)Â¶ Get the registered Platform with a particular name. If no Platform with that name has been registered, this throws an exception. static Platform &findPlatform(const std::vector<std::string> &kernelNames)Â¶ Find a Platform which can be used to perform a calculation. Parameters kernelNames â the names of all kernels which will be needed for the calculation Returns the fastest registered Platform which supports all of the requested kernels. If no Platform exists which supports all of them, this will throw an exception. static void loadPluginLibrary(const std::string &file)Â¶ Load a dynamic library (DLL) which contains an OpenMM plugin. Typically, each Platform is distributed as a separate dynamic library. This method can then be called at runtime to load each available library. Each library should contain an initializer function to register any Platforms and KernelFactories that it contains. If the file does not exist or cannot be loaded, an exception is thrown. Parameters file â the path to the dynamic library file. This is interpreted using the operating systemâs rules for loading libraries. Typically it may be either an absolute path or relative to a set of standard locations. static std::vector<std::string> loadPluginsFromDirectory(const std::string &directory)Â¶ Load multiple dynamic libraries (DLLs) which contain OpenMM plugins from one or more directories. Multiple fully-qualified paths can be joined together with â:â on unix-like systems (or â;â on windows-like systems); each will be searched for plugins, in-order. For example, â/foo/plugins:/bar/pluginsâ will search both /foo/plugins and /bar/plugins. If an identically-named plugin is encountered twice it will be loaded at both points; be careful!!! This method loops over every file contained in the specified directories and calls loadPluginLibrary() for each one. If an error occurs while trying to load a particular file, that file is simply ignored. You can retrieve a list of all such errors by calling getPluginLoadFailures(). Parameters directory â a â:â (unix) or â;â (windows) deliminated list of paths containing libraries to load Returns the names of all files which were successfully loaded as libraries static const std::string &getDefaultPluginsDirectory()Â¶ Get the default directory from which to load plugins. If the environment variable OPENMM_PLUGIN_DIR is set, this returns its value. Otherwise, it returns a platform specific default location. Returns the path to the default plugin directory static const std::string &getOpenMMVersion()Â¶ Get a string containing the version number of the OpenMM library.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_generated_System.html:
SystemÂ¶ class SystemÂ¶ This class represents a molecular system. The definition of a System involves four elements: The set of particles in the system The forces acting on them Pairs of particles whose separation should be constrained to a fixed value For periodic systems, the dimensions of the periodic box The particles and constraints are defined directly by the System object, while forces are defined by objects that extend the Force class. After creating a System, call addParticle() once for each particle, addConstraint() for each constraint, and addForce() for each Force. In addition, particles may be designated as âvirtual sitesâ. These are particles whose positions are computed automatically based on the positions of other particles. To define a virtual site, call setVirtualSite(), passing in a VirtualSite object that defines the rules for computing its position. Public Functions System()Â¶ Create a new System. inline int getNumParticles() constÂ¶ Get the number of particles in this System. inline int addParticle(double mass)Â¶ Add a particle to the System. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving. Parameters mass â the mass of the particle (in atomic mass units) Returns the index of the particle that was added double getParticleMass(int index) constÂ¶ Get the mass (in atomic mass units) of a particle. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving. Parameters index â the index of the particle for which to get the mass void setParticleMass(int index, double mass)Â¶ Set the mass (in atomic mass units) of a particle. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving. Parameters index â the index of the particle for which to set the mass mass â the mass of the particle void setVirtualSite(int index, VirtualSite *virtualSite)Â¶ Set a particle to be a virtual site. The VirtualSite object should have been created on the heap with the ânewâ operator. The System takes over ownership of it, and deletes it when the System itself is deleted. Parameters index â the index of the particle that should be treated as a virtual site virtualSite â a pointer to the VirtualSite object describing it inline bool isVirtualSite(int index) constÂ¶ Get whether a particle is a VirtualSite. Parameters index â the index of the particle to check const VirtualSite &getVirtualSite(int index) constÂ¶ Get VirtualSite object for a particle. If the particle is not a virtual site, this throws an exception. Parameters index â the index of the particle to get inline int getNumConstraints() constÂ¶ Get the number of distance constraints in this System. int addConstraint(int particle1, int particle2, double distance)Â¶ Add a constraint to the System. Particles whose mass is 0 cannot participate in constraints. Parameters particle1 â the index of the first particle involved in the constraint particle2 â the index of the second particle involved in the constraint distance â the required distance between the two particles, measured in nm Returns the index of the constraint that was added void getConstraintParameters(int index, int &particle1, int &particle2, double &distance) constÂ¶ Get the parameters defining a distance constraint. Parameters index â the index of the constraint for which to get parameters particle1 â [out] the index of the first particle involved in the constraint particle2 â [out] the index of the second particle involved in the constraint distance â [out] the required distance between the two particles, measured in nm void setConstraintParameters(int index, int particle1, int particle2, double distance)Â¶ Set the parameters defining a distance constraint. Particles whose mass is 0 cannot participate in constraints. Parameters index â the index of the constraint for which to set parameters particle1 â the index of the first particle involved in the constraint particle2 â the index of the second particle involved in the constraint distance â the required distance between the two particles, measured in nm void removeConstraint(int index)Â¶ Remove a constraint from the System. Parameters index â the index of the constraint to remove inline int addForce(Force *force)Â¶ Add a Force to the System. The Force should have been created on the heap with the ânewâ operator. The System takes over ownership of it, and deletes the Force when the System itself is deleted. Parameters force â a pointer to the Force object to be added Returns the index within the System of the Force that was added inline int getNumForces() constÂ¶ Get the number of Force objects that have been added to the System. const Force &getForce(int index) constÂ¶ Get a const reference to one of the Forces in this System. Parameters index â the index of the Force to get Force &getForce(int index)Â¶ Get a writable reference to one of the Forces in this System. Parameters index â the index of the Force to get void removeForce(int index)Â¶ Remove a Force from the System. The memory associated with the removed Force object is deleted. Parameters index â the index of the Force to remove void getDefaultPeriodicBoxVectors(Vec3 &a, Vec3 &b, Vec3 &c) constÂ¶ Get the default values of the vectors defining the axes of the periodic box (measured in nm). Any newly created Context will have its box vectors set to these. They will affect any Force added to the System that uses periodic boundary conditions. Parameters a â [out] the vector defining the first edge of the periodic box b â [out] the vector defining the second edge of the periodic box c â [out] the vector defining the third edge of the periodic box void setDefaultPeriodicBoxVectors(const Vec3 &a, const Vec3 &b, const Vec3 &c)Â¶ Set the default values of the vectors defining the axes of the periodic box (measured in nm). Any newly created Context will have its box vectors set to these. They will affect any Force added to the System that uses periodic boundary conditions. Triclinic boxes are supported, but the vectors must satisfy certain requirements. In particular, a must point in the x direction, b must point âmostlyâ in the y direction, and c must point âmostlyâ in the z direction. See the documentation for details. Parameters a â the vector defining the first edge of the periodic box b â the vector defining the second edge of the periodic box c â the vector defining the third edge of the periodic box bool usesPeriodicBoundaryConditions() constÂ¶ Returns whether or not any forces in this System use periodic boundaries. If a force in this System does not implement usesPeriodicBoundaryConditions a OpenMM::OpenMMException is thrown Returns true if at least one force uses PBC and false otherwise

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_generated_VerletIntegrator.html:
VerletIntegratorÂ¶ class VerletIntegrator : public OpenMM::IntegratorÂ¶ This is an Integrator which simulates a System using the leap-frog Verlet algorithm. Public Functions explicit VerletIntegrator(double stepSize)Â¶ Create a VerletIntegrator. Parameters stepSize â the step size with which to integrate the system (in picoseconds) virtual void step(int steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps â the number of time steps to take

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-c++_integrators.html:
IntegratorsÂ¶ The Integrator abstract classÂ¶ An Integrator implements an algorithm for advancing the simulation through time. Integrator is an abstract class; subclasses implement specific algorithms. Integrator General purpose integratorsÂ¶ These are integrators appropriate for traditional MD and BD simulations. BrownianIntegrator LangevinIntegrator LangevinMiddleIntegrator NoseHooverIntegrator VariableLangevinIntegrator VariableVerletIntegrator VerletIntegrator Drude integratorsÂ¶ These integrators permit modelling polarization with a Drude particle. DrudeIntegrator DrudeLangevinIntegrator DrudeNoseHooverIntegrator DrudeSCFIntegrator Ring Polymer Molecular Dynamics integratorsÂ¶ The RPMD integrator implements Ring Polymer MD. RPMDIntegrator Customizing IntegratorÂ¶ These classes facilitate customisation of the integrator. CustomIntegrator allows a wide variety of integration algorithms to be implemented efficiently without writing any low-level code. The integrator is built up as a series of steps, each defined as an algebraic expression. CompoundIntegrator allows different integrators to be combined by making it possible to switch the active integrator in the middle of a simulation. CustomIntegrator CompoundIntegrator

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python.html:
OpenMM Python APIÂ¶ The Python API provides information about the classes and methods available in OpenMM for Python developers. OpenMM consists of two parts. First, there is a set of libraries for performing many types of computations needed for molecular simulations: force evaluation, numerical integration, energy minimization, etc. Second, there is an application layer, a set of Python libraries providing a high level interface for running simulations. This layer is targeted at computational biologists or other people who want to run simulations, and who may or may not be programmers. See the user guide for more details. Application Layer Loaders and Setup Representation and Manipulation Simulation Reporting Output Extras Units Library Layer Core Objects Forces Integrators Extras

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_app.html:
Application LayerÂ¶ Loaders and SetupÂ¶ AmberInpcrdFile(file[,Â loadVelocities,Â â¦]) AmberInpcrdFile parses an AMBER inpcrd file and loads the data stored in it. AmberPrmtopFile(file[,Â periodicBoxVectors,Â â¦]) AmberPrmtopFile parses an AMBER prmtop file and constructs a Topology and (optionally) an OpenMM System from it. CharmmCrdFile(fname) Reads and parses a CHARMM coordinate file (.crd) into its components, namely the coordinates, CHARMM atom types, resname, etc. CharmmParameterSet(*args,Â **kwargs) Stores a parameter set defined by CHARMM files. CharmmPsfFile(psf_name[,Â â¦]) A chemical structure instantiated from CHARMM files. CharmmRstFile(fname) Reads and parses data, velocities and coordinates from a CHARMM restart file (.rst) of file name âfnameâ into class attributes DCDFile(file,Â topology,Â dt[,Â firstStep,Â â¦]) DCDFile provides methods for creating DCD files. DesmondDMSFile(file[,Â verbose]) DesmondDMSFile parses a Desmond DMS (desmond molecular system) and constructs a topology and (optionally) an OpenMM System from it GromacsGroFile(file) GromacsGroFile parses a Gromacs .gro file and constructs a set of atom positions from it. GromacsTopFile(file[,Â periodicBoxVectors,Â â¦]) GromacsTopFile parses a Gromacs top file and constructs a Topology and (optionally) an OpenMM System from it. PDBFile(file[,Â extraParticleIdentifier]) PDBFile parses a Protein Data Bank (PDB) file and constructs a Topology and a set of atom positions from it. PDBxFile(file) PDBxFile parses a PDBx/mmCIF file and constructs a Topology and a set of atom positions from it. XTCFile(fileName,Â topology,Â dt[,Â firstStep,Â â¦]) XTCFile provides methods for creating XTC files. Representation and ManipulationÂ¶ Topology() Topology stores the topological information about a system. Chain(index,Â topology,Â id) A Chain object represents a chain within a Topology. Residue(name,Â index,Â chain,Â id,Â insertionCode) A Residue object represents a residue within a Topology. Atom(name,Â element,Â index,Â residue,Â id) An Atom object represents an atom within a Topology. Modeller(topology,Â positions) Modeller provides tools for editing molecular models, such as adding water or missing hydrogens. SimulationÂ¶ ForceField(*files) A ForceField constructs OpenMM System objects based on a Topology. Simulation(topology,Â system,Â integrator[,Â â¦]) Simulation provides a simplified API for running simulations with OpenMM and reporting results. Reporting OutputÂ¶ CheckpointReporter(file,Â reportInterval[,Â â¦]) CheckpointReporter saves periodic checkpoints of a simulation. DCDReporter(file,Â reportInterval[,Â append,Â â¦]) DCDReporter outputs a series of frames from a Simulation to a DCD file. PDBReporter(file,Â reportInterval[,Â â¦]) PDBReporter outputs a series of frames from a Simulation to a PDB file. PDBxReporter(file,Â reportInterval[,Â â¦]) PDBxReporter outputs a series of frames from a Simulation to a PDBx/mmCIF file. StateDataReporter(file,Â reportInterval[,Â â¦]) StateDataReporter outputs information about a simulation, such as energy and temperature, to a file. XTCReporter(file,Â reportInterval[,Â append,Â â¦]) XTCReporter outputs a series of frames from a Simulation to a XTC file. ExtrasÂ¶ BiasVariable(force,Â minValue,Â maxValue,Â â¦) A collective variable that can be used to bias a simulation with metadynamics. CharmmPSFWarning For non-fatal PSF parsing issues Element(number,Â name,Â symbol,Â mass) An Element represents a chemical element. Metadynamics(system,Â variables,Â temperature,Â â¦) Performs metadynamics. SimulatedTempering(simulation[,Â â¦]) SimulatedTempering implements the simulated tempering algorithm for accelerated sampling. UnitsÂ¶ BaseDimension A physical dimension such as length, mass, or temperature. BaseUnit Physical unit expressed in exactly one BaseDimension. Quantity Physical quantity, such as 1.3 meters per second. ScaledUnit ScaledUnit is like a BaseUnit, but it is based on another Unit. SiPrefix Unit prefix that can be multiplied by a unit to yield a new unit. Unit Physical unit such as meter or ampere. UnitSystem A complete system of units defining the base unit in each dimension

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.amd.AMDForceGroupIntegrator.html:
AMDForceGroupIntegratorÂ¶ class openmm.amd.AMDForceGroupIntegrator(dt, group, alphaGroup, EGroup)Â¶ AMDForceGroupIntegrator implements a single boost aMD integration algorithm. This is similar to AMDIntegrator, but is applied based on the energy of a single force group (typically representing torsions). For details, see Hamelberg et al., J. Chem. Phys. 127, 155102 (2007). __init__(dt, group, alphaGroup, EGroup)Â¶ Create a AMDForceGroupIntegrator. Parameters dt (time) â The integration time step to use group (int) â The force group to apply the boost to alphaGroup (energy) â The alpha parameter to use for the boosted force group EGroup (energy) â The energy cutoff to use for the boosted force group Methods __init__(dt,Â group,Â alphaGroup,Â EGroup) Create a AMDForceGroupIntegrator. addComputeGlobal(self,Â variable,Â expression) Add a step to the integration algorithm that computes a global value. addComputePerDof(self,Â variable,Â expression) Add a step to the integration algorithm that computes a per-DOF value. addComputeSum(self,Â variable,Â expression) Add a step to the integration algorithm that computes a sum over degrees of freedom. addConstrainPositions(self) Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. addConstrainVelocities(self) Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. addGlobalVariable(self,Â name,Â initialValue) Define a new global variable. addPerDofVariable(self,Â name,Â initialValue) Define a new per-DOF variable. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in expressions. addUpdateContextState(self) Add a step to the integration algorithm that allows Forces to update the context state. beginIfBlock(self,Â condition) Add a step which begins a new âifâ block. beginWhileBlock(self,Â condition) Add a step which begins a new âwhileâ block. endBlock(self) Add a step which marks the end of the most recently begun âifâ or âwhileâ block. getAlphaGroup() Get the value of alpha for the boosted force group. getComputationStep(self,Â index) Get the details of a computation step that has been added to the integration algorithm. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getEGroup() Get the energy threshold E for the boosted force group. getEffectiveEnergy(groupEnergy) Given the actual group energy of the system, return the value of the effective potential. getGlobalVariable(self,Â index) Get the current value of a global variable. getGlobalVariableByName(self,Â name) Get the current value of a global variable, specified by name. getGlobalVariableName(self,Â index) Get the name of a global variable. getIntegrationForceGroups(self) Get which force groups to use for integration. getKineticEnergyExpression(self) Get the expression to use for computing the kinetic energy. getNumComputations(self) Get the number of computation steps that have been added. getNumGlobalVariables(self) Get the number of global variables that have been defined. getNumPerDofVariables(self) Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerDofVariable() getPerDofVariableByName(self,Â name) Get the value of a per-DOF variable, specified by name. getPerDofVariableName(self,Â index) Get the name of a per-DOF variable. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in expressions. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in expressions. setAlphaGroup(alpha) Set the value of alpha for the boosted force group. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setEGroup(E) Set the energy threshold E for the boosted force group. setGlobalVariable(self,Â index,Â value) Set the value of a global variable. setGlobalVariableByName(self,Â name,Â value) Set the value of a global variable, specified by name. setIntegrationForceGroups(groups) Set which force groups to use for integration. setKineticEnergyExpression(self,Â expression) Set the expression to use for computing the kinetic energy. setPerDofVariable(self,Â index,Â values) Set the value of a per-DOF variable. setPerDofVariableByName(self,Â name,Â values) Set the value of a per-DOF variable, specified by name. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes BlockEnd ComputeGlobal ComputePerDof ComputeSum ConstrainPositions ConstrainVelocities IfBlockStart UpdateContextState WhileBlockStart thisown The membership flag getAlphaGroup()Â¶ Get the value of alpha for the boosted force group. setAlphaGroup(alpha)Â¶ Set the value of alpha for the boosted force group. getEGroup()Â¶ Get the energy threshold E for the boosted force group. setEGroup(E)Â¶ Set the energy threshold E for the boosted force group. getEffectiveEnergy(groupEnergy)Â¶ Given the actual group energy of the system, return the value of the effective potential. Parameters groupEnergy (energy) â the actual potential energy of the boosted force group Returns the value of the effective potential Return type energy addComputeGlobal(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a global value. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving only global variables. In each integration step, its value is computed and stored into the specified variable. Returns the index of the step that was added Return type int addComputePerDof(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a per-DOF value. Parameters variable (string) â the per-DOF variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom and stored into the specified variable. Returns the index of the step that was added Return type int addComputeSum(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a sum over degrees of freedom. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom. Those values are then added together, and the sum is stored in the specified variable. Returns the index of the step that was added Return type int addConstrainPositions(self) → intÂ¶ Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. Returns the index of the step that was added Return type int addConstrainVelocities(self) → intÂ¶ Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. Returns the index of the step that was added Return type int addGlobalVariable(self, name, initialValue) → intÂ¶ Define a new global variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value Returns the index of the variable that was added Return type int addPerDofVariable(self, name, initialValue) → intÂ¶ Define a new per-DOF variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value for all degrees of freedom Returns the index of the variable that was added Return type int addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in expressions. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The integrator takes over ownership of it, and deletes it when the integrator itself is deleted. Returns the index of the function that was added Return type int addUpdateContextState(self) → intÂ¶ Add a step to the integration algorithm that allows Forces to update the context state. Returns the index of the step that was added Return type int beginIfBlock(self, condition) → intÂ¶ Add a step which begins a new âifâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed only if the condition is true. Returns the index of the step that was added Return type int beginWhileBlock(self, condition) → intÂ¶ Add a step which begins a new âwhileâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed repeatedly as long as the condition remains true. Returns the index of the step that was added Return type int endBlock(self) → intÂ¶ Add a step which marks the end of the most recently begun âifâ or âwhileâ block. Returns the index of the step that was added Return type int getComputationStep(self, index)Â¶ Get the details of a computation step that has been added to the integration algorithm. Parameters index (int) â the index of the computation step to get Returns type (ComputationType) â the type of computation this step performs variable (string) â the variable into which this step stores its result. If this step does not store a result in a variable, this will be an empty string. expression (string) â the expression this step evaluates. If this step does not evaluate an expression, this will be an empty string. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getGlobalVariable(self, index) → doubleÂ¶ Get the current value of a global variable. Parameters index (int) â the index of the variable to get Returns the current value of the variable Return type double getGlobalVariableByName(self, name) → doubleÂ¶ Get the current value of a global variable, specified by name. Parameters name (string) â the name of the variable to get Returns the current value of the parameter Return type double getGlobalVariableName(self, index) → std::string const &Â¶ Get the name of a global variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getKineticEnergyExpression(self) → std::string const &Â¶ Get the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. getNumComputations(self) → intÂ¶ Get the number of computation steps that have been added. getNumGlobalVariables(self) → intÂ¶ Get the number of global variables that have been defined. getNumPerDofVariables(self) → intÂ¶ Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getPerDofVariable(self, index)Â¶ getPerDofVariable(self, index) → PyObject * getPerDofVariableByName(self, name)Â¶ Get the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to get Returns values â the values of the variable for all degrees of freedom are stored into this Return type vector< Vec3 > getPerDofVariableName(self, index) → std::string const &Â¶ Get the name of a per-DOF variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setGlobalVariable(self, index, value)Â¶ Set the value of a global variable. Parameters index (int) â the index of the variable to set value (double) â the new value of the variable setGlobalVariableByName(self, name, value)Â¶ Set the value of a global variable, specified by name. Parameters name (string) â the name of the variable to set value (double) â the new value of the variable setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setKineticEnergyExpression(self, expression)Â¶ Set the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. setPerDofVariable(self, index, values)Â¶ Set the value of a per-DOF variable. Parameters index (int) â the index of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setPerDofVariableByName(self, name, values)Â¶ Set the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random numbers will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take property thisownÂ¶ The membership flag

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.amd.AMDIntegrator.html:
AMDIntegratorÂ¶ class openmm.amd.AMDIntegrator(dt, alpha, E)Â¶ AMDIntegrator implements the aMD integration algorithm. The system is integrated based on a modified potential. Whenever the energy V(r) is less than a cutoff value E, the following effective potential is used: V*(r) = V(r) + (E-V(r))^2 / (alpha+E-V(r)) For details, see Hamelberg et al., J. Chem. Phys. 127, 155102 (2007). __init__(dt, alpha, E)Â¶ Create an AMDIntegrator. Parameters dt (time) â The integration time step to use alpha (energy) â The alpha parameter to use E (energy) â The energy cutoff to use Methods __init__(dt,Â alpha,Â E) Create an AMDIntegrator. addComputeGlobal(self,Â variable,Â expression) Add a step to the integration algorithm that computes a global value. addComputePerDof(self,Â variable,Â expression) Add a step to the integration algorithm that computes a per-DOF value. addComputeSum(self,Â variable,Â expression) Add a step to the integration algorithm that computes a sum over degrees of freedom. addConstrainPositions(self) Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. addConstrainVelocities(self) Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. addGlobalVariable(self,Â name,Â initialValue) Define a new global variable. addPerDofVariable(self,Â name,Â initialValue) Define a new per-DOF variable. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in expressions. addUpdateContextState(self) Add a step to the integration algorithm that allows Forces to update the context state. beginIfBlock(self,Â condition) Add a step which begins a new âifâ block. beginWhileBlock(self,Â condition) Add a step which begins a new âwhileâ block. endBlock(self) Add a step which marks the end of the most recently begun âifâ or âwhileâ block. getAlpha() Get the value of alpha for the integrator. getComputationStep(self,Â index) Get the details of a computation step that has been added to the integration algorithm. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getE() Get the energy threshold E for the integrator. getEffectiveEnergy(energy) Given the actual potential energy of the system, return the value of the effective potential. getGlobalVariable(self,Â index) Get the current value of a global variable. getGlobalVariableByName(self,Â name) Get the current value of a global variable, specified by name. getGlobalVariableName(self,Â index) Get the name of a global variable. getIntegrationForceGroups(self) Get which force groups to use for integration. getKineticEnergyExpression(self) Get the expression to use for computing the kinetic energy. getNumComputations(self) Get the number of computation steps that have been added. getNumGlobalVariables(self) Get the number of global variables that have been defined. getNumPerDofVariables(self) Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerDofVariable() getPerDofVariableByName(self,Â name) Get the value of a per-DOF variable, specified by name. getPerDofVariableName(self,Â index) Get the name of a per-DOF variable. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in expressions. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in expressions. setAlpha(alpha) Set the value of alpha for the integrator. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setE(E) Set the energy threshold E for the integrator. setGlobalVariable(self,Â index,Â value) Set the value of a global variable. setGlobalVariableByName(self,Â name,Â value) Set the value of a global variable, specified by name. setIntegrationForceGroups(groups) Set which force groups to use for integration. setKineticEnergyExpression(self,Â expression) Set the expression to use for computing the kinetic energy. setPerDofVariable(self,Â index,Â values) Set the value of a per-DOF variable. setPerDofVariableByName(self,Â name,Â values) Set the value of a per-DOF variable, specified by name. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes BlockEnd ComputeGlobal ComputePerDof ComputeSum ConstrainPositions ConstrainVelocities IfBlockStart UpdateContextState WhileBlockStart thisown The membership flag getAlpha()Â¶ Get the value of alpha for the integrator. setAlpha(alpha)Â¶ Set the value of alpha for the integrator. getE()Â¶ Get the energy threshold E for the integrator. setE(E)Â¶ Set the energy threshold E for the integrator. getEffectiveEnergy(energy)Â¶ Given the actual potential energy of the system, return the value of the effective potential. addComputeGlobal(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a global value. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving only global variables. In each integration step, its value is computed and stored into the specified variable. Returns the index of the step that was added Return type int addComputePerDof(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a per-DOF value. Parameters variable (string) â the per-DOF variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom and stored into the specified variable. Returns the index of the step that was added Return type int addComputeSum(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a sum over degrees of freedom. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom. Those values are then added together, and the sum is stored in the specified variable. Returns the index of the step that was added Return type int addConstrainPositions(self) → intÂ¶ Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. Returns the index of the step that was added Return type int addConstrainVelocities(self) → intÂ¶ Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. Returns the index of the step that was added Return type int addGlobalVariable(self, name, initialValue) → intÂ¶ Define a new global variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value Returns the index of the variable that was added Return type int addPerDofVariable(self, name, initialValue) → intÂ¶ Define a new per-DOF variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value for all degrees of freedom Returns the index of the variable that was added Return type int addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in expressions. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The integrator takes over ownership of it, and deletes it when the integrator itself is deleted. Returns the index of the function that was added Return type int addUpdateContextState(self) → intÂ¶ Add a step to the integration algorithm that allows Forces to update the context state. Returns the index of the step that was added Return type int beginIfBlock(self, condition) → intÂ¶ Add a step which begins a new âifâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed only if the condition is true. Returns the index of the step that was added Return type int beginWhileBlock(self, condition) → intÂ¶ Add a step which begins a new âwhileâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed repeatedly as long as the condition remains true. Returns the index of the step that was added Return type int endBlock(self) → intÂ¶ Add a step which marks the end of the most recently begun âifâ or âwhileâ block. Returns the index of the step that was added Return type int getComputationStep(self, index)Â¶ Get the details of a computation step that has been added to the integration algorithm. Parameters index (int) â the index of the computation step to get Returns type (ComputationType) â the type of computation this step performs variable (string) â the variable into which this step stores its result. If this step does not store a result in a variable, this will be an empty string. expression (string) â the expression this step evaluates. If this step does not evaluate an expression, this will be an empty string. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getGlobalVariable(self, index) → doubleÂ¶ Get the current value of a global variable. Parameters index (int) â the index of the variable to get Returns the current value of the variable Return type double getGlobalVariableByName(self, name) → doubleÂ¶ Get the current value of a global variable, specified by name. Parameters name (string) â the name of the variable to get Returns the current value of the parameter Return type double getGlobalVariableName(self, index) → std::string const &Â¶ Get the name of a global variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getKineticEnergyExpression(self) → std::string const &Â¶ Get the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. getNumComputations(self) → intÂ¶ Get the number of computation steps that have been added. getNumGlobalVariables(self) → intÂ¶ Get the number of global variables that have been defined. getNumPerDofVariables(self) → intÂ¶ Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getPerDofVariable(self, index)Â¶ getPerDofVariable(self, index) → PyObject * getPerDofVariableByName(self, name)Â¶ Get the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to get Returns values â the values of the variable for all degrees of freedom are stored into this Return type vector< Vec3 > getPerDofVariableName(self, index) → std::string const &Â¶ Get the name of a per-DOF variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setGlobalVariable(self, index, value)Â¶ Set the value of a global variable. Parameters index (int) â the index of the variable to set value (double) â the new value of the variable setGlobalVariableByName(self, name, value)Â¶ Set the value of a global variable, specified by name. Parameters name (string) â the name of the variable to set value (double) â the new value of the variable setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setKineticEnergyExpression(self, expression)Â¶ Set the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. setPerDofVariable(self, index, values)Â¶ Set the value of a per-DOF variable. Parameters index (int) â the index of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setPerDofVariableByName(self, name, values)Â¶ Set the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random numbers will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take property thisownÂ¶ The membership flag

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.amd.DualAMDIntegrator.html:
DualAMDIntegratorÂ¶ class openmm.amd.DualAMDIntegrator(dt, group, alphaTotal, ETotal, alphaGroup, EGroup)Â¶ DualAMDIntegrator implements a dual boost aMD integration algorithm. This is similar to AMDIntegrator, but two different boosts are applied to the potential: one based on the total energy, and one based on the energy of a single force group (typically representing torsions). For details, see Hamelberg et al., J. Chem. Phys. 127, 155102 (2007). __init__(dt, group, alphaTotal, ETotal, alphaGroup, EGroup)Â¶ Create a DualAMDIntegrator. Parameters dt (time) â The integration time step to use group (int) â The force group to apply the second boost to alphaTotal (energy) â The alpha parameter to use for the total energy ETotal (energy) â The energy cutoff to use for the total energy alphaGroup (energy) â The alpha parameter to use for the boosted force group EGroup (energy) â The energy cutoff to use for the boosted force group Methods __init__(dt,Â group,Â alphaTotal,Â ETotal,Â â¦) Create a DualAMDIntegrator. addComputeGlobal(self,Â variable,Â expression) Add a step to the integration algorithm that computes a global value. addComputePerDof(self,Â variable,Â expression) Add a step to the integration algorithm that computes a per-DOF value. addComputeSum(self,Â variable,Â expression) Add a step to the integration algorithm that computes a sum over degrees of freedom. addConstrainPositions(self) Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. addConstrainVelocities(self) Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. addGlobalVariable(self,Â name,Â initialValue) Define a new global variable. addPerDofVariable(self,Â name,Â initialValue) Define a new per-DOF variable. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in expressions. addUpdateContextState(self) Add a step to the integration algorithm that allows Forces to update the context state. beginIfBlock(self,Â condition) Add a step which begins a new âifâ block. beginWhileBlock(self,Â condition) Add a step which begins a new âwhileâ block. endBlock(self) Add a step which marks the end of the most recently begun âifâ or âwhileâ block. getAlphaGroup() Get the value of alpha for the boosted force group. getAlphaTotal() Get the value of alpha for the total energy. getComputationStep(self,Â index) Get the details of a computation step that has been added to the integration algorithm. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getEGroup() Get the energy threshold E for the boosted force group. getETotal() Get the energy threshold E for the total energy. getEffectiveEnergy(totalEnergy,Â groupEnergy) Given the actual potential energy of the system, return the value of the effective potential. getGlobalVariable(self,Â index) Get the current value of a global variable. getGlobalVariableByName(self,Â name) Get the current value of a global variable, specified by name. getGlobalVariableName(self,Â index) Get the name of a global variable. getIntegrationForceGroups(self) Get which force groups to use for integration. getKineticEnergyExpression(self) Get the expression to use for computing the kinetic energy. getNumComputations(self) Get the number of computation steps that have been added. getNumGlobalVariables(self) Get the number of global variables that have been defined. getNumPerDofVariables(self) Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerDofVariable() getPerDofVariableByName(self,Â name) Get the value of a per-DOF variable, specified by name. getPerDofVariableName(self,Â index) Get the name of a per-DOF variable. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in expressions. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in expressions. setAlphaGroup(alpha) Set the value of alpha for the boosted force group. setAlphaTotal(alpha) Set the value of alpha for the total energy. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setEGroup(E) Set the energy threshold E for the boosted force group. setETotal(E) Set the energy threshold E for the total energy. setGlobalVariable(self,Â index,Â value) Set the value of a global variable. setGlobalVariableByName(self,Â name,Â value) Set the value of a global variable, specified by name. setIntegrationForceGroups(groups) Set which force groups to use for integration. setKineticEnergyExpression(self,Â expression) Set the expression to use for computing the kinetic energy. setPerDofVariable(self,Â index,Â values) Set the value of a per-DOF variable. setPerDofVariableByName(self,Â name,Â values) Set the value of a per-DOF variable, specified by name. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes BlockEnd ComputeGlobal ComputePerDof ComputeSum ConstrainPositions ConstrainVelocities IfBlockStart UpdateContextState WhileBlockStart thisown The membership flag getAlphaTotal()Â¶ Get the value of alpha for the total energy. setAlphaTotal(alpha)Â¶ Set the value of alpha for the total energy. getETotal()Â¶ Get the energy threshold E for the total energy. setETotal(E)Â¶ Set the energy threshold E for the total energy. getAlphaGroup()Â¶ Get the value of alpha for the boosted force group. setAlphaGroup(alpha)Â¶ Set the value of alpha for the boosted force group. getEGroup()Â¶ Get the energy threshold E for the boosted force group. setEGroup(E)Â¶ Set the energy threshold E for the boosted force group. getEffectiveEnergy(totalEnergy, groupEnergy)Â¶ Given the actual potential energy of the system, return the value of the effective potential. Parameters totalEnergy (energy) â the actual potential energy of the whole system groupEnergy (energy) â the actual potential energy of the boosted force group Returns the value of the effective potential Return type energy addComputeGlobal(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a global value. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving only global variables. In each integration step, its value is computed and stored into the specified variable. Returns the index of the step that was added Return type int addComputePerDof(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a per-DOF value. Parameters variable (string) â the per-DOF variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom and stored into the specified variable. Returns the index of the step that was added Return type int addComputeSum(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a sum over degrees of freedom. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom. Those values are then added together, and the sum is stored in the specified variable. Returns the index of the step that was added Return type int addConstrainPositions(self) → intÂ¶ Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. Returns the index of the step that was added Return type int addConstrainVelocities(self) → intÂ¶ Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. Returns the index of the step that was added Return type int addGlobalVariable(self, name, initialValue) → intÂ¶ Define a new global variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value Returns the index of the variable that was added Return type int addPerDofVariable(self, name, initialValue) → intÂ¶ Define a new per-DOF variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value for all degrees of freedom Returns the index of the variable that was added Return type int addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in expressions. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The integrator takes over ownership of it, and deletes it when the integrator itself is deleted. Returns the index of the function that was added Return type int addUpdateContextState(self) → intÂ¶ Add a step to the integration algorithm that allows Forces to update the context state. Returns the index of the step that was added Return type int beginIfBlock(self, condition) → intÂ¶ Add a step which begins a new âifâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed only if the condition is true. Returns the index of the step that was added Return type int beginWhileBlock(self, condition) → intÂ¶ Add a step which begins a new âwhileâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed repeatedly as long as the condition remains true. Returns the index of the step that was added Return type int endBlock(self) → intÂ¶ Add a step which marks the end of the most recently begun âifâ or âwhileâ block. Returns the index of the step that was added Return type int getComputationStep(self, index)Â¶ Get the details of a computation step that has been added to the integration algorithm. Parameters index (int) â the index of the computation step to get Returns type (ComputationType) â the type of computation this step performs variable (string) â the variable into which this step stores its result. If this step does not store a result in a variable, this will be an empty string. expression (string) â the expression this step evaluates. If this step does not evaluate an expression, this will be an empty string. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getGlobalVariable(self, index) → doubleÂ¶ Get the current value of a global variable. Parameters index (int) â the index of the variable to get Returns the current value of the variable Return type double getGlobalVariableByName(self, name) → doubleÂ¶ Get the current value of a global variable, specified by name. Parameters name (string) â the name of the variable to get Returns the current value of the parameter Return type double getGlobalVariableName(self, index) → std::string const &Â¶ Get the name of a global variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getKineticEnergyExpression(self) → std::string const &Â¶ Get the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. getNumComputations(self) → intÂ¶ Get the number of computation steps that have been added. getNumGlobalVariables(self) → intÂ¶ Get the number of global variables that have been defined. getNumPerDofVariables(self) → intÂ¶ Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getPerDofVariable(self, index)Â¶ getPerDofVariable(self, index) → PyObject * getPerDofVariableByName(self, name)Â¶ Get the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to get Returns values â the values of the variable for all degrees of freedom are stored into this Return type vector< Vec3 > getPerDofVariableName(self, index) → std::string const &Â¶ Get the name of a per-DOF variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setGlobalVariable(self, index, value)Â¶ Set the value of a global variable. Parameters index (int) â the index of the variable to set value (double) â the new value of the variable setGlobalVariableByName(self, name, value)Â¶ Set the value of a global variable, specified by name. Parameters name (string) â the name of the variable to set value (double) â the new value of the variable setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setKineticEnergyExpression(self, expression)Â¶ Set the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. setPerDofVariable(self, index, values)Â¶ Set the value of a per-DOF variable. Parameters index (int) â the index of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setPerDofVariableByName(self, name, values)Â¶ Set the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random numbers will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take property thisownÂ¶ The membership flag

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.amberinpcrdfile.AmberInpcrdFile.html:
AmberInpcrdFileÂ¶ class openmm.app.amberinpcrdfile.AmberInpcrdFile(file, loadVelocities=None, loadBoxVectors=None)Â¶ AmberInpcrdFile parses an AMBER inpcrd file and loads the data stored in it. __init__(file, loadVelocities=None, loadBoxVectors=None)Â¶ Load an inpcrd file. An inpcrd file contains atom positions and, optionally, velocities and periodic box dimensions. Parameters file (str) â The name of the file to load loadVelocities (bool) â Deprecated. Velocities are loaded automatically if present loadBoxVectors (bool) â Deprecated. Box vectors are loaded automatically if present Methods __init__(file[,Â loadVelocities,Â loadBoxVectors]) Load an inpcrd file. getBoxVectors([asNumpy]) Get the periodic box vectors. getPositions([asNumpy]) Get the atomic positions. getVelocities([asNumpy]) Get the atomic velocities. getPositions(asNumpy=False)Â¶ Get the atomic positions. Parameters asNumpy (bool=False) â if true, the values are returned as a numpy array instead of a list of Vec3s getVelocities(asNumpy=False)Â¶ Get the atomic velocities. Parameters asNumpy (bool=False) â if true, the vectors are returned as numpy arrays instead of Vec3s getBoxVectors(asNumpy=False)Â¶ Get the periodic box vectors. Parameters asNumpy (bool=False) â if true, the values are returned as a numpy array instead of a list of Vec3s

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.amberprmtopfile.AmberPrmtopFile.html:
AmberPrmtopFileÂ¶ class openmm.app.amberprmtopfile.AmberPrmtopFile(file, periodicBoxVectors=None, unitCellDimensions=None)Â¶ AmberPrmtopFile parses an AMBER prmtop file and constructs a Topology and (optionally) an OpenMM System from it. __init__(file, periodicBoxVectors=None, unitCellDimensions=None)Â¶ Load a prmtop file. filestrthe name of the file to load periodicBoxVectorstuple of Vec3=Nonethe vectors defining the periodic box unitCellDimensionsVec3=Nonethe dimensions of the crystallographic unit cell. For non-rectangular unit cells, specify periodicBoxVectors instead. Methods __init__(file[,Â periodicBoxVectors,Â â¦]) Load a prmtop file. createSystem([nonbondedMethod,Â â¦]) Construct an OpenMM System representing the topology described by this prmtop file. createSystem(nonbondedMethod=NoCutoff, nonbondedCutoff=Quantity(value=1.0, unit=nanometer), constraints=None, rigidWater=True, implicitSolvent=None, implicitSolventSaltConc=Quantity(value=0.0, unit=mole / liter), implicitSolventKappa=None, temperature=Quantity(value=298.15, unit=kelvin), soluteDielectric=1.0, solventDielectric=78.5, removeCMMotion=True, hydrogenMass=None, ewaldErrorTolerance=0.0005, switchDistance=Quantity(value=0.0, unit=nanometer), gbsaModel='ACE')Â¶ Construct an OpenMM System representing the topology described by this prmtop file. Parameters nonbondedMethod (object=NoCutoff) â The method to use for nonbonded interactions. Allowed values are NoCutoff, CutoffNonPeriodic, CutoffPeriodic, Ewald, PME, or LJPME. nonbondedCutoff (distance=1*nanometer) â The cutoff distance to use for nonbonded interactions constraints (object=None) â Specifies which bonds angles should be implemented with constraints. Allowed values are None, HBonds, AllBonds, or HAngles. rigidWater (boolean=True) â If true, water molecules will be fully rigid regardless of the value passed for the constraints argument implicitSolvent (object=None) â If not None, the implicit solvent model to use. Allowed values are HCT, OBC1, OBC2, GBn, or GBn2. implicitSolventSaltConc (float=0.0*unit.moles/unit.liter) â The salt concentration for GB calculations (modelled as a debye screening parameter). It is converted to the debye length (kappa) using the provided temperature and solventDielectric temperature (float=300*kelvin) â Temperature of the system. Only used to compute the Debye length from implicitSolventSoltConc implicitSolventKappa (float units of 1/length) â If this value is set, implicitSolventSaltConc will be ignored. soluteDielectric (float=1.0) â The solute dielectric constant to use in the implicit solvent model. solventDielectric (float=78.5) â The solvent dielectric constant to use in the implicit solvent model. removeCMMotion (boolean=True) â If true, a CMMotionRemover will be added to the System hydrogenMass (mass=None) â The mass to use for hydrogen atoms bound to heavy atoms. Any mass added to a hydrogen is subtracted from the heavy atom to keep their total mass the same. If rigidWater is used to make water molecules rigid, then water hydrogens are not altered. ewaldErrorTolerance (float=0.0005) â The error tolerance to use if nonbondedMethod is Ewald, PME, or LJPME. switchDistance (float=0*nanometers) â The distance at which the potential energy switching function is turned on for Lennard-Jones interactions. If the switchDistance is 0 or evaluates to boolean False, no switching function will be used. Values greater than nonbondedCutoff or less than 0 raise ValueError gbsaModel (str='ACE') â The SA model used to model the nonpolar solvation component of GB implicit solvent models. If GB is active, this must be âACEâ or None (the latter indicates no SA model will be used). Other values will result in a ValueError Returns the newly created System Return type System

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.charmmcrdfiles.CharmmCrdFile.html:
CharmmCrdFileÂ¶ class openmm.app.charmmcrdfiles.CharmmCrdFile(fname)Â¶ Reads and parses a CHARMM coordinate file (.crd) into its components, namely the coordinates, CHARMM atom types, resname, etc. natomÂ¶ Number of atoms in the system Type int resnameÂ¶ Names of all residues Type list positionsÂ¶ All cartesian coordinates [x1, y1, z1, x2, â¦] Type list Examples >>> chm = CharmmCrdFile('testfiles/1tnm.crd') >>> print '%d atoms; %d coords' % (chm.natom, len(chm.positions)) 1414 atoms; 1414 coords __init__(fname)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(fname) Initialize self.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.charmmcrdfiles.CharmmRstFile.html:
CharmmRstFileÂ¶ class openmm.app.charmmcrdfiles.CharmmRstFile(fname)Â¶ Reads and parses data, velocities and coordinates from a CHARMM restart file (.rst) of file name âfnameâ into class attributes natomÂ¶ Number of atoms in the system Type int resnameÂ¶ Names of all residues Type list positionsÂ¶ All cartesian coordinates [x1, y1, z1, x2, â¦] Type list positionsoldÂ¶ Old cartesian coordinates Type list velocitiesÂ¶ List of all cartesian velocities Type list Examples >>> chm = CharmmRstFile('testfiles/sample-charmm.rst') >>> print chm.header[0] REST 37 1 >>> natom, nc, nco = chm.natom, len(chm.positions), len(chm.positionsold) >>> nv = len(chm.velocities) >>> print '%d atoms; %d crds; %d old crds; %d vels' % (natom, nc, nco, nv) 256 atoms; 256 crds; 256 old crds; 256 vels __init__(fname)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(fname) Initialize self. printcoords(crds)

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.charmmparameterset.CharmmParameterSet.html:
CharmmParameterSetÂ¶ class openmm.app.charmmparameterset.CharmmParameterSet(*args, **kwargs)Â¶ Stores a parameter set defined by CHARMM files. It stores the equivalent of the information found in the MASS section of the CHARMM topology file (TOP/RTF) and all of the information in the parameter files (PAR) Parameters filenames (List of topology, parameter, and stream files to load into the parameter set.) â The following file type suffixes are recognized. Unrecognized file types raise a TypeError .rtf, .top â Residue topology file .par, .prm â Parameter file .str â Stream file .inp â If âparâ is in the file name, it is a parameter file. Ifâtopâ is in the file name, it is a topology file. Otherwise, raise TypeError All type lists are dictionaries whose keys are tuples (with however many elements are needed to define that type of parameter). The types that can be in any order are SORTED. - atom_types_str - atom_types_int - atom_types_tuple - bond_types - angle_types - urey_bradley_types - dihedral_types - improper_types - cmap_types - nbfix_types The dihedral types can be multiterm, so the values for each dict key is actually a list of DihedralType instances. The atom_types are dicts that match the name (str), number (int), or (name, number) tuple (tuple) to the atom type. The tuple is guaranteed to be the most robust, although when only the integer or string is available the other dictionaries are helpfulÂ¶ Examples >>> params = CharmmParameterSet('charmm22.top', 'charmm22.par', 'file.str') __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. condense() This function goes through each of the parameter type dicts and eliminates duplicate types. loadSet([tfile,Â pfile,Â sfiles,Â permissive]) Instantiates a CharmmParameterSet from a Topology file and a Parameter file (or just a Parameter file if it has all information) readParameterFile(pfile[,Â permissive]) Reads all of the parameters from a parameter file. readStreamFile(sfile) Reads RTF and PAR sections from a stream file and dispatches the sections to readTopologyFile or readParameterFile readTopologyFile(tfile) Reads _only_ the atom type definitions from a topology file. classmethod loadSet(tfile=None, pfile=None, sfiles=[], permissive=False)Â¶ Instantiates a CharmmParameterSet from a Topology file and a Parameter file (or just a Parameter file if it has all information) Parameters tfile (str) â Name of the Topology (RTF/TOP) file pfile (str) â Name of the Parameter (PAR) file sfiles (list of str) â List or tuple of stream (STR) file names. permissive (bool=False) â Accept non-bonbded parameters for undefined atom types Returns New CharmmParameterSet populated with the parameters found in the provided files. Return type CharmmParameterSet Notes The RTF file is read first (if provided), followed by the PAR file, followed by the list of stream files (in the order they are provided). Parameters in each stream file will overwrite those that came before (or simply append to the existing set if they are different) readParameterFile(pfile, permissive=False)Â¶ Reads all of the parameters from a parameter file. Versions 36 and later of the CHARMM force field files have an ATOMS section defining all of the atom types. Older versions need to load this information from the RTF/TOP files. Parameters pfile (str) â Name of the CHARMM PARameter file to read permissive (bool) â Accept non-bonbded parameters for undefined atom types (default: False). Notes The atom types must all be loaded by the end of this routine. Either supply a PAR file with atom definitions in them or read in a RTF/TOP file first. Failure to do so will result in a raised RuntimeError. readTopologyFile(tfile)Â¶ Reads _only_ the atom type definitions from a topology file. This is unnecessary for versions 36 and later of the CHARMM force field. Parameters tfile (str) â : Name of the CHARMM TOPology file to read Notes The CHARMM TOPology file is also called a Residue Topology File readStreamFile(sfile)Â¶ Reads RTF and PAR sections from a stream file and dispatches the sections to readTopologyFile or readParameterFile Parameters sfile (str or CharmmStreamFile) â Stream file to parse condense()Â¶ This function goes through each of the parameter type dicts and eliminates duplicate types. After calling this function, every unique bond, angle, dihedral, improper, or cmap type will pair with EVERY key in the type mapping dictionaries that points to the equivalent type Example >>> params = CharmmParameterSet('charmm.prm').condense()

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.charmmpsffile.CharmmPsfFile.html:
CharmmPsfFileÂ¶ class openmm.app.charmmpsffile.CharmmPsfFile(psf_name, periodicBoxVectors=None, unitCellDimensions=None)Â¶ A chemical structure instantiated from CHARMM files. This structure has numerous attributes that are lists of the elements of this structure, including atoms, bonds, torsions, etc. The attributes are residue_list atom_list bond_list angle_list dihedral_list dihedral_parameter_list improper_list cmap_list donor_list # hbonds donors? acceptor_list # hbond acceptors? group_list # list of nonbonded interaction groups Four additional lists for Drude psf: - drudeconsts_list - drudepair_list - lonepair_list - aniso_list Additional attribute is available if a CharmmParameterSet is loaded into this structure. urey_bradley_list The lengths of each of these lists gives the pointers (e.g., natom, nres, etc.) Examples >>> cs = CharmmPsfFile("testfiles/test.psf") >>> len(cs.atom_list) 33 >>> len(cs.bond_list) 32 __init__(psf_name, periodicBoxVectors=None, unitCellDimensions=None)Â¶ Opens and parses a PSF file, then instantiates a CharmmPsfFile instance from the data. Parameters psf_name (str) â Name of the PSF file (it must exist) periodicBoxVectors (tuple of Vec3) â the vectors defining the periodic box unitCellDimensions (Vec3) â the dimensions of the crystallographic unit cell. For non-rectangular unit cells, specify periodicBoxVectors instead. :raises IOError : If file âpsf_nameâ does not exist: :raises CharmmPSFError: If any parsing errors are encountered: Methods __init__(psf_name[,Â periodicBoxVectors,Â â¦]) Opens and parses a PSF file, then instantiates a CharmmPsfFile instance from the data. createSystem(params[,Â nonbondedMethod,Â â¦]) Construct an OpenMM System representing the topology described by the prmtop file. deleteCmap() Deletes the CMAP terms from the CHARMM PSF loadParameters(parmset) Loads parameters from a parameter set that was loaded via CHARMM RTF, PAR, and STR files. setBox(a,Â b,Â c[,Â alpha,Â beta,Â gamma]) Sets the periodic box boundary conditions. Attributes ANGLE_FORCE_GROUP BOND_FORCE_GROUP CMAP_FORCE_GROUP DIHEDRAL_FORCE_GROUP DRUDE_FORCE_GROUP GB_FORCE_GROUP IMPROPER_FORCE_GROUP NONBONDED_FORCE_GROUP UREY_BRADLEY_FORCE_GROUP boxLengths Return tuple of 3 units boxVectors Return the box vectors system Return the cached system class â it needs to be initialized via âcreateSystemâ first! topology Create an OpenMM Topology object from the stored bonded network loadParameters(parmset)Â¶ Loads parameters from a parameter set that was loaded via CHARMM RTF, PAR, and STR files. Parameters parmset (CharmmParameterSet) â List of all parameters Notes If any parameters that are necessary cannot be found, a MissingParameter exception is raised. If any dihedral or improper parameters cannot be found, I will try inserting wildcards (at either end for dihedrals and as the two central atoms in impropers) and see if that matches. Wild-cards will apply ONLY if specific parameters cannot be found. This method will expand the dihedral_parameter_list attribute by adding a separate Dihedral object for each term for types that have a multi-term expansion setBox(a, b, c, alpha=Quantity(value=90.0, unit=degree), beta=Quantity(value=90.0, unit=degree), gamma=Quantity(value=90.0, unit=degree))Â¶ Sets the periodic box boundary conditions. Parameters a (length) â Lengths of the periodic cell b (length) â Lengths of the periodic cell c (length) â Lengths of the periodic cell alpha (floats, optional) â Angles between the periodic cell vectors. beta (floats, optional) â Angles between the periodic cell vectors. gamma (floats, optional) â Angles between the periodic cell vectors. property topologyÂ¶ Create an OpenMM Topology object from the stored bonded network createSystem(params, nonbondedMethod=NoCutoff, nonbondedCutoff=Quantity(value=1.0, unit=nanometer), switchDistance=Quantity(value=0.0, unit=nanometer), constraints=None, rigidWater=True, implicitSolvent=None, implicitSolventKappa=None, implicitSolventSaltConc=Quantity(value=0.0, unit=mole / liter), temperature=Quantity(value=298.15, unit=kelvin), soluteDielectric=1.0, solventDielectric=78.5, removeCMMotion=True, hydrogenMass=None, ewaldErrorTolerance=0.0005, flexibleConstraints=True, verbose=False, gbsaModel=None, drudeMass=Quantity(value=0.4, unit=dalton))Â¶ Construct an OpenMM System representing the topology described by the prmtop file. You MUST have loaded a parameter set into this PSF before calling createSystem. If not, AttributeError will be raised. ValueError is raised for illegal input. Parameters params (CharmmParameterSet) â The parameter set to use to parametrize this molecule nonbondedMethod (object=NoCutoff) â The method to use for nonbonded interactions. Allowed values are NoCutoff, CutoffNonPeriodic, CutoffPeriodic, Ewald, PME, or LJPME. nonbondedCutoff (distance=1*nanometer) â The cutoff distance to use for nonbonded interactions. switchDistance (distance=0*nanometer) â The distance at which the switching function is active for nonbonded interactions. If the switchDistance evaluates to boolean False (if it is 0), no switching function will be used. Illegal values will raise a ValueError constraints (object=None) â Specifies which bonds or angles should be implemented with constraints. Allowed values are None, HBonds, AllBonds, or HAngles. rigidWater (boolean=True) â If true, water molecules will be fully rigid regardless of the value passed for the constraints argument implicitSolvent (object=None) â If not None, the implicit solvent model to use. Allowed values are HCT, OBC1, OBC2, or GBn implicitSolventKappa (float=None) â Debye screening parameter to model salt concentrations in GB solvent. implicitSolventSaltConc (float=0.0*u.moles/u.liter) â Salt concentration for GB simulations. Converted to Debye length kappa temperature (float=298.15*u.kelvin) â Temperature used in the salt concentration-to-kappa conversion for GB salt concentration term soluteDielectric (float=1.0) â The solute dielectric constant to use in the implicit solvent model. solventDielectric (float=78.5) â The solvent dielectric constant to use in the implicit solvent model. removeCMMotion (boolean=True) â If true, a CMMotionRemover will be added to the System. hydrogenMass (mass=None) â The mass to use for hydrogen atoms bound to heavy atoms. Any mass added to a hydrogen is subtracted from the heavy atom to keep their total mass the same. If rigidWater is used to make water molecules rigid, then water hydrogens are not altered. ewaldErrorTolerance (float=0.0005) â The error tolerance to use if the nonbonded method is Ewald, PME, or LJPME. flexibleConstraints (bool=True) â If True, parameters for constrained degrees of freedom will be added to the System verbose (bool=False) â Optionally prints out a running progress report gbsaModel (str=None) â Can be ACE (to use the ACE solvation model) or None. Other values raise a ValueError drudeMass (mass=0.4*amu) â The mass to use for Drude particles. Any mass added to a Drude particle is subtracted from its parent atom to keep their total mass the same. property systemÂ¶ Return the cached system class â it needs to be initialized via âcreateSystemâ first! property boxLengthsÂ¶ Return tuple of 3 units property boxVectorsÂ¶ Return the box vectors deleteCmap()Â¶ Deletes the CMAP terms from the CHARMM PSF

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.checkpointreporter.CheckpointReporter.html:
CheckpointReporterÂ¶ class openmm.app.checkpointreporter.CheckpointReporter(file, reportInterval, writeState=False)Â¶ CheckpointReporter saves periodic checkpoints of a simulation. The checkpoints will overwrite one another â only the last checkpoint will be saved in the file. Optionally you can saved serialized State objects instead of checkpoints. This is a more portable but less thorough way of recording the state of a simulation. To use it, create a CheckpointReporter, then add it to the Simulationâs list of reporters. To load a checkpoint file and continue a simulation, use the following recipe: >>> simulation.loadCheckpoint('checkpoint.chk') Reloading a saved State can be done like this: >>> simulation.loadState('state.xml') Notes: A checkpoint contains not only publicly visible data such as the particle positions and velocities, but also internal data such as the states of random number generators. Ideally, loading a checkpoint should restore the Context to an identical state to when it was written, such that continuing the simulation will produce an identical trajectory. This is not strictly guaranteed to be true, however, and should not be relied on. For most purposes, however, the internal state should be close enough to be reasonably considered equivalent. A checkpoint contains data that is highly specific to the Context from which it was created. It depends on the details of the System, the Platform being used, and the hardware and software of the computer it was created on. If you try to load it on a computer with different hardware, or for a System that is different in any way, loading is likely to fail. Checkpoints created with different versions of OpenMM are also often incompatible. If a checkpoint cannot be loaded, that is signaled by throwing an exception. In contrast, a State contains only the publicly visible data: positions, velocities, global parameters, box vectors, etc. This makes it much more portable. Reloading the State will put the Simulation back into approximately the same state it had before, but you should not expect it to produce an identical trajectory to the original Simulation. __init__(file, reportInterval, writeState=False)Â¶ Create a CheckpointReporter. Parameters file (string or open file object) â The file to write to. Any current contents will be overwritten. If this is a file object, it should have been opened in binary mode if writeState is false, or in text mode if writeState is true. reportInterval (int) â The interval (in time steps) at which to write checkpoints. writeState (bool=False) â If true, write serialized State objects. If false, write checkpoints. Methods __init__(file,Â reportInterval[,Â writeState]) Create a CheckpointReporter. describeNextReport(simulation) Get information about the next report this object will generate. report(simulation,Â state) Generate a report. describeNextReport(simulation)Â¶ Get information about the next report this object will generate. Parameters simulation (Simulation) â The Simulation to generate a report for Returns A five element tuple. The first element is the number of steps until the next report. The remaining elements specify whether that report will require positions, velocities, forces, and energies respectively. Return type tuple report(simulation, state)Â¶ Generate a report. Parameters simulation (Simulation) â The Simulation to generate a report for state (State) â The current state of the simulation

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.dcdfile.DCDFile.html:
DCDFileÂ¶ class openmm.app.dcdfile.DCDFile(file, topology, dt, firstStep=0, interval=1, append=False)Â¶ DCDFile provides methods for creating DCD files. DCD is a file format for storing simulation trajectories. It is supported by many programs, such as CHARMM, NAMD, and X-PLOR. Note, however, that different programs produce subtly different versions of the format. This class generates the CHARMM version. Also note that there is no standard byte ordering (big-endian or little-endian) for this format. This class always generates files with little-endian ordering. To use this class, create a DCDFile object, then call writeModel() once for each model in the file. __init__(file, topology, dt, firstStep=0, interval=1, append=False)Â¶ Create a DCD file and write out the header, or open an existing file to append. Parameters file (file) â A file to write to topology (Topology) â The Topology defining the molecular system being written dt (time) â The time step used in the trajectory firstStep (int=0) â The index of the first step in the trajectory interval (int=1) â The frequency (measured in time steps) at which states are written to the trajectory append (bool=False) â If True, open an existing DCD file to append to. If False, create a new file. Methods __init__(file,Â topology,Â dt[,Â firstStep,Â â¦]) Create a DCD file and write out the header, or open an existing file to append. writeModel(positions[,Â unitCellDimensions,Â â¦]) Write out a model to the DCD file. writeModel(positions, unitCellDimensions=None, periodicBoxVectors=None)Â¶ Write out a model to the DCD file. The periodic box can be specified either by the unit cell dimensions (for a rectangular box), or the full set of box vectors (for an arbitrary triclinic box). If neither is specified, the box vectors specified in the Topology will be used. Regardless of the value specified, no dimensions will be written if the Topology does not represent a periodic system. Parameters positions (list) â The list of atomic positions to write unitCellDimensions (Vec3=None) â The dimensions of the crystallographic unit cell. periodicBoxVectors (tuple of Vec3=None) â The vectors defining the periodic box.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.dcdreporter.DCDReporter.html:
DCDReporterÂ¶ class openmm.app.dcdreporter.DCDReporter(file, reportInterval, append=False, enforcePeriodicBox=None)Â¶ DCDReporter outputs a series of frames from a Simulation to a DCD file. To use it, create a DCDReporter, then add it to the Simulationâs list of reporters. __init__(file, reportInterval, append=False, enforcePeriodicBox=None)Â¶ Create a DCDReporter. Parameters file (string) â The file to write to reportInterval (int) â The interval (in time steps) at which to write frames append (bool=False) â If True, open an existing DCD file to append to. If False, create a new file. enforcePeriodicBox (bool) â Specifies whether particle positions should be translated so the center of every molecule lies in the same periodic box. If None (the default), it will automatically decide whether to translate molecules based on whether the system being simulated uses periodic boundary conditions. Methods __init__(file,Â reportInterval[,Â append,Â â¦]) Create a DCDReporter. describeNextReport(simulation) Get information about the next report this object will generate. report(simulation,Â state) Generate a report. describeNextReport(simulation)Â¶ Get information about the next report this object will generate. Parameters simulation (Simulation) â The Simulation to generate a report for Returns A six element tuple. The first element is the number of steps until the next report. The next four elements specify whether that report will require positions, velocities, forces, and energies respectively. The final element specifies whether positions should be wrapped to lie in a single periodic box. Return type tuple report(simulation, state)Â¶ Generate a report. Parameters simulation (Simulation) â The Simulation to generate a report for state (State) â The current state of the simulation

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.desmonddmsfile.DesmondDMSFile.html:
DesmondDMSFileÂ¶ class openmm.app.desmonddmsfile.DesmondDMSFile(file, verbose=False)Â¶ DesmondDMSFile parses a Desmond DMS (desmond molecular system) and constructs a topology and (optionally) an OpenMM System from it __init__(file, verbose=False)Â¶ Load a DMS file Parameters file (list of strings (multiple files, each containing a molecule)) â or â file â name(s) of the file to load (the) â Methods __init__(file[,Â verbose]) Load a DMS file close() Close the SQL connections createSystem([nonbondedMethod,Â â¦]) Construct an OpenMM System representing the topology described by this DMS file getPositions() Get the positions of each atom in the system getProvenance() Get the provenance string of this system getTopology() Get the topology of the system getVelocities() Get the positions of each atom in the system setPositions(positions) Update atomic positions in attached DMS files setVelocities(velocities) Update atomic velocities in attached DMS files getPositions()Â¶ Get the positions of each atom in the system getVelocities()Â¶ Get the positions of each atom in the system getTopology()Â¶ Get the topology of the system getProvenance()Â¶ Get the provenance string of this system setPositions(positions)Â¶ Update atomic positions in attached DMS files setVelocities(velocities)Â¶ Update atomic velocities in attached DMS files createSystem(nonbondedMethod=NoCutoff, nonbondedCutoff=Quantity(value=1.0, unit=nanometer), ewaldErrorTolerance=0.0005, removeCMMotion=True, hydrogenMass=None, OPLS=False, implicitSolvent=None, AGBNPVersion=1)Â¶ Construct an OpenMM System representing the topology described by this DMS file Parameters nonbondedMethod (object=NoCutoff) â The method to use for nonbonded interactions. Allowed values are NoCutoff, CutoffNonPeriodic, CutoffPeriodic, Ewald, PME, or LJPME. nonbondedCutoff (distance=1*nanometer) â The cutoff distance to use for nonbonded interactions ewaldErrorTolerance (float=0.0005) â The error tolerance to use if nonbondedMethod is Ewald, PME, or LJPME. removeCMMotion (boolean=True) â If true, a CMMotionRemover will be added to the System hydrogenMass (mass=None) â The mass to use for hydrogen atoms bound to heavy atoms. Any mass added to a hydrogen is subtracted from the heavy atom to keep their total mass the same. OPLS (boolean=False) â If True, forces OPLS combining rules implicitSolvent (string=None) â If not None, creates implicit solvent force of the given name Allowed values are: HCT and âAGBNPâ (the corresponding tables must be present in the DMS file) AGBNPVersion (int=1) â AGBNP implicit solvent version close()Â¶ Close the SQL connections

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.element.Element.html:
ElementÂ¶ class openmm.app.element.Element(number, name, symbol, mass)Â¶ An Element represents a chemical element. The openmm.app.element module contains objects for all the standard chemical elements, such as element.hydrogen or element.carbon. You can also call the static method Element.getBySymbol() to look up the Element with a particular chemical symbol. Element objects should be considered immutable __init__(number, name, symbol, mass)Â¶ Create a new element Parameters number (int) â The atomic number of the element name (string) â The name of the element symbol (string) â The chemical symbol of the element mass (float) â The atomic mass of the element Methods __init__(number,Â name,Â symbol,Â mass) Create a new element getByAtomicNumber(atomic_number) getByMass(mass) Get the element whose mass is CLOSEST to the requested mass. getBySymbol(symbol) Get the Element with a particular chemical symbol. Attributes atomic_number mass name symbol static getBySymbol(symbol)Â¶ Get the Element with a particular chemical symbol. static getByMass(mass)Â¶ Get the element whose mass is CLOSEST to the requested mass. This method should not be used for repartitioned masses Parameters mass (float or Quantity) â Mass of the atom to find the element for. Units assumed to be daltons if not specified Returns The element whose atomic mass is closest to the input mass Return type Element

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.forcefield.ForceField.html:
ForceFieldÂ¶ class openmm.app.forcefield.ForceField(*files)Â¶ A ForceField constructs OpenMM System objects based on a Topology. __init__(*files)Â¶ Load one or more XML files and create a ForceField object based on them. Parameters files (list) â A list of XML files defining the force field. Each entry may be an absolute file path, a path relative to the current working directory, a path relative to this moduleâs data subdirectory (for built in force fields), or an open file-like object with a read() method from which the forcefield XML data can be loaded. Methods __init__(*files) Load one or more XML files and create a ForceField object based on them. createSystem(topology[,Â nonbondedMethod,Â â¦]) Construct an OpenMM System representing a Topology with this force field. generateTemplatesForUnmatchedResidues(topology) Generate forcefield residue templates for residues in specified topology for which no forcefield templates are available. getGenerators() Get the list of all registered generators. getMatchingTemplates(topology[,Â â¦]) Return a list of forcefield residue templates matching residues in the specified topology. getUnmatchedResidues(topology[,Â â¦]) Return a list of Residue objects from specified topology for which no forcefield templates are available. loadFile(files[,Â resname_prefix]) Load an XML file and add the definitions from it to this ForceField. registerAtomType(parameters) Register a new atom type. registerGenerator(generator) Register a new generator. registerPatch(patch) Register a new patch that can be applied to templates. registerResidueTemplate(template) Register a new residue template. registerScript(script) Register a new script to be executed after building the System. registerTemplateGenerator(generator) Register a residue template generator that can be used to parameterize residues that do not match existing forcefield templates. registerTemplateMatcher(matcher) Register an object that can override the default logic for matching templates to residues. registerTemplatePatch(residue,Â patch,Â â¦) Register that a particular patch can be used with a particular residue. loadFile(files, resname_prefix='')Â¶ Load an XML file and add the definitions from it to this ForceField. Parameters files (string or file or tuple) â An XML file or tuple of XML files containing force field definitions. Each entry may be either an absolute file path, a path relative to the current working directory, a path relative to this moduleâs data subdirectory (for built in force fields), or an open file-like object with a read() method from which the forcefield XML data can be loaded. prefix (string) â An optional string to be prepended to each residue name found in the loaded files. getGenerators()Â¶ Get the list of all registered generators. registerGenerator(generator)Â¶ Register a new generator. registerAtomType(parameters)Â¶ Register a new atom type. registerResidueTemplate(template)Â¶ Register a new residue template. registerPatch(patch)Â¶ Register a new patch that can be applied to templates. registerTemplatePatch(residue, patch, patchResidueIndex)Â¶ Register that a particular patch can be used with a particular residue. registerScript(script)Â¶ Register a new script to be executed after building the System. registerTemplateMatcher(matcher)Â¶ Register an object that can override the default logic for matching templates to residues. A template matcher is a callable object that can be invoked as: template = f(forcefield, residue, bondedToAtom, ignoreExternalBonds, ignoreExtraParticles) where forcefield is the ForceField invoking it, residue is an openmm.app.Residue object, bondedToAtom[i] is the set of atoms bonded to atom index i, and ignoreExternalBonds and ignoreExtraParticles indicate whether external bonds and extra particules should be considered in matching templates. It should return a _TemplateData object that matches the residue. Alternatively it may return None, in which case the standard logic will be used to find a template for the residue. Caution This method is experimental, and its API is subject to change. registerTemplateGenerator(generator)Â¶ Register a residue template generator that can be used to parameterize residues that do not match existing forcefield templates. This functionality can be used to add handlers to parameterize small molecules or unnatural/modified residues. Caution This method is experimental, and its API is subject to change. Parameters generator (function) â A function that will be called when a residue is encountered that does not match an existing forcefield template. a residue without a template is encountered (When) â generator function is called with (the) â :: â success = generator(forcefield, residue) forcefield is the calling ForceField object and residue is a openmm.app.topology.Residue object. (where) â must conform to the following API (generator) â :: â generator API param forcefield The ForceField object to which residue templates and/or parameters are to be added. type forcefield openmm.app.ForceField param residue The residue topology for which a template is to be generated. type residue openmm.app.Topology.Residue returns success (bool) â If the generator is able to successfully parameterize the residue, True is returned. If the generator cannot parameterize the residue, it should return False and not modify forcefield. The generator should either register a residue template directly with forcefield.registerResidueTemplate(template) or it should call forcefield.loadFile(file) to load residue definitions from an ffxml file. It can also use the ForceField programmatic API to add additional atom types (via forcefield.registerAtomType(parameters)) or additional parameters. getUnmatchedResidues(topology, residueTemplates={})Â¶ Return a list of Residue objects from specified topology for which no forcefield templates are available. Caution This method is experimental, and its API is subject to change. Parameters topology (Topology) â The Topology whose residues are to be checked against the forcefield residue templates. residueTemplates (dict=dict()) â Specifies which template to use for particular residues. The keys should be Residue objects from the Topology, and the values should be the names of the templates to use for them. This is useful when a ForceField contains multiple templates that can match the same residue (e.g Fe2+ and Fe3+ templates in the ForceField for a monoatomic iron ion in the Topology). Returns unmatched_residues (list of Residue) â List of Residue objects from topology for which no forcefield residue templates are available. Note that multiple instances of the same residue appearing at different points in the topology may be returned. This method may be of use in generating missing residue templates or diagnosing parameterization failures. getMatchingTemplates(topology, ignoreExternalBonds=False)Â¶ Return a list of forcefield residue templates matching residues in the specified topology. Caution This method is experimental, and its API is subject to change. Parameters topology (Topology) â The Topology whose residues are to be checked against the forcefield residue templates. ignoreExternalBonds (bool=False) â If true, ignore external bonds when matching residues to templates. Returns templates (list of _TemplateData) â List of forcefield residue templates corresponding to residues in the topology. templates[index] is template corresponding to residue index in topology.residues() This method may be of use in debugging issues related to parameter assignment. generateTemplatesForUnmatchedResidues(topology)Â¶ Generate forcefield residue templates for residues in specified topology for which no forcefield templates are available. Caution This method is experimental, and its API is subject to change. Parameters topology (Topology) â The Topology whose residues are to be checked against the forcefield residue templates. Returns templates (list of _TemplateData) â List of forcefield residue templates corresponding to residues in topology for which no forcefield templates are currently available. Atom types will be set to None, but template name, atom names, elements, and connectivity will be taken from corresponding Residue objects. residues (list of Residue) â List of Residue objects that were used to generate the templates. residues[index] is the Residue that was used to generate the template templates[index] createSystem(topology, nonbondedMethod=NoCutoff, nonbondedCutoff=Quantity(value=1.0, unit=nanometer), constraints=None, rigidWater=None, removeCMMotion=True, hydrogenMass=None, residueTemplates={}, ignoreExternalBonds=False, switchDistance=None, flexibleConstraints=False, drudeMass=Quantity(value=0.4, unit=dalton), **args)Â¶ Construct an OpenMM System representing a Topology with this force field. Parameters topology (Topology) â The Topology for which to create a System nonbondedMethod (object=NoCutoff) â The method to use for nonbonded interactions. Allowed values are NoCutoff, CutoffNonPeriodic, CutoffPeriodic, Ewald, PME, or LJPME. nonbondedCutoff (distance=1*nanometer) â The cutoff distance to use for nonbonded interactions constraints (object=None) â Specifies which bonds and angles should be implemented with constraints. Allowed values are None, HBonds, AllBonds, or HAngles. rigidWater (boolean=None) â If true, water molecules will be fully rigid regardless of the value passed for the constraints argument. If None (the default), it uses the default behavior for this force fieldâs water model. removeCMMotion (boolean=True) â If true, a CMMotionRemover will be added to the System hydrogenMass (mass=None) â The mass to use for hydrogen atoms bound to heavy atoms. Any mass added to a hydrogen is subtracted from the heavy atom to keep their total mass the same. If rigidWater is used to make water molecules rigid, then water hydrogens are not altered. residueTemplates (dict=dict()) â Specifies which template to use for particular residues. The keys should be Residue objects from the Topology, and the values should be the names of the templates to use for them. This is useful when a ForceField contains multiple templates that can match the same residue (e.g Fe2+ and Fe3+ templates in the ForceField for a monoatomic iron ion in the Topology). ignoreExternalBonds (boolean=False) â If true, ignore external bonds when matching residues to templates. This is useful when the Topology represents one piece of a larger molecule, so chains are not terminated properly. This option can create ambiguities where multiple templates match the same residue. If that happens, use the residueTemplates argument to specify which one to use. switchDistance (float=None) â The distance at which the potential energy switching function is turned on for Lennard-Jones interactions. If this is None, no switching function will be used. flexibleConstraints (boolean=False) â If True, parameters for constrained degrees of freedom will be added to the System drudeMass (mass=0.4*amu) â The mass to use for Drude particles. Any mass added to a Drude particle is subtracted from its parent atom to keep their total mass the same. args â Arbitrary additional keyword arguments may also be specified. This allows extra parameters to be specified that are specific to particular force fields. Returns the newly created System Return type system

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.gromacsgrofile.GromacsGroFile.html:
GromacsGroFileÂ¶ class openmm.app.gromacsgrofile.GromacsGroFile(file)Â¶ GromacsGroFile parses a Gromacs .gro file and constructs a set of atom positions from it. A .gro file also contains some topological information, such as elements and residue names, but not enough to construct a full Topology object. This information is recorded and stored in the objectâs public fields. __init__(file)Â¶ Load a .gro file. The atom positions can be retrieved by calling getPositions(). Parameters file (string) â the name of the file to load Methods __init__(file) Load a .gro file. getNumFrames() Get the number of frames stored in the file. getPeriodicBoxVectors([frame]) Get the vectors defining the periodic box. getPositions([asNumpy,Â frame]) Get the atomic positions. getUnitCellDimensions([frame]) Get the dimensions of the crystallographic unit cell. getNumFrames()Â¶ Get the number of frames stored in the file. getPositions(asNumpy=False, frame=0)Â¶ Get the atomic positions. Parameters asNumpy (boolean=False) â if true, the values are returned as a numpy array instead of a list of Vec3s frame (int=0) â the index of the frame for which to get positions getPeriodicBoxVectors(frame=0)Â¶ Get the vectors defining the periodic box. Parameters frame (int=0) â the index of the frame for which to get the box vectors getUnitCellDimensions(frame=0)Â¶ Get the dimensions of the crystallographic unit cell. Parameters frame (int=0) â the index of the frame for which to get the unit cell dimensions

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.gromacstopfile.GromacsTopFile.html:
GromacsTopFileÂ¶ class openmm.app.gromacstopfile.GromacsTopFile(file, periodicBoxVectors=None, unitCellDimensions=None, includeDir=None, defines=None)Â¶ GromacsTopFile parses a Gromacs top file and constructs a Topology and (optionally) an OpenMM System from it. __init__(file, periodicBoxVectors=None, unitCellDimensions=None, includeDir=None, defines=None)Â¶ Load a top file. Parameters file (str) â the name of the file to load periodicBoxVectors (tuple of Vec3=None) â the vectors defining the periodic box unitCellDimensions (Vec3=None) â the dimensions of the crystallographic unit cell. For non-rectangular unit cells, specify periodicBoxVectors instead. includeDir (string=None) â A directory in which to look for other files included from the top file. If not specified, we will attempt to locate a gromacs installation on your system. When gromacs is installed in /usr/local, this will resolve to /usr/local/gromacs/share/gromacs/top defines (dict={}) â preprocessor definitions that should be predefined when parsing the file Methods __init__(file[,Â periodicBoxVectors,Â â¦]) Load a top file. createSystem([nonbondedMethod,Â â¦]) Construct an OpenMM System representing the topology described by this top file. createSystem(nonbondedMethod=NoCutoff, nonbondedCutoff=Quantity(value=1.0, unit=nanometer), constraints=None, rigidWater=True, ewaldErrorTolerance=0.0005, removeCMMotion=True, hydrogenMass=None, switchDistance=None)Â¶ Construct an OpenMM System representing the topology described by this top file. Parameters nonbondedMethod (object=NoCutoff) â The method to use for nonbonded interactions. Allowed values are NoCutoff, CutoffNonPeriodic, CutoffPeriodic, Ewald, PME, or LJPME. nonbondedCutoff (distance=1*nanometer) â The cutoff distance to use for nonbonded interactions constraints (object=None) â Specifies which bonds and angles should be implemented with constraints. Allowed values are None, HBonds, AllBonds, or HAngles. Regardless of this value, constraints that are explicitly specified in the top file will always be included. rigidWater (boolean=True) â If true, water molecules will be fully rigid regardless of the value passed for the constraints argument ewaldErrorTolerance (float=0.0005) â The error tolerance to use if nonbondedMethod is Ewald, PME or LJPME. removeCMMotion (boolean=True) â If true, a CMMotionRemover will be added to the System hydrogenMass (mass=None) â The mass to use for hydrogen atoms bound to heavy atoms. Any mass added to a hydrogen is subtracted from the heavy atom to keep their total mass the same. If rigidWater is used to make water molecules rigid, then water hydrogens are not altered. switchDistance (float=None) â The distance at which the potential energy switching function is turned on for Lennard-Jones interactions. If this is None, no switching function will be used. Returns the newly created System Return type System

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.internal.charmm.exceptions.CharmmPSFWarning.html:
CharmmPSFWarningÂ¶ class openmm.app.internal.charmm.exceptions.CharmmPSFWarningÂ¶ For non-fatal PSF parsing issues __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. with_traceback()Â¶ Exception.with_traceback(tb) â set self.__traceback__ to tb and return self.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.metadynamics.BiasVariable.html:
BiasVariableÂ¶ class openmm.app.metadynamics.BiasVariable(force, minValue, maxValue, biasWidth, periodic=False, gridWidth=None)Â¶ A collective variable that can be used to bias a simulation with metadynamics. __init__(force, minValue, maxValue, biasWidth, periodic=False, gridWidth=None)Â¶ Create a BiasVariable. Parameters force (Force) â the Force object whose potential energy defines the collective variable minValue (float or unit.Quantity) â the minimum value the collective variable can take. If it should ever go below this, the bias force will be set to 0. maxValue (float or unit.Quantity) â the maximum value the collective variable can take. If it should ever go above this, the bias force will be set to 0. biasWidth (float or unit.Quantity) â the width (standard deviation) of the Gaussians added to the bias during metadynamics periodic (bool (optional)) â whether this is a periodic variable, such that minValue and maxValue are physical equivalent gridWidth (int (optional)) â the number of grid points to use when tabulating the bias function. If this is omitted, a reasonable value is chosen automatically. Methods __init__(force,Â minValue,Â maxValue,Â biasWidth) Create a BiasVariable.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.metadynamics.Metadynamics.html:
MetadynamicsÂ¶ class openmm.app.metadynamics.Metadynamics(system, variables, temperature, biasFactor, height, frequency, saveFrequency=None, biasDir=None)Â¶ Performs metadynamics. This class implements well-tempered metadynamics, as described in Barducci et al., âWell-Tempered Metadynamics: A Smoothly Converging and Tunable Free-Energy Methodâ (https://doi.org/10.1103/PhysRevLett.100.020603). You specify from one to three collective variables whose sampling should be accelerated. A biasing force that depends on the collective variables is added to the simulation. Initially the bias is zero. As the simulation runs, Gaussian bumps are periodically added to the bias at the current location of the simulation. This pushes the simulation away from areas it has already explored, encouraging it to sample other regions. At the end of the simulation, the bias function can be used to calculate the systemâs free energy as a function of the collective variables. To use the class you create a Metadynamics object, passing to it the System you want to simulate and a list of BiasVariable objects defining the collective variables. It creates a biasing force and adds it to the System. You then run the simulation as usual, but call step() on the Metadynamics object instead of on the Simulation. You can optionally specify a directory on disk where the current bias function should periodically be written. In addition, it loads biases from any other files in the same directory and includes them in the simulation. It loads files when the Metqdynamics object is first created, and also checks for any new files every time it updates its own bias on disk. This serves two important functions. First, it lets you stop a metadynamics run and resume it later. When you begin the new simulation, it will load the biases computed in the earlier simulation and continue adding to them. Second, it provides an easy way to parallelize metadynamics sampling across many computers. Just point all of them to a shared directory on disk. Each process will save its biases to that directory, and also load in and apply the biases added by other processes. __init__(system, variables, temperature, biasFactor, height, frequency, saveFrequency=None, biasDir=None)Â¶ Create a Metadynamics object. Parameters system (System) â the System to simulate. A CustomCVForce implementing the bias is created and added to the System. variables (list of BiasVariables) â the collective variables to sample temperature (temperature) â the temperature at which the simulation is being run. This is used in computing the free energy. biasFactor (float) â used in scaling the height of the Gaussians added to the bias. The collective variables are sampled as if the effective temperature of the simulation were temperature*biasFactor. height (energy) â the initial height of the Gaussians to add frequency (int) â the interval in time steps at which Gaussians should be added to the bias potential saveFrequency (int (optional)) â the interval in time steps at which to write out the current biases to disk. At the same time it writes biases, it also checks for updated biases written by other processes and loads them in. This must be a multiple of frequency. biasDir (str (optional)) â the directory to which biases should be written, and from which biases written by other processes should be loaded Methods __init__(system,Â variables,Â temperature,Â â¦) Create a Metadynamics object. getCollectiveVariables(simulation) Get the current values of all collective variables in a Simulation. getFreeEnergy() Get the free energy of the system as a function of the collective variables. step(simulation,Â steps) Advance the simulation by integrating a specified number of time steps. step(simulation, steps)Â¶ Advance the simulation by integrating a specified number of time steps. Parameters simulation (Simulation) â the Simulation to advance steps (int) â the number of time steps to integrate getFreeEnergy()Â¶ Get the free energy of the system as a function of the collective variables. The result is returned as a N-dimensional NumPy array, where N is the number of collective variables. The values are in kJ/mole. The iâth position along an axis corresponds to minValue + i*(maxValue-minValue)/gridWidth. getCollectiveVariables(simulation)Â¶ Get the current values of all collective variables in a Simulation.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.modeller.Modeller.html:
ModellerÂ¶ class openmm.app.modeller.Modeller(topology, positions)Â¶ Modeller provides tools for editing molecular models, such as adding water or missing hydrogens. To use it, create a Modeller object, specifying the initial Topology and atom positions. You can then call various methods to change the model in different ways. Each time you do, a new Topology and list of coordinates is created to represent the changed model. Finally, call getTopology() and getPositions() to get the results. __init__(topology, positions)Â¶ Create a new Modeller object Parameters topology (Topology) â the initial Topology of the model positions (list) â the initial atomic positions Methods __init__(topology,Â positions) Create a new Modeller object add(addTopology,Â addPositions) Add chains, residues, atoms, and bonds to the model. addExtraParticles(forcefield[,Â â¦]) Add missing extra particles to the model that are required by a force field. addHydrogens([forcefield,Â pH,Â variants,Â â¦]) Add missing hydrogens to the model. addMembrane(forcefield[,Â lipidType,Â â¦]) Add a lipid membrane to the model. addSolvent(forcefield[,Â model,Â boxSize,Â â¦]) Add solvent (both water and ions) to the model to fill a periodic box. convertWater([model]) Convert all water molecules to a different water model. delete(toDelete) Delete chains, residues, atoms, and bonds from the model. deleteWater() Delete all water molecules from the model. getPositions() Get the atomic positions. getTopology() Get the Topology of the model. loadHydrogenDefinitions(file) Load an XML file containing definitions of hydrogens that should be added by addHydrogens(). getTopology()Â¶ Get the Topology of the model. getPositions()Â¶ Get the atomic positions. add(addTopology, addPositions)Â¶ Add chains, residues, atoms, and bonds to the model. Specify what to add by providing a new Topology object and the corresponding atomic positions. All chains, residues, atoms, and bonds contained in the Topology are added to the model. Parameters addTopology (Topology) â a Topology whose contents should be added to the model addPositions (list) â the positions of the atoms to add delete(toDelete)Â¶ Delete chains, residues, atoms, and bonds from the model. You can specify objects to delete at any granularity: atoms, residues, or chains. Passing in an Atom object causes that Atom to be deleted. Passing in a Residue object causes that Residue and all Atoms it contains to be deleted. Passing in a Chain object causes that Chain and all Residues and Atoms it contains to be deleted. In all cases, when an Atom is deleted, any bonds it participates in are also deleted. You also can specify a bond (as a tuple of Atom objects) to delete just that bond without deleting the Atoms it connects. Parameters toDelete (list) â a list of Atoms, Residues, Chains, and bonds (specified as tuples of Atoms) to delete deleteWater()Â¶ Delete all water molecules from the model. convertWater(model='tip3p')Â¶ Convert all water molecules to a different water model. Deprecated Use addExtraParticles() instead. It performs the same function but in a more general way. Parameters model (string='tip3p') â the water model to convert to. Supported values are âtip3pâ, âspceâ, âtip4pewâ, and âtip5pâ. addSolvent(forcefield, model='tip3p', boxSize=None, boxVectors=None, padding=None, numAdded=None, boxShape='cube', positiveIon='Na+', negativeIon='Cl-', ionicStrength=Quantity(value=0, unit=molar), neutralize=True, residueTemplates={})Â¶ Add solvent (both water and ions) to the model to fill a periodic box. The algorithm works as follows: Water molecules are added to fill the box. Water molecules are removed if their distance to any solute atom is less than the sum of their van der Waals radii. If the solute is charged and neutralize=True, enough positive or negative ions are added to neutralize it. Each ion is added by randomly selecting a water molecule and replacing it with the ion. Ion pairs are added to give the requested total ionic strength. Note that only monovalent ions are currently supported. The box size can be specified in any of several ways: You can explicitly give the vectors defining the periodic box to use. Alternatively, for a rectangular box you can simply give the dimensions of the unit cell. You can give a padding distance. A bounding sphere containing the solute is determined, and the box size is set to (sphere diameter)+(padding). This guarantees no atom in the solute will come closer than the padding distance to any atom of another periodic copy. If the sphere diameter is less than the padding distance, the box size is set to 2*(padding) to ensure no atom is closer than the padding distance to two periodic copies of any other atom. You can specify the total number of molecules (both waters and ions) to add. A box is then created whose size is just large enough hold the specified amount of solvent. Finally, if none of the above options is specified, the existing Topologyâs box vectors are used. When specifying either a padding distance or a number of molecules, you can specify a shape for the periodic box: cubic, rhombic dodecahedron, or truncated octahedron. Using a non-rectangular box allows the same distance between periodic copies to be achieved with a smaller box. The most compact option is a rhombic dodecahedron, for which the box volume is 70.7% the volume of a cubic box with the same amount of padding. There exist many different water models, many of which are very similar to each other. This method creates preequilibrated water boxes for a limited set of water models. In most cases, they work equally well for other models that involve the same number of particles. For example, to simulate a box of TIP3P-FB water, use this method to create a box of TIP3P water, construct a System using TIP3P-FB parameters, and perform a local energy minimization to correct for the small differences between the models. Likewise, a box of TIP4P-Ew water can be used for most four site water models. Parameters forcefield (ForceField) â the ForceField to use for determining van der Waals radii and atomic charges model (str='tip3p') â the water model to use. Supported values are âtip3pâ, âspceâ, âtip4pewâ, âtip5pâ, and âswm4ndpâ (polarizable). boxSize (Vec3=None) â the size of the box to fill with water boxVectors (tuple of Vec3=None) â the vectors defining the periodic box to fill with water padding (distance=None) â the padding distance to use numAdded (int=None) â the total number of molecules (waters and ions) to add boxShape (str='cube') â the box shape to use. Allowed values are âcubeâ, âdodecahedronâ, and âoctahedronâ. If padding and numAdded are both None, this is ignored. positiveIon (string='Na+') â the type of positive ion to add. Allowed values are âCs+â, âK+â, âLi+â, âNa+â, and âRb+â negativeIon (string='Cl-') â the type of negative ion to add. Allowed values are âCl-â, âBr-â, âF-â, and âI-â. Be aware that not all force fields support all ion types. ionicStrength (concentration=0*molar) â the total concentration of ions (both positive and negative) to add. This does not include ions that are added to neutralize the system. Note that only monovalent ions are currently supported. neutralize (bool=True) â whether to add ions to neutralize the system residueTemplates (dict=dict()) â specifies which template the ForceField should use for particular residues. The keys should be Residue objects from the Topology, and the values should be the names of the templates to use for them. This is useful when a ForceField contains multiple templates that can match the same residue (e.g Fe2+ and Fe3+ templates in the ForceField for a monoatomic iron ion in the Topology). static loadHydrogenDefinitions(file)Â¶ Load an XML file containing definitions of hydrogens that should be added by addHydrogens(). The built in hydrogens.xml file containing definitions for standard amino acids and nucleotides is loaded automatically. This method can be used to load additional definitions for other residue types. They will then be used in subsequent calls to addHydrogens(). Parameters file (string or file) â An XML file containing hydrogen definitions. It may be either an absolute file path, a path relative to the current working directory, a path relative to this moduleâs data subdirectory (for built in sets of definitions), or an open file-like object with a read() method from which the data can be loaded. addHydrogens(forcefield=None, pH=7.0, variants=None, platform=None, residueTemplates={})Â¶ Add missing hydrogens to the model. Some residues can exist in multiple forms depending on the pH and properties of the local environment. These variants differ in the presence or absence of particular hydrogens. In particular, the following variants are supported: Aspartic acid:ASH: Neutral form with a hydrogen on one of the delta oxygens ASP: Negatively charged form without a hydrogen on either delta oxygen Cysteine:CYS: Neutral form with a hydrogen on the sulfur CYX: No hydrogen on the sulfur (either negatively charged, or part of a disulfide bond) Glutamic acid:GLH: Neutral form with a hydrogen on one of the epsilon oxygens GLU: Negatively charged form without a hydrogen on either epsilon oxygen Histidine:HID: Neutral form with a hydrogen on the ND1 atom HIE: Neutral form with a hydrogen on the NE2 atom HIP: Positively charged form with hydrogens on both ND1 and NE2 HIN: Negatively charged form without a hydrogen on either ND1 or NE2 Lysine:LYN: Neutral form with two hydrogens on the zeta nitrogen LYS: Positively charged form with three hydrogens on the zeta nitrogen The variant to use for each residue is determined by the following rules: The most common variant at the specified pH is selected. Any Cysteine that participates in a disulfide bond uses the CYX variant regardless of pH. For a neutral Histidine residue, the HID or HIE variant is selected based on which one forms a better hydrogen bond. You can override these rules by explicitly specifying a variant for any residue. To do that, provide a list for the âvariantsâ parameter, and set the corresponding element to the name of the variant to use. A special case is when the model already contains a hydrogen that should not be present in the desired variant. If you explicitly specify a variant using the âvariantsâ parameter, the residue will be modified to match the desired variant, removing hydrogens if necessary. On the other hand, for residues whose variant is selected automatically, this function will only add hydrogens. It will never remove ones that are already present in the model, regardless of the specified pH. In all cases, the positions of existing atoms (including existing hydrogens) are not modified. Definitions for standard amino acids and nucleotides are built in. You can call loadHydrogenDefinitions() to load additional definitions for other residue types. Parameters forcefield (ForceField=None) â the ForceField to use for determining the positions of hydrogens. If this is None, positions will be picked which are generally reasonable but not optimized for any particular ForceField. pH (float=7.0) â the pH based on which to select variants variants (list=None) â an optional list of variants to use. If this is specified, its length must equal the number of residues in the model. variants[i] is the name of the variant to use for residue i (indexed starting at 0). If an element is None, the standard rules will be followed to select a variant for that residue. platform (Platform=None) â the Platform to use when computing the hydrogen atom positions. If this is None, the default Platform will be used. residueTemplates (dict=dict()) â specifies which template the ForceField should use for particular residues. The keys should be Residue objects from the Topology, and the values should be the names of the templates to use for them. This is useful when a ForceField contains multiple templates that can match the same residue (e.g Fe2+ and Fe3+ templates in the ForceField for a monoatomic iron ion in the Topology). Returns a list of what variant was actually selected for each residue, in the same format as the variants parameter Return type list addExtraParticles(forcefield, ignoreExternalBonds=False, residueTemplates={})Â¶ Add missing extra particles to the model that are required by a force field. Some force fields use âextra particlesâ that do not represent actual atoms, but still need to be included in the System. Examples include lone pairs, Drude particles, and the virtual sites used in some water models to adjust the charge distribution. Extra particles can be recognized by the fact that their element is None. This method is primarily used to add extra particles, but it can also remove them. It tries to match every residue in the Topology to a template in the force field. If there is no match, it will both add and remove extra particles as necessary to make it match. Parameters forcefield (ForceField) â the ForceField defining what extra particles should be present ignoreExternalBonds (boolean=False) â If true, ignore external bonds when matching residues to templates. This is useful when the Topology represents one piece of a larger molecule, so chains are not terminated properly. residueTemplates (dict=dict()) â specifies which template the ForceField should use for particular residues. The keys should be Residue objects from the Topology, and the values should be the names of the templates to use for them. This is useful when a ForceField contains multiple templates that can match the same residue (e.g Fe2+ and Fe3+ templates in the ForceField for a monoatomic iron ion in the Topology). addMembrane(forcefield, lipidType='POPC', membraneCenterZ=Quantity(value=0, unit=nanometer), minimumPadding=Quantity(value=1, unit=nanometer), positiveIon='Na+', negativeIon='Cl-', ionicStrength=Quantity(value=0, unit=molar), neutralize=True, residueTemplates={})Â¶ Add a lipid membrane to the model. This method actually adds both a membrane and a water box. It is best to build them together, both to avoid adding waters inside the membrane and to ensure that lipid head groups are properly solvated. For that reason, this method includes many of the same arguments as addSolvent(). The membrane is added in the XY plane, and the existing protein is assumed to already be oriented and positioned correctly. When possible, it is recommended to start with a model from the Orientations of Proteins in Membranes (OPM) database at http://opm.phar.umich.edu. Otherwise, it is up to you to select the protein position yourself. The algorithm is based on the one described in Wolf et al., J. Comp. Chem. 31, pp. 2169-2174 (2010). It begins by tiling copies of a pre-equilibrated membrane patch to create a membrane of the desired size. Next it scales down the protein by 50% along the X and Y axes. Any lipid within a cutoff distance of the scaled protein is removed. It also ensures that equal numbers of lipids are removed from each leaf of the membrane. Finally, it runs molecular dynamics to let the membrane relax while gradually scaling the protein back up to its original size. The size of the membrane and water box are determined by the minimumPadding argument. All pre-existing atoms are guaranteed to be at least this far from any edge of the periodic box. It is also possible for the periodic box to have more padding than requested. In particular, it only adds whole copies of the pre-equilibrated membrane patch, so the box dimensions will always be integer multiples of the patch size. That may lead to a larger membrane than what you requested. This method has built in support for POPC, POPE, DLPC, DLPE, DMPC, DOPC and DPPC lipids. You can also build other types of membranes by providing a pre-equilibrated, solvated membrane patch that can be tiled in the XY plane to form the membrane. Parameters forcefield (ForceField) â the ForceField to use for determining atomic charges and for relaxing the membrane lipidType (string or object) â the type of lipid to use. Supported string values are âPOPCâ, âPOPEâ, âDLPCâ, âDLPEâ, âDMPCâ, âDOPCâ, and âDPPCâ. For other types of lipids, provide a PDBFile or PDBxFile object (or any other object with âtopologyâ and âpositionsâ fields) containing a membrane patch. membraneCenterZ (distance=0*nanometer) â the position along the Z axis of the center of the membrane minimumPadding (distance=1*nanometer) â the padding distance to use positiveIon (string='Na+') â the type of positive ion to add. Allowed values are âCs+â, âK+â, âLi+â, âNa+â, and âRb+â negativeIon (string='Cl-') â the type of negative ion to add. Allowed values are âCl-â, âBr-â, âF-â, and âI-â. Be aware that not all force fields support all ion types. ionicStrength (concentration=0*molar) â the total concentration of ions (both positive and negative) to add. This does not include ions that are added to neutralize the system. Note that only monovalent ions are currently supported. neutralize (bool=True) â whether to add ions to neutralize the system residueTemplates (dict=dict()) â specifies which template the ForceField should use for particular residues. The keys should be Residue objects from the Topology, and the values should be the names of the templates to use for them. This is useful when a ForceField contains multiple templates that can match the same residue (e.g Fe2+ and Fe3+ templates in the ForceField for a monoatomic iron ion in the Topology).

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.pdbfile.PDBFile.html:
PDBFileÂ¶ class openmm.app.pdbfile.PDBFile(file, extraParticleIdentifier='EP')Â¶ PDBFile parses a Protein Data Bank (PDB) file and constructs a Topology and a set of atom positions from it. This class also provides methods for creating PDB files. To write a file containing a single model, call writeFile(). You also can create files that contain multiple models. To do this, first call writeHeader(), then writeModel() once for each model in the file, and finally writeFooter() to complete the file. __init__(file, extraParticleIdentifier='EP')Â¶ Load a PDB file. The atom positions and Topology can be retrieved by calling getPositions() and getTopology(). Parameters file (string or file) â the name of the file to load. Alternatively you can pass an open file object. extraParticleIdentifier (string='EP') â if this value appears in the element column for an ATOM record, the Atomâs element will be set to None to mark it as an extra particle Methods __init__(file[,Â extraParticleIdentifier]) Load a PDB file. getNumFrames() Get the number of frames stored in the file. getPositions([asNumpy,Â frame]) Get the atomic positions. getTopology() Get the Topology of the model. writeFile(topology,Â positions[,Â file,Â â¦]) Write a PDB file containing a single model. writeFooter(topology[,Â file]) Write out the footer for a PDB file. writeHeader(topology[,Â file]) Write out the header for a PDB file. writeModel(topology,Â positions[,Â file,Â â¦]) Write out a model to a PDB file. getTopology()Â¶ Get the Topology of the model. getNumFrames()Â¶ Get the number of frames stored in the file. getPositions(asNumpy=False, frame=0)Â¶ Get the atomic positions. Parameters asNumpy (boolean=False) â if true, the values are returned as a numpy array instead of a list of Vec3s frame (int=0) â the index of the frame for which to get positions static writeFile(topology, positions, file=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, keepIds=False, extraParticleIdentifier='EP')Â¶ Write a PDB file containing a single model. Parameters topology (Topology) â The Topology defining the model to write positions (list) â The list of atomic positions to write file (string or file) â the name of the file to write. Alternatively you can pass an open file object. keepIds (bool=False) â If True, keep the residue and chain IDs specified in the Topology rather than generating new ones. Warning: It is up to the caller to make sure these are valid IDs that satisfy the requirements of the PDB format. Otherwise, the output file will be invalid. extraParticleIdentifier (string='EP') â String to write in the element column of the ATOM records for atoms whose element is None (extra particles) static writeHeader(topology, file=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)Â¶ Write out the header for a PDB file. Parameters topology (Topology) â The Topology defining the molecular system being written file (file=stdout) â A file to write the file to static writeModel(topology, positions, file=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, modelIndex=None, keepIds=False, extraParticleIdentifier='EP')Â¶ Write out a model to a PDB file. Parameters topology (Topology) â The Topology defining the model to write positions (list) â The list of atomic positions to write file (file=stdout) â A file to write the model to modelIndex (int=None) â If not None, the model will be surrounded by MODEL/ENDMDL records with this index keepIds (bool=False) â If True, keep the residue and chain IDs specified in the Topology rather than generating new ones. Warning: It is up to the caller to make sure these are valid IDs that satisfy the requirements of the PDB format. No guarantees are made about what will happen if they are not, and the output file could be invalid. extraParticleIdentifier (string='EP') â String to write in the element column of the ATOM records for atoms whose element is None (extra particles) static writeFooter(topology, file=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)Â¶ Write out the footer for a PDB file. Parameters topology (Topology) â The Topology defining the molecular system being written file (file=stdout) â A file to write the file to

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.pdbreporter.PDBReporter.html:
PDBReporterÂ¶ class openmm.app.pdbreporter.PDBReporter(file, reportInterval, enforcePeriodicBox=None, atomSubset=None)Â¶ PDBReporter outputs a series of frames from a Simulation to a PDB file. To use it, create a PDBReporter, then add it to the Simulationâs list of reporters. __init__(file, reportInterval, enforcePeriodicBox=None, atomSubset=None)Â¶ Create a PDBReporter. Parameters file (string) â The file to write to reportInterval (int) â The interval (in time steps) at which to write frames enforcePeriodicBox (bool) â Specifies whether particle positions should be translated so the center of every molecule lies in the same periodic box. If None (the default), it will automatically decide whether to translate molecules based on whether the system being simulated uses periodic boundary conditions. atomSubset (list) â Atom indices (zero indexed) of the particles to output. if None (the default), all particles will be output. Methods __init__(file,Â reportInterval[,Â â¦]) Create a PDBReporter. describeNextReport(simulation) Get information about the next report this object will generate. report(simulation,Â state) Generate a report. describeNextReport(simulation)Â¶ Get information about the next report this object will generate. Parameters simulation (Simulation) â The Simulation to generate a report for Returns A six element tuple. The first element is the number of steps until the next report. The next four elements specify whether that report will require positions, velocities, forces, and energies respectively. The final element specifies whether positions should be wrapped to lie in a single periodic box. Return type tuple report(simulation, state)Â¶ Generate a report. Parameters simulation (Simulation) â The Simulation to generate a report for state (State) â The current state of the simulation

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.pdbreporter.PDBxReporter.html:
PDBxReporterÂ¶ class openmm.app.pdbreporter.PDBxReporter(file, reportInterval, enforcePeriodicBox=None, atomSubset=None)Â¶ PDBxReporter outputs a series of frames from a Simulation to a PDBx/mmCIF file. To use it, create a PDBxReporter, then add it to the Simulationâs list of reporters. __init__(file, reportInterval, enforcePeriodicBox=None, atomSubset=None)Â¶ Create a PDBReporter. Parameters file (string) â The file to write to reportInterval (int) â The interval (in time steps) at which to write frames enforcePeriodicBox (bool) â Specifies whether particle positions should be translated so the center of every molecule lies in the same periodic box. If None (the default), it will automatically decide whether to translate molecules based on whether the system being simulated uses periodic boundary conditions. atomSubset (list) â Atom indices (zero indexed) of the particles to output. if None (the default), all particles will be output. Methods __init__(file,Â reportInterval[,Â â¦]) Create a PDBReporter. describeNextReport(simulation) Get information about the next report this object will generate. report(simulation,Â state) Generate a report. report(simulation, state)Â¶ Generate a report. Parameters simulation (Simulation) â The Simulation to generate a report for state (State) â The current state of the simulation describeNextReport(simulation)Â¶ Get information about the next report this object will generate. Parameters simulation (Simulation) â The Simulation to generate a report for Returns A six element tuple. The first element is the number of steps until the next report. The next four elements specify whether that report will require positions, velocities, forces, and energies respectively. The final element specifies whether positions should be wrapped to lie in a single periodic box. Return type tuple

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.pdbxfile.PDBxFile.html:
PDBxFileÂ¶ class openmm.app.pdbxfile.PDBxFile(file)Â¶ PDBxFile parses a PDBx/mmCIF file and constructs a Topology and a set of atom positions from it. __init__(file)Â¶ Load a PDBx/mmCIF file. The atom positions and Topology can be retrieved by calling getPositions() and getTopology(). Parameters file (string) â the name of the file to load. Alternatively you can pass an open file object. Methods __init__(file) Load a PDBx/mmCIF file. getNumFrames() Get the number of frames stored in the file. getPositions([asNumpy,Â frame]) Get the atomic positions. getTopology() Get the Topology of the model. writeFile(topology,Â positions[,Â file,Â â¦]) Write a PDBx/mmCIF file containing a single model. writeHeader(topology[,Â file,Â entry,Â keepIds]) Write out the header for a PDBx/mmCIF file. writeModel(topology,Â positions[,Â file,Â â¦]) Write out a model to a PDBx/mmCIF file. getTopology()Â¶ Get the Topology of the model. getNumFrames()Â¶ Get the number of frames stored in the file. getPositions(asNumpy=False, frame=0)Â¶ Get the atomic positions. Parameters asNumpy (bool=False) â if true, the values are returned as a numpy array instead of a list of Vec3s frame (int=0) â the index of the frame for which to get positions static writeFile(topology, positions, file=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, keepIds=False, entry=None)Â¶ Write a PDBx/mmCIF file containing a single model. Parameters topology (Topology) â The Topology defining the model to write positions (list) â The list of atomic positions to write file (string or file) â the name of the file to write. Alternatively you can pass an open file object. keepIds (bool=False) â If True, keep the residue and chain IDs specified in the Topology rather than generating new ones. Warning: It is up to the caller to make sure these are valid IDs that satisfy the requirements of the PDBx/mmCIF format. Otherwise, the output file will be invalid. entry (str=None) â The entry ID to assign to the CIF file static writeHeader(topology, file=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, entry=None, keepIds=False)Â¶ Write out the header for a PDBx/mmCIF file. Parameters topology (Topology) â The Topology defining the molecular system being written file (file=stdout) â A file to write the file to entry (str=None) â The entry ID to assign to the CIF file keepIds (bool=False) â If True, keep the residue and chain IDs specified in the Topology rather than generating new ones. Warning: It is up to the caller to make sure these are valid IDs that satisfy the requirements of the PDBx/mmCIF format. Otherwise, the output file will be invalid. static writeModel(topology, positions, file=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, modelIndex=1, keepIds=False)Â¶ Write out a model to a PDBx/mmCIF file. Parameters topology (Topology) â The Topology defining the model to write positions (list) â The list of atomic positions to write file (file=stdout) â A file to write the model to modelIndex (int=1) â The model number of this frame keepIds (bool=False) â If True, keep the residue and chain IDs specified in the Topology rather than generating new ones. Warning: It is up to the caller to make sure these are valid IDs that satisfy the requirements of the PDBx/mmCIF format. Otherwise, the output file will be invalid.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.simulatedtempering.SimulatedTempering.html:
SimulatedTemperingÂ¶ class openmm.app.simulatedtempering.SimulatedTempering(simulation, temperatures=None, numTemperatures=None, minTemperature=None, maxTemperature=None, weights=None, tempChangeInterval=25, reportInterval=1000, reportFile=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)Â¶ SimulatedTempering implements the simulated tempering algorithm for accelerated sampling. It runs a simulation while allowing the temperature to vary. At high temperatures, it can more easily cross energy barriers to explore a wider area of conformation space. At low temperatures, it can thoroughly explore each local region. For details, see Marinari, E. and Parisi, G., Europhys. Lett. 19(6). pp. 451-458 (1992). The set of temperatures to sample can be specified in two ways. First, you can explicitly provide a list of temperatures by using the âtemperaturesâ argument. Alternatively, you can specify the minimum and maximum temperatures, and the total number of temperatures to use. The temperatures are chosen spaced exponentially between the two extremes. For example, st = SimulatedTempering(simulation, numTemperatures=15, minTemperature=300*kelvin, maxTemperature=450*kelvin) After creating the SimulatedTempering object, call step() on it to run the simulation. Transitions between temperatures are performed at regular intervals, as specified by the âtempChangeIntervalâ argument. For each transition, a new temperature is selected using the independence sampling method, as described in Chodera, J. and Shirts, M., J. Chem. Phys. 135, 194110 (2011). Simulated tempering requires a âweight factorâ for each temperature. Ideally, these should be chosen so the simulation spends equal time at every temperature. You can specify the list of weights to use with the optional âweightsâ argument. If this is omitted, weights are selected automatically using the Wang-Landau algorithm as described in Wang, F. and Landau, D. P., Phys. Rev. Lett. 86(10), pp. 2050-2053 (2001). To properly analyze the results of the simulation, it is important to know the temperature and weight factors at every point in time. The SimulatedTempering object functions as a reporter, writing this information to a file or stdout at regular intervals (which should match the interval at which you save frames from the simulation). You can specify the output file and reporting interval with the âreportFileâ and âreportIntervalâ arguments. __init__(simulation, temperatures=None, numTemperatures=None, minTemperature=None, maxTemperature=None, weights=None, tempChangeInterval=25, reportInterval=1000, reportFile=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)Â¶ Create a new SimulatedTempering. Parameters simulation (Simulation) â The Simulation defining the System, Context, and Integrator to use temperatures (list) â The list of temperatures to use for tempering, in increasing order numTemperatures (int) â The number of temperatures to use for tempering. If temperatures is not None, this is ignored. minTemperature (temperature) â The minimum temperature to use for tempering. If temperatures is not None, this is ignored. maxTemperature (temperature) â The maximum temperature to use for tempering. If temperatures is not None, this is ignored. weights (list) â The weight factor for each temperature. If none, weights are selected automatically. tempChangeInterval (int) â The interval (in time steps) at which to attempt transitions between temperatures reportInterval (int) â The interval (in time steps) at which to write information to the report file reportFile (string or file) â The file to write reporting information to, specified as a file name or file object Methods __init__(simulation[,Â temperatures,Â â¦]) Create a new SimulatedTempering. step(steps) Advance the simulation by integrating a specified number of time steps. Attributes weights step(steps)Â¶ Advance the simulation by integrating a specified number of time steps.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.simulation.Simulation.html:
SimulationÂ¶ class openmm.app.simulation.Simulation(topology, system, integrator, platform=None, platformProperties=None, state=None)Â¶ Simulation provides a simplified API for running simulations with OpenMM and reporting results. A Simulation ties together various objects used for running a simulation: a Topology, System, Integrator, and Context. To use it, you provide the Topology, System, and Integrator, and it creates the Context automatically. Simulation also maintains a list of âreporterâ objects that record or analyze data as the simulation runs, such as writing coordinates to files or displaying structures on the screen. For example, the following line will cause a file called âoutput.pdbâ to be created, and a structure written to it every 1000 time steps: simulation.reporters.append(PDBReporter(âoutput.pdbâ, 1000)) __init__(topology, system, integrator, platform=None, platformProperties=None, state=None)Â¶ Create a Simulation. Parameters topology (Topology) â A Topology describing the the system to simulate system (System or XML file name) â The OpenMM System object to simulate (or the name of an XML file with a serialized System) integrator (Integrator or XML file name) â The OpenMM Integrator to use for simulating the System (or the name of an XML file with a serialized System) platform (Platform=None) â If not None, the OpenMM Platform to use platformProperties (map=None) â If not None, a set of platform-specific properties to pass to the Contextâs constructor. This argument may only be used if a specific Platform is specified. state (XML file name=None) â The name of an XML file containing a serialized State. If not None, the information stored in state will be transferred to the generated Simulation object. Methods __init__(topology,Â system,Â integrator[,Â â¦]) Create a Simulation. loadCheckpoint(file) Load a checkpoint file that was created with saveCheckpoint(). loadState(file) Load a State file that was created with saveState(). minimizeEnergy([tolerance,Â maxIterations,Â â¦]) Perform a local energy minimization on the system. runForClockTime(time[,Â checkpointFile,Â â¦]) Advance the simulation by integrating time steps until a fixed amount of clock time has elapsed. saveCheckpoint(file) Save a checkpoint of the simulation to a file. saveState(file) Save the current state of the simulation to a file. step(steps) Advance the simulation by integrating a specified number of time steps. Attributes currentStep The index of the current time step. property currentStepÂ¶ The index of the current time step. minimizeEnergy(tolerance=Quantity(value=10, unit=kilojoule / nanometer * mole), maxIterations=0, reporter=None)Â¶ Perform a local energy minimization on the system. Parameters tolerance (force) â This specifies how precisely the energy minimum must be located. Minimization is halted once the root-mean-square value of all force components reaches this tolerance. maxIterations (int) â The maximum number of iterations to perform. If this is 0, minimization is continued until the results converge without regard to how many iterations it takes. reporter (MinimizationReporter = None) â an optional reporter to invoke after each iteration. This can be used to monitor the progress of minimization or to stop minimization early. step(steps)Â¶ Advance the simulation by integrating a specified number of time steps. runForClockTime(time, checkpointFile=None, stateFile=None, checkpointInterval=None)Â¶ Advance the simulation by integrating time steps until a fixed amount of clock time has elapsed. This is useful when you have a limited amount of computer time available, and want to run the longest simulation possible in that time. This method will continue taking time steps until the specified clock time has elapsed, then return. It also can automatically write out a checkpoint and/or state file before returning, so you can later resume the simulation. Another option allows it to write checkpoints or states at regular intervals, so you can resume even if the simulation is interrupted before the time limit is reached. Parameters time (time) â the amount of time to run for. If no units are specified, it is assumed to be a number of hours. checkpointFile (string or file=None) â if specified, a checkpoint file will be written at the end of the simulation (and optionally at regular intervals before then) by passing this to saveCheckpoint(). stateFile (string or file=None) â if specified, a state file will be written at the end of the simulation (and optionally at regular intervals before then) by passing this to saveState(). checkpointInterval (time=None) â if specified, checkpoints and/or states will be written at regular intervals during the simulation, in addition to writing a final version at the end. If no units are specified, this is assumed to be in hours. saveCheckpoint(file)Â¶ Save a checkpoint of the simulation to a file. The output is a binary file that contains a complete representation of the current state of the Simulation. It includes both publicly visible data such as the particle positions and velocities, and also internal data such as the states of random number generators. Reloading the checkpoint will put the Simulation back into precisely the same state it had before, so it can be exactly continued. A checkpoint file is highly specific to the Simulation it was created from. It can only be loaded into another Simulation that has an identical System, uses the same Platform and OpenMM version, and is running on identical hardware. If you need a more portable way to resume simulations, consider using saveState() instead. Parameters file (string or file) â a File-like object to write the checkpoint to, or alternatively a filename loadCheckpoint(file)Â¶ Load a checkpoint file that was created with saveCheckpoint(). Parameters file (string or file) â a File-like object to load the checkpoint from, or alternatively a filename saveState(file)Â¶ Save the current state of the simulation to a file. The output is an XML file containing a serialized State object. It includes all publicly visible data, including positions, velocities, and parameters. Reloading the State will put the Simulation back into approximately the same state it had before. Unlike saveCheckpoint(), this does not store internal data such as the states of random number generators. Therefore, you should not expect the following trajectory to be identical to what would have been produced with the original Simulation. On the other hand, this means it is portable across different Platforms or hardware. Parameters file (string or file) â a File-like object to write the state to, or alternatively a filename loadState(file)Â¶ Load a State file that was created with saveState(). Parameters file (string or file) â a File-like object to load the state from, or alternatively a filename

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.statedatareporter.StateDataReporter.html:
StateDataReporterÂ¶ class openmm.app.statedatareporter.StateDataReporter(file, reportInterval, step=False, time=False, potentialEnergy=False, kineticEnergy=False, totalEnergy=False, temperature=False, volume=False, density=False, progress=False, remainingTime=False, speed=False, elapsedTime=False, separator=',', systemMass=None, totalSteps=None, append=False)Â¶ StateDataReporter outputs information about a simulation, such as energy and temperature, to a file. To use it, create a StateDataReporter, then add it to the Simulationâs list of reporters. The set of data to write is configurable using boolean flags passed to the constructor. By default the data is written in comma-separated-value (CSV) format, but you can specify a different separator to use. __init__(file, reportInterval, step=False, time=False, potentialEnergy=False, kineticEnergy=False, totalEnergy=False, temperature=False, volume=False, density=False, progress=False, remainingTime=False, speed=False, elapsedTime=False, separator=',', systemMass=None, totalSteps=None, append=False)Â¶ Create a StateDataReporter. Parameters file (string or file) â The file to write to, specified as a file name or file object reportInterval (int) â The interval (in time steps) at which to write frames step (bool=False) â Whether to write the current step index to the file time (bool=False) â Whether to write the current time to the file potentialEnergy (bool=False) â Whether to write the potential energy to the file kineticEnergy (bool=False) â Whether to write the kinetic energy to the file totalEnergy (bool=False) â Whether to write the total energy to the file temperature (bool=False) â Whether to write the instantaneous temperature to the file volume (bool=False) â Whether to write the periodic box volume to the file density (bool=False) â Whether to write the system density to the file progress (bool=False) â Whether to write current progress (percent completion) to the file. If this is True, you must also specify totalSteps. remainingTime (bool=False) â Whether to write an estimate of the remaining clock time until completion to the file. If this is True, you must also specify totalSteps. speed (bool=False) â Whether to write an estimate of the simulation speed in ns/day to the file elapsedTime (bool=False) â Whether to write the elapsed time of the simulation in seconds to the file. separator (string=',') â The separator to use between columns in the file systemMass (mass=None) â The total mass to use for the system when reporting density. If this is None (the default), the system mass is computed by summing the masses of all particles. This parameter is useful when the particle masses do not reflect their actual physical mass, such as when some particles have had their masses set to 0 to immobilize them. totalSteps (int=None) â The total number of steps that will be included in the simulation. This is required if either progress or remainingTime is set to True, and defines how many steps will indicate 100% completion. append (bool=False) â If true, append to an existing file. This has two effects. First, the file is opened in append mode. Second, the header line is not written, since there is assumed to already be a header line at the start of the file. Methods __init__(file,Â reportInterval[,Â step,Â time,Â â¦]) Create a StateDataReporter. describeNextReport(simulation) Get information about the next report this object will generate. report(simulation,Â state) Generate a report. describeNextReport(simulation)Â¶ Get information about the next report this object will generate. Parameters simulation (Simulation) â The Simulation to generate a report for Returns A five element tuple. The first element is the number of steps until the next report. The remaining elements specify whether that report will require positions, velocities, forces, and energies respectively. Return type tuple report(simulation, state)Â¶ Generate a report. Parameters simulation (Simulation) â The Simulation to generate a report for state (State) â The current state of the simulation

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.topology.Atom.html:
AtomÂ¶ class openmm.app.topology.Atom(name, element, index, residue, id)Â¶ An Atom object represents an atom within a Topology. __init__(name, element, index, residue, id)Â¶ Construct a new Atom. You should call addAtom() on the Topology instead of calling this directly. Methods __init__(name,Â element,Â index,Â residue,Â id) Construct a new Atom.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.topology.Chain.html:
ChainÂ¶ class openmm.app.topology.Chain(index, topology, id)Â¶ A Chain object represents a chain within a Topology. __init__(index, topology, id)Â¶ Construct a new Chain. You should call addChain() on the Topology instead of calling this directly. Methods __init__(index,Â topology,Â id) Construct a new Chain. atoms() Iterate over all Atoms in the Chain. residues() Iterate over all Residues in the Chain. residues()Â¶ Iterate over all Residues in the Chain. atoms()Â¶ Iterate over all Atoms in the Chain.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.topology.Residue.html:
ResidueÂ¶ class openmm.app.topology.Residue(name, index, chain, id, insertionCode)Â¶ A Residue object represents a residue within a Topology. __init__(name, index, chain, id, insertionCode)Â¶ Construct a new Residue. You should call addResidue() on the Topology instead of calling this directly. Methods __init__(name,Â index,Â chain,Â id,Â insertionCode) Construct a new Residue. atoms() Iterate over all Atoms in the Residue. bonds() Iterate over all Bonds involving any atom in this residue. external_bonds() Iterate over all Bonds to external atoms. internal_bonds() Iterate over all internal Bonds. atoms()Â¶ Iterate over all Atoms in the Residue. bonds()Â¶ Iterate over all Bonds involving any atom in this residue. internal_bonds()Â¶ Iterate over all internal Bonds. external_bonds()Â¶ Iterate over all Bonds to external atoms.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.topology.Topology.html:
TopologyÂ¶ class openmm.app.topology.TopologyÂ¶ Topology stores the topological information about a system. The structure of a Topology object is similar to that of a PDB file. It consists of a set of Chains (often but not always corresponding to polymer chains). Each Chain contains a set of Residues, and each Residue contains a set of Atoms. In addition, the Topology stores a list of which atom pairs are bonded to each other, and the dimensions of the crystallographic unit cell. Atom and residue names should follow the PDB 3.0 nomenclature for all molecules for which one exists. __init__()Â¶ Create a new Topology object Methods __init__() Create a new Topology object addAtom(name,Â element,Â residue[,Â id]) Create a new Atom and add it to the Topology. addBond(atom1,Â atom2[,Â type,Â order]) Create a new bond and add it to the Topology. addChain([id]) Create a new Chain and add it to the Topology. addResidue(name,Â chain[,Â id,Â insertionCode]) Create a new Residue and add it to the Topology. atoms() Iterate over all Atoms in the Topology. bonds() Iterate over all bonds in the Topology. chains() Iterate over all Chains in the Topology. createDisulfideBonds(positions) Identify disulfide bonds based on proximity and add them to the Topology. createStandardBonds() Create bonds based on the atom and residue names for all standard residue types. getNumAtoms() Return the number of atoms in the Topology. getNumBonds() Return the number of bonds in the Topology. getNumChains() Return the number of chains in the Topology. getNumResidues() Return the number of residues in the Topology. getPeriodicBoxVectors() Get the vectors defining the periodic box. getUnitCellDimensions() Get the dimensions of the crystallographic unit cell. loadBondDefinitions(file) Load an XML file containing definitions of bonds that should be used by createStandardBonds(). residues() Iterate over all Residues in the Topology. setPeriodicBoxVectors(vectors) Set the vectors defining the periodic box. setUnitCellDimensions(dimensions) Set the dimensions of the crystallographic unit cell. getNumAtoms()Â¶ Return the number of atoms in the Topology. getNumResidues()Â¶ Return the number of residues in the Topology. getNumChains()Â¶ Return the number of chains in the Topology. getNumBonds()Â¶ Return the number of bonds in the Topology. addChain(id=None)Â¶ Create a new Chain and add it to the Topology. Parameters id (string=None) â An optional identifier for the chain. If this is omitted, an id is generated based on the chain index. Returns the newly created Chain Return type Chain addResidue(name, chain, id=None, insertionCode='')Â¶ Create a new Residue and add it to the Topology. Parameters name (string) â The name of the residue to add chain (Chain) â The Chain to add it to id (string=None) â An optional identifier for the residue. If this is omitted, an id is generated based on the residue index. insertionCode (string='') â An optional insertion code for the residue. Returns the newly created Residue Return type Residue addAtom(name, element, residue, id=None)Â¶ Create a new Atom and add it to the Topology. Parameters name (string) â The name of the atom to add element (Element) â The element of the atom to add residue (Residue) â The Residue to add it to id (string=None) â An optional identifier for the atom. If this is omitted, an id is generated based on the atom index. Returns the newly created Atom Return type Atom addBond(atom1, atom2, type=None, order=None)Â¶ Create a new bond and add it to the Topology. Parameters atom1 (Atom) â The first Atom connected by the bond atom2 (Atom) â The second Atom connected by the bond type (object=None) â The type of bond to add. Allowed values are None, Single, Double, Triple, Aromatic, or Amide. order (int=None) â The bond order, or None if it is not specified chains()Â¶ Iterate over all Chains in the Topology. residues()Â¶ Iterate over all Residues in the Topology. atoms()Â¶ Iterate over all Atoms in the Topology. bonds()Â¶ Iterate over all bonds in the Topology. Each one is represented by a Bond object, which is a named tuple of two atoms. getPeriodicBoxVectors()Â¶ Get the vectors defining the periodic box. The return value may be None if this Topology does not represent a periodic structure. setPeriodicBoxVectors(vectors)Â¶ Set the vectors defining the periodic box. getUnitCellDimensions()Â¶ Get the dimensions of the crystallographic unit cell. The return value may be None if this Topology does not represent a periodic structure. setUnitCellDimensions(dimensions)Â¶ Set the dimensions of the crystallographic unit cell. This method is an alternative to setPeriodicBoxVectors() for the case of a rectangular box. It sets the box vectors to be orthogonal to each other and to have the specified lengths. static loadBondDefinitions(file)Â¶ Load an XML file containing definitions of bonds that should be used by createStandardBonds(). The built in residues.xml file containing definitions for standard amino acids and nucleotides is loaded automatically. This method can be used to load additional definitions for other residue types. They will then be used in subsequent calls to createStandardBonds(). This is a static method, so it affects subsequent calls on all Topology objects. Also note that PDBFile calls createStandardBonds() automatically when a file is loaded, so the newly loaded definitions will be used for any PDB file loaded after this is called. createStandardBonds()Â¶ Create bonds based on the atom and residue names for all standard residue types. Definitions for standard amino acids and nucleotides are built in. You can call loadBondDefinitions() to load additional definitions for other residue types. createDisulfideBonds(positions)Â¶ Identify disulfide bonds based on proximity and add them to the Topology. Parameters positions (list) â The list of atomic positions based on which to identify bonded atoms

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.xtcfile.XTCFile.html:
XTCFileÂ¶ class openmm.app.xtcfile.XTCFile(fileName, topology, dt, firstStep=0, interval=1, append=False)Â¶ XTCFile provides methods for creating XTC files. To use this class, create a XTCFile object, then call writeModel() once for each model in the file. __init__(fileName, topology, dt, firstStep=0, interval=1, append=False)Â¶ Create a XTC file, or open an existing file to append. Parameters fileName (str) â A file name to write to topology (Topology) â The Topology defining the molecular system being written dt (time) â The time step used in the trajectory firstStep (int=0) â The index of the first step in the trajectory interval (int=1) â The frequency (measured in time steps) at which states are written to the trajectory append (bool=False) â If True, open an existing XTC file to append to. If False, create a new file. Methods __init__(fileName,Â topology,Â dt[,Â â¦]) Create a XTC file, or open an existing file to append. writeModel(positions[,Â unitCellDimensions,Â â¦]) Write out a model to the XTC file. writeModel(positions, unitCellDimensions=None, periodicBoxVectors=None)Â¶ Write out a model to the XTC file. The periodic box can be specified either by the unit cell dimensions (for a rectangular box), or the full set of box vectors (for an arbitrary triclinic box). If neither is specified, the box vectors specified in the Topology will be used. Regardless of the value specified, no dimensions will be written if the Topology does not represent a periodic system. Parameters positions (list) â The list of atomic positions to write unitCellDimensions (Vec3=None) â The dimensions of the crystallographic unit cell. periodicBoxVectors (tuple of Vec3=None) â The vectors defining the periodic box.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.app.xtcreporter.XTCReporter.html:
XTCReporterÂ¶ class openmm.app.xtcreporter.XTCReporter(file, reportInterval, append=False, enforcePeriodicBox=None)Â¶ XTCReporter outputs a series of frames from a Simulation to a XTC file. To use it, create a XTCReporter, then add it to the Simulationâs list of reporters. __init__(file, reportInterval, append=False, enforcePeriodicBox=None)Â¶ Create a XTCReporter. Parameters file (string) â The file to write to reportInterval (int) â The interval (in time steps) at which to write frames append (bool=False) â If True, open an existing XTC file to append to. If False, create a new file. enforcePeriodicBox (bool) â Specifies whether particle positions should be translated so the center of every molecule lies in the same periodic box. If None (the default), it will automatically decide whether to translate molecules based on whether the system being simulated uses periodic boundary conditions. Methods __init__(file,Â reportInterval[,Â append,Â â¦]) Create a XTCReporter. describeNextReport(simulation) Get information about the next report this object will generate. report(simulation,Â state) Generate a report. describeNextReport(simulation)Â¶ Get information about the next report this object will generate. Parameters simulation (Simulation) â The Simulation to generate a report for Returns A six element tuple. The first element is the number of steps until the next report. The next four elements specify whether that report will require positions, velocities, forces, and energies respectively. The final element specifies whether positions should be wrapped to lie in a single periodic box. Return type tuple report(simulation, state)Â¶ Generate a report. Parameters simulation (Simulation) â The Simulation to generate a report for state (State) â The current state of the simulation

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.mtsintegrator.MTSIntegrator.html:
MTSIntegratorÂ¶ class openmm.mtsintegrator.MTSIntegrator(dt, groups)Â¶ MTSIntegrator implements the rRESPA multiple time step integration algorithm. This integrator allows different forces to be evaluated at different frequencies, for example to evaluate the expensive, slowly changing forces less frequently than the inexpensive, quickly changing forces. To use it, you must first divide your forces into two or more groups (by calling setForceGroup() on them) that should be evaluated at different frequencies. When you create the integrator, you provide a tuple for each group specifying the index of the force group and the frequency (as a fraction of the outermost time step) at which to evaluate it. For example: integrator = MTSIntegrator(4*femtoseconds, [(0,1), (1,2), (2,8)]) This specifies that the outermost time step is 4 fs, so each step of the integrator will advance time by that much. It also says that force group 0 should be evaluated once per time step, force group 1 should be evaluated twice per time step (every 2 fs), and force group 2 should be evaluated eight times per time step (every 0.5 fs). A common use of this algorithm is to evaluate reciprocal space nonbonded interactions less often than the bonded and direct space nonbonded interactions. The following example looks up the NonbondedForce, sets the reciprocal space interactions to their own force group, and then creates an integrator that evaluates them once every 4 fs, but all other interactions every 2 fs: nonbonded = [f for f in system.getForces() if isinstance(f, NonbondedForce)][0] nonbonded.setReciprocalSpaceForceGroup(1) integrator = MTSIntegrator(4*femtoseconds, [(1,1), (0,2)]) For details, see Tuckerman et al., J. Chem. Phys. 97(3) pp. 1990-2001 (1992). __init__(dt, groups)Â¶ Create an MTSIntegrator. Parameters dt (time) â The largest (outermost) integration time step to use groups (list) â A list of tuples defining the force groups. The first element of each tuple is the force group index, and the second element is the number of times that force group should be evaluated in one time step. Methods __init__(dt,Â groups) Create an MTSIntegrator. addComputeGlobal(self,Â variable,Â expression) Add a step to the integration algorithm that computes a global value. addComputePerDof(self,Â variable,Â expression) Add a step to the integration algorithm that computes a per-DOF value. addComputeSum(self,Â variable,Â expression) Add a step to the integration algorithm that computes a sum over degrees of freedom. addConstrainPositions(self) Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. addConstrainVelocities(self) Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. addGlobalVariable(self,Â name,Â initialValue) Define a new global variable. addPerDofVariable(self,Â name,Â initialValue) Define a new per-DOF variable. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in expressions. addUpdateContextState(self) Add a step to the integration algorithm that allows Forces to update the context state. beginIfBlock(self,Â condition) Add a step which begins a new âifâ block. beginWhileBlock(self,Â condition) Add a step which begins a new âwhileâ block. endBlock(self) Add a step which marks the end of the most recently begun âifâ or âwhileâ block. getComputationStep(self,Â index) Get the details of a computation step that has been added to the integration algorithm. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getGlobalVariable(self,Â index) Get the current value of a global variable. getGlobalVariableByName(self,Â name) Get the current value of a global variable, specified by name. getGlobalVariableName(self,Â index) Get the name of a global variable. getIntegrationForceGroups(self) Get which force groups to use for integration. getKineticEnergyExpression(self) Get the expression to use for computing the kinetic energy. getNumComputations(self) Get the number of computation steps that have been added. getNumGlobalVariables(self) Get the number of global variables that have been defined. getNumPerDofVariables(self) Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerDofVariable() getPerDofVariableByName(self,Â name) Get the value of a per-DOF variable, specified by name. getPerDofVariableName(self,Â index) Get the name of a per-DOF variable. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in expressions. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in expressions. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setGlobalVariable(self,Â index,Â value) Set the value of a global variable. setGlobalVariableByName(self,Â name,Â value) Set the value of a global variable, specified by name. setIntegrationForceGroups(groups) Set which force groups to use for integration. setKineticEnergyExpression(self,Â expression) Set the expression to use for computing the kinetic energy. setPerDofVariable(self,Â index,Â values) Set the value of a per-DOF variable. setPerDofVariableByName(self,Â name,Â values) Set the value of a per-DOF variable, specified by name. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes BlockEnd ComputeGlobal ComputePerDof ComputeSum ConstrainPositions ConstrainVelocities IfBlockStart UpdateContextState WhileBlockStart thisown The membership flag addComputeGlobal(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a global value. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving only global variables. In each integration step, its value is computed and stored into the specified variable. Returns the index of the step that was added Return type int addComputePerDof(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a per-DOF value. Parameters variable (string) â the per-DOF variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom and stored into the specified variable. Returns the index of the step that was added Return type int addComputeSum(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a sum over degrees of freedom. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom. Those values are then added together, and the sum is stored in the specified variable. Returns the index of the step that was added Return type int addConstrainPositions(self) → intÂ¶ Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. Returns the index of the step that was added Return type int addConstrainVelocities(self) → intÂ¶ Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. Returns the index of the step that was added Return type int addGlobalVariable(self, name, initialValue) → intÂ¶ Define a new global variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value Returns the index of the variable that was added Return type int addPerDofVariable(self, name, initialValue) → intÂ¶ Define a new per-DOF variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value for all degrees of freedom Returns the index of the variable that was added Return type int addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in expressions. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The integrator takes over ownership of it, and deletes it when the integrator itself is deleted. Returns the index of the function that was added Return type int addUpdateContextState(self) → intÂ¶ Add a step to the integration algorithm that allows Forces to update the context state. Returns the index of the step that was added Return type int beginIfBlock(self, condition) → intÂ¶ Add a step which begins a new âifâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed only if the condition is true. Returns the index of the step that was added Return type int beginWhileBlock(self, condition) → intÂ¶ Add a step which begins a new âwhileâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed repeatedly as long as the condition remains true. Returns the index of the step that was added Return type int endBlock(self) → intÂ¶ Add a step which marks the end of the most recently begun âifâ or âwhileâ block. Returns the index of the step that was added Return type int getComputationStep(self, index)Â¶ Get the details of a computation step that has been added to the integration algorithm. Parameters index (int) â the index of the computation step to get Returns type (ComputationType) â the type of computation this step performs variable (string) â the variable into which this step stores its result. If this step does not store a result in a variable, this will be an empty string. expression (string) â the expression this step evaluates. If this step does not evaluate an expression, this will be an empty string. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getGlobalVariable(self, index) → doubleÂ¶ Get the current value of a global variable. Parameters index (int) â the index of the variable to get Returns the current value of the variable Return type double getGlobalVariableByName(self, name) → doubleÂ¶ Get the current value of a global variable, specified by name. Parameters name (string) â the name of the variable to get Returns the current value of the parameter Return type double getGlobalVariableName(self, index) → std::string const &Â¶ Get the name of a global variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getKineticEnergyExpression(self) → std::string const &Â¶ Get the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. getNumComputations(self) → intÂ¶ Get the number of computation steps that have been added. getNumGlobalVariables(self) → intÂ¶ Get the number of global variables that have been defined. getNumPerDofVariables(self) → intÂ¶ Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getPerDofVariable(self, index)Â¶ getPerDofVariable(self, index) → PyObject * getPerDofVariableByName(self, name)Â¶ Get the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to get Returns values â the values of the variable for all degrees of freedom are stored into this Return type vector< Vec3 > getPerDofVariableName(self, index) → std::string const &Â¶ Get the name of a per-DOF variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setGlobalVariable(self, index, value)Â¶ Set the value of a global variable. Parameters index (int) â the index of the variable to set value (double) â the new value of the variable setGlobalVariableByName(self, name, value)Â¶ Set the value of a global variable, specified by name. Parameters name (string) â the name of the variable to set value (double) â the new value of the variable setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setKineticEnergyExpression(self, expression)Â¶ Set the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. setPerDofVariable(self, index, values)Â¶ Set the value of a per-DOF variable. Parameters index (int) â the index of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setPerDofVariableByName(self, name, values)Â¶ Set the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random numbers will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take property thisownÂ¶ The membership flag

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.mtsintegrator.MTSLangevinIntegrator.html:
MTSLangevinIntegratorÂ¶ class openmm.mtsintegrator.MTSLangevinIntegrator(temperature, friction, dt, groups)Â¶ MTSLangevinIntegrator implements the BAOAB-RESPA multiple time step algorithm for constant temperature dynamics. This integrator allows different forces to be evaluated at different frequencies, for example to evaluate the expensive, slowly changing forces less frequently than the inexpensive, quickly changing forces. To use it, you must first divide your forces into two or more groups (by calling setForceGroup() on them) that should be evaluated at different frequencies. When you create the integrator, you provide a tuple for each group specifying the index of the force group and the frequency (as a fraction of the outermost time step) at which to evaluate it. For example: integrator = MTSLangevinIntegrator(300*kelvin, 1/picosecond, 4*femtoseconds, [(0,1), (1,2), (2,8)]) This specifies that the outermost time step is 4 fs, so each step of the integrator will advance time by that much. It also says that force group 0 should be evaluated once per time step, force group 1 should be evaluated twice per time step (every 2 fs), and force group 2 should be evaluated eight times per time step (every 0.5 fs). A common use of this algorithm is to evaluate reciprocal space nonbonded interactions less often than the bonded and direct space nonbonded interactions. The following example looks up the NonbondedForce, sets the reciprocal space interactions to their own force group, and then creates an integrator that evaluates them once every 4 fs, but all other interactions every 2 fs: nonbonded = [f for f in system.getForces() if isinstance(f, NonbondedForce)][0] nonbonded.setReciprocalSpaceForceGroup(1) integrator = MTSLangevinIntegrator(300*kelvin, 1/picosecond, 4*femtoseconds, [(1,1), (0,2)]) For details, see Tuckerman et al., J. Chem. Phys. 97(3) pp. 1990-2001 (1992) and Lagardere et al., J. Phys. Chem. Lett. 10(10) pp. 2593-2599 (2019). __init__(temperature, friction, dt, groups)Â¶ Create an MTSLangevinIntegrator. Parameters temperature (temperature) â the temperature of the heat bath friction (1/temperature) â the friction coefficient which couples the system to the heat bath dt (time) â The largest (outermost) integration time step to use groups (list) â A list of tuples defining the force groups. The first element of each tuple is the force group index, and the second element is the number of times that force group should be evaluated in one time step. Methods __init__(temperature,Â friction,Â dt,Â groups) Create an MTSLangevinIntegrator. addComputeGlobal(self,Â variable,Â expression) Add a step to the integration algorithm that computes a global value. addComputePerDof(self,Â variable,Â expression) Add a step to the integration algorithm that computes a per-DOF value. addComputeSum(self,Â variable,Â expression) Add a step to the integration algorithm that computes a sum over degrees of freedom. addConstrainPositions(self) Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. addConstrainVelocities(self) Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. addGlobalVariable(self,Â name,Â initialValue) Define a new global variable. addPerDofVariable(self,Â name,Â initialValue) Define a new per-DOF variable. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in expressions. addUpdateContextState(self) Add a step to the integration algorithm that allows Forces to update the context state. beginIfBlock(self,Â condition) Add a step which begins a new âifâ block. beginWhileBlock(self,Â condition) Add a step which begins a new âwhileâ block. endBlock(self) Add a step which marks the end of the most recently begun âifâ or âwhileâ block. getComputationStep(self,Â index) Get the details of a computation step that has been added to the integration algorithm. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getGlobalVariable(self,Â index) Get the current value of a global variable. getGlobalVariableByName(self,Â name) Get the current value of a global variable, specified by name. getGlobalVariableName(self,Â index) Get the name of a global variable. getIntegrationForceGroups(self) Get which force groups to use for integration. getKineticEnergyExpression(self) Get the expression to use for computing the kinetic energy. getNumComputations(self) Get the number of computation steps that have been added. getNumGlobalVariables(self) Get the number of global variables that have been defined. getNumPerDofVariables(self) Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerDofVariable() getPerDofVariableByName(self,Â name) Get the value of a per-DOF variable, specified by name. getPerDofVariableName(self,Â index) Get the name of a per-DOF variable. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in expressions. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in expressions. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setGlobalVariable(self,Â index,Â value) Set the value of a global variable. setGlobalVariableByName(self,Â name,Â value) Set the value of a global variable, specified by name. setIntegrationForceGroups(groups) Set which force groups to use for integration. setKineticEnergyExpression(self,Â expression) Set the expression to use for computing the kinetic energy. setPerDofVariable(self,Â index,Â values) Set the value of a per-DOF variable. setPerDofVariableByName(self,Â name,Â values) Set the value of a per-DOF variable, specified by name. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes BlockEnd ComputeGlobal ComputePerDof ComputeSum ConstrainPositions ConstrainVelocities IfBlockStart UpdateContextState WhileBlockStart thisown The membership flag addComputeGlobal(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a global value. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving only global variables. In each integration step, its value is computed and stored into the specified variable. Returns the index of the step that was added Return type int addComputePerDof(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a per-DOF value. Parameters variable (string) â the per-DOF variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom and stored into the specified variable. Returns the index of the step that was added Return type int addComputeSum(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a sum over degrees of freedom. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom. Those values are then added together, and the sum is stored in the specified variable. Returns the index of the step that was added Return type int addConstrainPositions(self) → intÂ¶ Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. Returns the index of the step that was added Return type int addConstrainVelocities(self) → intÂ¶ Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. Returns the index of the step that was added Return type int addGlobalVariable(self, name, initialValue) → intÂ¶ Define a new global variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value Returns the index of the variable that was added Return type int addPerDofVariable(self, name, initialValue) → intÂ¶ Define a new per-DOF variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value for all degrees of freedom Returns the index of the variable that was added Return type int addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in expressions. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The integrator takes over ownership of it, and deletes it when the integrator itself is deleted. Returns the index of the function that was added Return type int addUpdateContextState(self) → intÂ¶ Add a step to the integration algorithm that allows Forces to update the context state. Returns the index of the step that was added Return type int beginIfBlock(self, condition) → intÂ¶ Add a step which begins a new âifâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed only if the condition is true. Returns the index of the step that was added Return type int beginWhileBlock(self, condition) → intÂ¶ Add a step which begins a new âwhileâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed repeatedly as long as the condition remains true. Returns the index of the step that was added Return type int endBlock(self) → intÂ¶ Add a step which marks the end of the most recently begun âifâ or âwhileâ block. Returns the index of the step that was added Return type int getComputationStep(self, index)Â¶ Get the details of a computation step that has been added to the integration algorithm. Parameters index (int) â the index of the computation step to get Returns type (ComputationType) â the type of computation this step performs variable (string) â the variable into which this step stores its result. If this step does not store a result in a variable, this will be an empty string. expression (string) â the expression this step evaluates. If this step does not evaluate an expression, this will be an empty string. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getGlobalVariable(self, index) → doubleÂ¶ Get the current value of a global variable. Parameters index (int) â the index of the variable to get Returns the current value of the variable Return type double getGlobalVariableByName(self, name) → doubleÂ¶ Get the current value of a global variable, specified by name. Parameters name (string) â the name of the variable to get Returns the current value of the parameter Return type double getGlobalVariableName(self, index) → std::string const &Â¶ Get the name of a global variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getKineticEnergyExpression(self) → std::string const &Â¶ Get the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. getNumComputations(self) → intÂ¶ Get the number of computation steps that have been added. getNumGlobalVariables(self) → intÂ¶ Get the number of global variables that have been defined. getNumPerDofVariables(self) → intÂ¶ Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getPerDofVariable(self, index)Â¶ getPerDofVariable(self, index) → PyObject * getPerDofVariableByName(self, name)Â¶ Get the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to get Returns values â the values of the variable for all degrees of freedom are stored into this Return type vector< Vec3 > getPerDofVariableName(self, index) → std::string const &Â¶ Get the name of a per-DOF variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setGlobalVariable(self, index, value)Â¶ Set the value of a global variable. Parameters index (int) â the index of the variable to set value (double) â the new value of the variable setGlobalVariableByName(self, name, value)Â¶ Set the value of a global variable, specified by name. Parameters name (string) â the name of the variable to set value (double) â the new value of the variable setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setKineticEnergyExpression(self, expression)Â¶ Set the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. setPerDofVariable(self, index, values)Â¶ Set the value of a per-DOF variable. Parameters index (int) â the index of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setPerDofVariableByName(self, name, values)Â¶ Set the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random numbers will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take property thisownÂ¶ The membership flag

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.AmoebaGeneralizedKirkwoodForce.html:
AmoebaGeneralizedKirkwoodForceÂ¶ class openmm.openmm.AmoebaGeneralizedKirkwoodForce(*args)Â¶ This class implements an implicit solvation force using the generalized Kirkwood/Grycuk model. To use this class, create an AmoebaGeneralizedKirkwoodForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define parameters must be equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). __init__(self) → AmoebaGeneralizedKirkwoodForceÂ¶ __init__(self, other) → AmoebaGeneralizedKirkwoodForce This class implements an implicit solvation force using the generalized Kirkwood/Grycuk model. To use this class, create an AmoebaGeneralizedKirkwoodForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define parameters must be equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). Methods __init__(->Â AmoebaGeneralizedKirkwoodForce) This class implements an implicit solvation force using the generalized Kirkwood/Grycuk model. addParticle(self,Â charge,Â radius,Â scalingFactor) Add the parameters for a particle. getForceGroup(self) Get the force group this Force belongs to. getIncludeCavityTerm(self) Get the flag signaling whether the cavity term should be included getName(self) Get the name of this Force. getNumParticles(self) Get the number of particles in the system. getParticleParameters(self,Â index) Get the force field parameters for a particle. getProbeRadius(self) Get the probe radius (nm) used in SASA contribution getSoluteDielectric(self) Get the dielectric constant for the solute. getSolventDielectric(self) Get the dielectric constant for the solvent. getSurfaceAreaFactor(self) Get the surface area factor kJ/(nm*nm) used in SASA contribution setForceGroup(self,Â group) Set the force group this Force belongs to. setIncludeCavityTerm(self,Â includeCavityTerm) Set the flag signaling whether the cavity term should be included setName(self,Â name) Set the name of this Force. setParticleParameters(self,Â index,Â charge,Â â¦) Set the force field parameters for a particle. setProbeRadius(self,Â probeRadius) Set the probe radius (nm) used in SASA contribution setSoluteDielectric(self,Â dielectric) Set the dielectric constant for the solute. setSolventDielectric(self,Â dielectric) Set the dielectric constant for the solvent. setSurfaceAreaFactor(self,Â surfaceAreaFactor) Set the surface area factor kJ/(nm*nm) used in SASA contribution updateParametersInContext(self,Â context) Update the per-particle parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles in the system. addParticle(self, charge, radius, scalingFactor) → intÂ¶ Add the parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. Parameters charge (double) â the charge of the particle, measured in units of the proton charge radius (double) â the atomic radius of the particle, measured in nm scalingFactor (double) â the scaling factor for the particle Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the force field parameters for a particle. Parameters index (int) â the index of the particle for which to get parameters Returns charge (double) â the charge of the particle, measured in units of the proton charge radius (double) â the atomic radius of the particle, measured in nm scalingFactor (double) â the scaling factor for the particle setParticleParameters(self, index, charge, radius, scalingFactor)Â¶ Set the force field parameters for a particle. Parameters index (int) â the index of the particle for which to set parameters charge (double) â the charge of the particle, measured in units of the proton charge radius (double) â the atomic radius of the particle, measured in nm scalingFactor (double) â the scaling factor for the particle getSolventDielectric(self) → doubleÂ¶ Get the dielectric constant for the solvent. setSolventDielectric(self, dielectric)Â¶ Set the dielectric constant for the solvent. getSoluteDielectric(self) → doubleÂ¶ Get the dielectric constant for the solute. setSoluteDielectric(self, dielectric)Â¶ Set the dielectric constant for the solute. getIncludeCavityTerm(self) → intÂ¶ Get the flag signaling whether the cavity term should be included setIncludeCavityTerm(self, includeCavityTerm)Â¶ Set the flag signaling whether the cavity term should be included getProbeRadius(self) → doubleÂ¶ Get the probe radius (nm) used in SASA contribution setProbeRadius(self, probeRadius)Â¶ Set the probe radius (nm) used in SASA contribution getSurfaceAreaFactor(self) → doubleÂ¶ Get the surface area factor kJ/(nm*nm) used in SASA contribution setSurfaceAreaFactor(self, surfaceAreaFactor)Â¶ Set the surface area factor kJ/(nm*nm) used in SASA contribution updateParametersInContext(self, context)Â¶ Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-particle parameters. All other aspects of the Force (the probe radius, the surface area factor, etc.) are unaffected and can only be changed by reinitializing the Context. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if nonbondedMethod uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.AmoebaMultipoleForce.html:
AmoebaMultipoleForceÂ¶ class openmm.openmm.AmoebaMultipoleForce(*args)Â¶ This class implements the Amoeba multipole interaction. To use it, create an AmoebaMultipoleForce object then call addMultipole() once for each atom. After an entry has been added, you can modify its force field parameters by calling setMultipoleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). __init__(self) → AmoebaMultipoleForceÂ¶ __init__(self, other) → AmoebaMultipoleForce Create an AmoebaMultipoleForce. Methods __init__(->Â AmoebaMultipoleForce) Create an AmoebaMultipoleForce. addMultipole(self,Â charge,Â molecularDipole,Â â¦) Add multipole-related info for a particle getAEwald(self) Get the Ewald alpha parameter. getCovalentMap(self,Â index,Â typeId) Get the CovalentMap for an atom getCovalentMaps(self,Â index) Get the CovalentMap for an atom getCutoffDistance(self) Get the cutoff distance (in nm) being used for nonbonded interactions. getElectrostaticPotential(self,Â inputGrid,Â â¦) Get the electrostatic potential. getEwaldErrorTolerance(self) Get the error tolerance for Ewald summation. getExtrapolationCoefficients(self) Get the coefficients for the mu_0, mu_1, mu_2, â¦, mu_n terms in the extrapolation algorithm for induced dipoles. getForceGroup(self) Get the force group this Force belongs to. getInducedDipoles(self,Â context) Get the induced dipole moments of all particles. getLabFramePermanentDipoles(self,Â context) Get the fixed dipole moments of all particles in the global reference frame. getMultipoleParameters(self,Â index) Get the multipole parameters for a particle. getMutualInducedMaxIterations(self) Get the max number of iterations to be used in calculating the mutual induced dipoles getMutualInducedTargetEpsilon(self) Get the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long-range nonbonded interactions. getNumMultipoles(self) Get the number of particles in the potential function getPMEParameters(self) Get the parameters to use for PME calculations. getPMEParametersInContext(self,Â context) Get the parameters being used for PME in a particular Context. getPmeBSplineOrder(self) Get the B-spline order to use for PME charge spreading getPmeGridDimensions(self) Get the PME grid dimensions. getPolarizationType(self) Get polarization type getSystemMultipoleMoments(self,Â context) Get the system multipole moments. getTotalDipoles(self,Â context) Get the total dipole moments (fixed plus induced) of all particles. setAEwald(self,Â aewald) Set the Ewald alpha parameter. setCovalentMap(self,Â index,Â typeId,Â â¦) Set the CovalentMap for an atom setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for nonbonded interactions. setEwaldErrorTolerance(self,Â tol) Get the error tolerance for Ewald summation. setExtrapolationCoefficients(self,Â coefficients) Set the coefficients for the mu_0, mu_1, mu_2, â¦, mu_n terms in the extrapolation algorithm for induced dipoles. setForceGroup(self,Â group) Set the force group this Force belongs to. setMultipoleParameters(self,Â index,Â charge,Â â¦) Set the multipole parameters for a particle. setMutualInducedMaxIterations(self,Â â¦) Set the max number of iterations to be used in calculating the mutual induced dipoles setMutualInducedTargetEpsilon(self,Â â¦) Set the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long-range nonbonded interactions. setPMEParameters(self,Â alpha,Â nx,Â ny,Â nz) Set the parameters to use for PME calculations. setPmeGridDimensions(self,Â gridDimension) Set the PME grid dimensions. setPolarizationType(self,Â type) Set the polarization type updateParametersInContext(self,Â context) Update the multipole parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes Bisector Covalent12 Covalent13 Covalent14 Covalent15 CovalentEnd Direct Extrapolated LastAxisTypeIndex Mutual NoAxisType NoCutoff PME PolarizationCovalent11 PolarizationCovalent12 PolarizationCovalent13 PolarizationCovalent14 ThreeFold ZBisect ZOnly ZThenX thisown The membership flag property thisownÂ¶ The membership flag getNumMultipoles(self) → intÂ¶ Get the number of particles in the potential function getNonbondedMethod(self) → OpenMM::AmoebaMultipoleForce::NonbondedMethodÂ¶ Get the method used for handling long-range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long-range nonbonded interactions. getPolarizationType(self) → OpenMM::AmoebaMultipoleForce::PolarizationTypeÂ¶ Get polarization type setPolarizationType(self, type)Â¶ Set the polarization type getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm getPMEParameters(self)Â¶ Get the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Returns alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis setPMEParameters(self, alpha, nx, ny, nz)Â¶ Set the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis getAEwald(self) → doubleÂ¶ Get the Ewald alpha parameter. If this is 0 (the default), a value is chosen automatically based on the Ewald error tolerance. Deprecated This method exists only for backward compatibility. Use getPMEParameters() instead. Returns the Ewald alpha parameter Return type double setAEwald(self, aewald)Â¶ Set the Ewald alpha parameter. If this is 0 (the default), a value is chosen automatically based on the Ewald error tolerance. Deprecated This method exists only for backward compatibility. Use setPMEParameters() instead. Parameters aewald (double) â alpha parameter getPmeBSplineOrder(self) → intÂ¶ Get the B-spline order to use for PME charge spreading Returns the B-spline order Return type int getPmeGridDimensions(self)Â¶ Get the PME grid dimensions. If Ewald alpha is 0 (the default), this is ignored and grid dimensions are chosen automatically based on the Ewald error tolerance. Deprecated This method exists only for backward compatibility. Use getPMEParameters() instead. Returns the PME grid dimensions Return type void setPmeGridDimensions(self, gridDimension)Â¶ Set the PME grid dimensions. If Ewald alpha is 0 (the default), this is ignored and grid dimensions are chosen automatically based on the Ewald error tolerance. Deprecated This method exists only for backward compatibility. Use setPMEParameters() instead. Parameters gridDimension (vector< int >) â the PME grid dimensions getPMEParametersInContext(self, context)Â¶ Get the parameters being used for PME in a particular Context. Because some platforms have restrictions on the allowed grid sizes, the values that are actually used may be slightly different from those specified with setPmeGridDimensions(), or the standard values calculated based on the Ewald error tolerance. See the manual for details. Parameters context (Context) â the Context for which to get the parameters Returns alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis addMultipole(self, charge, molecularDipole, molecularQuadrupole, axisType, multipoleAtomZ, multipoleAtomX, multipoleAtomY, thole, dampingFactor, polarity) → intÂ¶ Add multipole-related info for a particle Parameters charge (double) â the particleâs charge molecularDipole (vector< double >) â the particleâs molecular dipole (vector of size 3) molecularQuadrupole (vector< double >) â the particleâs molecular quadrupole (vector of size 9) axisType (int) â the particleâs axis type multipoleAtomZ (int) â index of first atom used in constructing lab<->molecular frames multipoleAtomX (int) â index of second atom used in constructing lab<->molecular frames multipoleAtomY (int) â index of second atom used in constructing lab<->molecular frames thole (double) â Thole parameter dampingFactor (double) â dampingFactor parameter polarity (double) â polarity parameter Returns the index of the particle that was added Return type int getMultipoleParameters(self, index)Â¶ Get the multipole parameters for a particle. Parameters index (int) â the index of the atom for which to get parameters Returns charge (double) â the particleâs charge molecularDipole (vector< double >) â the particleâs molecular dipole (vector of size 3) molecularQuadrupole (vector< double >) â the particleâs molecular quadrupole (vector of size 9) axisType (int) â the particleâs axis type multipoleAtomZ (int) â index of first atom used in constructing lab<->molecular frames multipoleAtomX (int) â index of second atom used in constructing lab<->molecular frames multipoleAtomY (int) â index of second atom used in constructing lab<->molecular frames thole (double) â Thole parameter dampingFactor (double) â dampingFactor parameter polarity (double) â polarity parameter setMultipoleParameters(self, index, charge, molecularDipole, molecularQuadrupole, axisType, multipoleAtomZ, multipoleAtomX, multipoleAtomY, thole, dampingFactor, polarity)Â¶ Set the multipole parameters for a particle. Parameters index (int) â the index of the atom for which to set parameters charge (double) â the particleâs charge molecularDipole (vector< double >) â the particleâs molecular dipole (vector of size 3) molecularQuadrupole (vector< double >) â the particleâs molecular quadrupole (vector of size 9) axisType (int) â the particleâs axis type multipoleAtomZ (int) â index of first atom used in constructing lab<->molecular frames multipoleAtomX (int) â index of second atom used in constructing lab<->molecular frames multipoleAtomY (int) â index of second atom used in constructing lab<->molecular frames thole (double) â thole parameter dampingFactor (double) â damping factor parameter polarity (double) â polarity parameter setCovalentMap(self, index, typeId, covalentAtoms)Â¶ Set the CovalentMap for an atom Parameters index (int) â the index of the atom for which to set parameters typeId (CovalentType) â CovalentTypes type covalentAtoms (vector< int >) â vector of covalent atoms associated w/ the specfied CovalentType getCovalentMap(self, index, typeId)Â¶ Get the CovalentMap for an atom Parameters index (int) â the index of the atom for which to set parameters typeId (CovalentType) â CovalentTypes type Returns covalentAtoms â output vector of covalent atoms associated w/ the specfied CovalentType Return type vector< int > getCovalentMaps(self, index)Â¶ Get the CovalentMap for an atom Parameters index (int) â the index of the atom for which to set parameters Returns covalentLists â output vector of covalent lists of atoms Return type vector< std::vector< int > > getMutualInducedMaxIterations(self) → intÂ¶ Get the max number of iterations to be used in calculating the mutual induced dipoles Returns max number of iterations Return type int setMutualInducedMaxIterations(self, inputMutualInducedMaxIterations)Â¶ Set the max number of iterations to be used in calculating the mutual induced dipoles Parameters inputMutualInducedMaxIterations (int) â number of iterations getMutualInducedTargetEpsilon(self) → doubleÂ¶ Get the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles Returns target epsilon Return type double setMutualInducedTargetEpsilon(self, inputMutualInducedTargetEpsilon)Â¶ Set the target epsilon to be used to test for convergence of iterative method used in calculating the mutual induced dipoles Parameters inputMutualInducedTargetEpsilon (double) â target epsilon setExtrapolationCoefficients(self, coefficients)Â¶ Set the coefficients for the mu_0, mu_1, mu_2, â¦, mu_n terms in the extrapolation algorithm for induced dipoles. Parameters coefficients (vector< double >) â a vector whose mth entry specifies the coefficient for mu_m. The length of this vector determines how many iterations are performed. getExtrapolationCoefficients(self) → vectordÂ¶ Get the coefficients for the mu_0, mu_1, mu_2, â¦, mu_n terms in the extrapolation algorithm for induced dipoles. In this release, the default values for the coefficients are [-0.154, 0.017, 0.658, 0.474], but be aware that those may change in a future release. getEwaldErrorTolerance(self) → doubleÂ¶ Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the grid dimensions and separation (alpha) parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however. This can be overridden by explicitly setting an alpha parameter and grid dimensions to use. setEwaldErrorTolerance(self, tol)Â¶ Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the grid dimensions and separation (alpha) parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however. This can be overridden by explicitly setting an alpha parameter and grid dimensions to use. getLabFramePermanentDipoles(self, context)Â¶ Get the fixed dipole moments of all particles in the global reference frame. Parameters context (Context) â the Context for which to get the fixed dipoles Returns dipoles â the fixed dipole moment of particle i is stored into the iâth element Return type vector< Vec3 > getInducedDipoles(self, context)Â¶ Get the induced dipole moments of all particles. Parameters context (Context) â the Context for which to get the induced dipoles Returns dipoles â the induced dipole moment of particle i is stored into the iâth element Return type vector< Vec3 > getTotalDipoles(self, context)Â¶ Get the total dipole moments (fixed plus induced) of all particles. Parameters context (Context) â the Context for which to get the total dipoles Returns dipoles â the total dipole moment of particle i is stored into the iâth element Return type vector< Vec3 > getElectrostaticPotential(self, inputGrid, context)Â¶ Get the electrostatic potential. Parameters inputGrid (vector< Vec3 >) â input grid points over which the potential is to be evaluated context (Context) â context Returns outputElectrostaticPotential â output potential Return type vector< double > getSystemMultipoleMoments(self, context)Â¶ Get the system multipole moments. This method is most useful for non-periodic systems. When called for a periodic system, only the lowest nonvanishing moment has a well defined value. This means that if the system has a net nonzero charge, the dipole and quadrupole moments are not well defined and should be ignored. If the net charge is zero, the dipole moment is well defined (and really represents a dipole density), but the quadrupole moment is still undefined and should be ignored. Parameters context (Context) â context Returns outputMultipoleMoments â (charge, dipole_x, dipole_y, dipole_z, quadrupole_xx, quadrupole_xy, quadrupole_xz, quadrupole_yx, quadrupole_yy, quadrupole_yz, quadrupole_zx, quadrupole_zy, quadrupole_zz) Return type vector< double > updateParametersInContext(self, context)Â¶ Update the multipole parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setMultipoleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the parameters of multipoles. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, this method cannot be used to add new multipoles, only to change the parameters of existing ones. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if nonbondedMethod uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.AmoebaTorsionTorsionForce.html:
AmoebaTorsionTorsionForceÂ¶ class openmm.openmm.AmoebaTorsionTorsionForce(*args)Â¶ This class implements the Amoeba torsion-torsion interaction. To use it, create an AmoebaTorsionTorsionForce object then call addTorsionTorsion() once for each torsion-torsion. After a torsion-torsion has been added, you can modify its force field parameters by calling setTorsionTorsionParameters(). __init__(self) → AmoebaTorsionTorsionForceÂ¶ __init__(self, other) → AmoebaTorsionTorsionForce Create an AmoebaTorsionTorsionForce. Methods __init__(->Â AmoebaTorsionTorsionForce) Create an AmoebaTorsionTorsionForce. addTorsionTorsion(self,Â particle1,Â â¦) Add a torsion-torsion term to the force field. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNumTorsionTorsionGrids(self) Get the number of torsion-torsion grids getNumTorsionTorsions(self) Get the number of torsion-torsion terms in the potential function getTorsionTorsionGrid(self,Â index) Get the torsion-torsion grid at the specified index getTorsionTorsionParameters(self,Â index) Get the force field parameters for a torsion-torsion term. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setTorsionTorsionGrid(self,Â index,Â grid) Set the torsion-torsion grid at the specified index setTorsionTorsionParameters(self,Â index,Â â¦) Set the force field parameters for a torsion-torsion term. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumTorsionTorsions(self) → intÂ¶ Get the number of torsion-torsion terms in the potential function getNumTorsionTorsionGrids(self) → intÂ¶ Get the number of torsion-torsion grids addTorsionTorsion(self, particle1, particle2, particle3, particle4, particle5, chiralCheckAtomIndex, gridIndex) → intÂ¶ Add a torsion-torsion term to the force field. Parameters particle1 (int) â the index of the first particle connected by the torsion-torsion particle2 (int) â the index of the second particle connected by the torsion-torsion particle3 (int) â the index of the third particle connected by the torsion-torsion particle4 (int) â the index of the fourth particle connected by the torsion-torsion particle5 (int) â the index of the fifth particle connected by the torsion-torsion chiralCheckAtomIndex (int) â the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check gridIndex (int) â the index to the grid to be used Returns the index of the torsion-torsion that was added Return type int getTorsionTorsionParameters(self, index)Â¶ Get the force field parameters for a torsion-torsion term. Parameters index (int) â the index of the torsion-torsion for which to get parameters Returns particle1 (int) â the index of the first particle connected by the torsion-torsion particle2 (int) â the index of the second particle connected by the torsion-torsion particle3 (int) â the index of the third particle connected by the torsion-torsion particle4 (int) â the index of the fourth particle connected by the torsion-torsion particle5 (int) â the index of the fifth particle connected by the torsion-torsion chiralCheckAtomIndex (int) â the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check gridIndex (int) â the grid index setTorsionTorsionParameters(self, index, particle1, particle2, particle3, particle4, particle5, chiralCheckAtomIndex, gridIndex)Â¶ Set the force field parameters for a torsion-torsion term. Parameters index (int) â the index of the torsion-torsion for which to set parameters particle1 (int) â the index of the first particle connected by the torsion-torsion particle2 (int) â the index of the second particle connected by the torsion-torsion particle3 (int) â the index of the third particle connected by the torsion-torsion particle4 (int) â the index of the fourth particle connected by the torsion-torsion particle5 (int) â the index of the fifth particle connected by the torsion-torsion chiralCheckAtomIndex (int) â the index of the particle connected to particle3, but not particle2 or particle4 to be used in chirality check gridIndex (int) â the grid index getTorsionTorsionGrid(self, index) → vectordddÂ¶ Get the torsion-torsion grid at the specified index Parameters index (int) â the grid index Returns grid return grid reference Return type vector< std::vector< std::vector< double > > > setTorsionTorsionGrid(self, index, grid)Â¶ Set the torsion-torsion grid at the specified index Parameters index (int) â the index of the torsion-torsion for which to get parameters grid (vector< std::vector< std::vector< double > > >) â either 3 or 6 values may be specified per grid point. If the derivatives are omitted, they are calculated automatically by fitting a 2D spline to the energies. grid[x][y][0] = x value grid[x][y][1] = y value grid[x][y][2] = energy grid[x][y][3] = dEdx value grid[x][y][4] = dEdy value grid[x][y][5] = dEd(xy) value setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.AmoebaVdwForce.html:
AmoebaVdwForceÂ¶ class openmm.openmm.AmoebaVdwForce(*args)Â¶ This class models van der Waals forces in the AMOEBA force field. It can use either buffered 14-7 potential or a Lennard-Jones 12-6 potential. This class can operate in two different modes. In one mode, force field parameters are defined for each particle. When two particles interact, a combining rule is used to calculate the interaction parameters based on the parameters for the two particles. To use the class in this mode, call the version of addParticle() that takes sigma and epsilon values. It should be called once for each particle in the System. In the other mode, each particle has a type index, and parameters are specified for each type rather than each individual particle. By default this mode also uses a combining rule, but you can override it by defining alternate parameters to use for specific pairs of particle types. To use the class in this mode, call the version of addParticle() that takes a type index. It should be called once for each particle in the System. You also must call addParticleType() once for each type. If you wish to override the combining for particular pairs of types, do so by calling addTypePair(). A unique feature of this class is that the interaction site for a particle does not need to be exactly at the particleâs location. Instead, it can be placed a fraction of the distance from that particle to another one. This is typically done for hydrogens to place the interaction site slightly closer to the parent atom. The fraction is known as the âreduction factorâ, since it reduces the distance from the parent atom to the interaction site. Support is also available for softcore interactions based on setting a per particle alchemical flag and setting the AmoebaVdwForce to use an âAlchemicalMethodâ either Decouple or Annihilate. For Decouple, two alchemical atoms interact normally. For Annihilate, all interactions involving an alchemical atom are influenced. The softcore state is specified by setting a single Context parameter âAmoebaVdwLambdaâ between 0.0 and 1.0. The softcore functional form can be modified by setting the softcore power (default of 5) and the softcore alpha (default of 0,7). For more information on the softcore functional form see Eq. 2 from: Jiao, D.; Golubkov, P. A.; Darden, T. A.; Ren, P., Calculation of protein-ligand binding free energy by using a polarizable potential. Proc. Natl. Acad. Sci. U.S.A. 2008, 105 (17), 6290-6295. . __init__(self) → AmoebaVdwForceÂ¶ __init__(self, other) → AmoebaVdwForce Create an Amoeba VdwForce. Methods Lambda() This is the name of the parameter which stores the current Amoeba vdW lambda value. __init__(->Â AmoebaVdwForce) Create an Amoeba VdwForce. addParticle(->Â int) Add the force field parameters for a vdw particle. addParticleType(self,Â sigma,Â epsilon) Add a particle type. addTypePair(self,Â type1,Â type2,Â sigma,Â epsilon) Add a type pair. getAlchemicalMethod(self) Get the method used for alchemical interactions. getCutoff(self) Get the cutoff distance. getCutoffDistance(self) Get the cutoff distance (in nm) being used for nonbonded interactions. getEpsilonCombiningRule(self) Get epsilon combining rule getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long range nonbonded interactions. getNumParticleTypes(self) Get the number of particle types. getNumParticles(self) Get the number of particles getNumTypePairs(self) Get the number of type pairs. getParticleExclusions(self,Â particleIndex) Get exclusions for specified particle getParticleParameters(self,Â particleIndex) Get the force field parameters for a vdw particle. getParticleTypeParameters(self,Â typeIndex) Get the force field parameters for a particle type. getPotentialFunction(self) Get the potential function to use. getSigmaCombiningRule(self) Get sigma combining rule getSoftcoreAlpha(self) Get the softcore alpha value. getSoftcorePower(self) Get the softcore power on lambda. getTypePairParameters(self,Â pairIndex) Get the force field parameters for a type pair. getUseDispersionCorrection(self) Get whether to add a contribution to the energy that approximately represents the effect of VdW interactions beyond the cutoff distance. getUseParticleTypes(self) Get whether parameters were specified by particle or by particle type. setAlchemicalMethod(self,Â method) Set the method used for handling long range nonbonded interactions. setCutoff(self,Â cutoff) Set the cutoff distance. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for nonbonded interactions. setEpsilonCombiningRule(self,Â â¦) Set epsilon combining rule setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long range nonbonded interactions. setParticleExclusions(self,Â particleIndex,Â â¦) Set exclusions for specified particle setParticleParameters(self,Â particleIndex,Â â¦) Set the force field parameters for a vdw particle. setParticleTypeParameters(self,Â typeIndex,Â â¦) Set the force field parameters for a particle type. setPotentialFunction(self,Â potential) Set the potential function to use. setSigmaCombiningRule(self,Â sigmaCombiningRule) Set sigma combining rule setSoftcoreAlpha(self,Â alpha) Set the softcore alpha value (default = 0.7). setSoftcorePower(self,Â n) Set the softcore power on lambda (default = 5). setTypePairParameters(self,Â pairIndex,Â â¦) Set the force field parameters for a type pair. setUseDispersionCorrection(self,Â useCorrection) Set whether to add a contribution to the energy that approximately represents the effect of VdW interactions beyond the cutoff distance. updateParametersInContext(self,Â context) Update the per-particle parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes Annihilate Buffered147 CutoffPeriodic Decouple LennardJones NoCutoff thisown The membership flag property thisownÂ¶ The membership flag static Lambda() → std::string const &Â¶ This is the name of the parameter which stores the current Amoeba vdW lambda value. getNumParticles(self) → intÂ¶ Get the number of particles getNumParticleTypes(self) → intÂ¶ Get the number of particle types. getNumTypePairs(self) → intÂ¶ Get the number of type pairs. setParticleParameters(self, particleIndex, parentIndex, sigma, epsilon, reductionFactor, isAlchemical=False, typeIndex=- 1)Â¶ Set the force field parameters for a vdw particle. Parameters particleIndex (int) â the particle index parentIndex (int) â the index of the parent particle sigma (double) â vdw sigma epsilon (double) â vdw epsilon reductionFactor (double) â the fraction of the distance along the line from the parent particle to this particle at which the interaction site should be placed isAlchemical (bool) â if true, this vdW particle is undergoing an alchemical change. typeIndex (int) â the index of the particle type for this particle getParticleParameters(self, particleIndex)Â¶ Get the force field parameters for a vdw particle. Parameters particleIndex (int) â the particle index Returns parentIndex (int) â the index of the parent particle sigma (double) â vdw sigma epsilon (double) â vdw epsilon reductionFactor (double) â the fraction of the distance along the line from the parent particle to this particle at which the interaction site should be placed isAlchemical (bool) â if true, this vdW particle is undergoing an alchemical change. typeIndex (int) â the index of the particle type for this particle addParticle(self, parentIndex, sigma, epsilon, reductionFactor, isAlchemical=False) → intÂ¶ addParticle(self, parentIndex, typeIndex, reductionFactor, isAlchemical=False) → int Add the force field parameters for a vdw particle. This version is used when parameters are defined by particle type. Parameters parentIndex (int) â the index of the parent particle typeIndex (int) â the index of the particle type for this particle reductionFactor (double) â the fraction of the distance along the line from the parent particle to this particle at which the interaction site should be placed isAlchemical (bool) â if true, this vdW particle is undergoing an alchemical change. Returns index of added particle Return type int addParticleType(self, sigma, epsilon) → intÂ¶ Add a particle type. Parameters sigma (double) â the sigma value for particles of this type epsilon (double) â the epsilon value for particles of this type Returns the index of the particle type that was just added. Return type int getParticleTypeParameters(self, typeIndex)Â¶ Get the force field parameters for a particle type. Parameters typeIndex (int) â the index of the particle type Returns sigma (double) â the sigma value for particles of this type epsilon (double) â the epsilon value for particles of this type setParticleTypeParameters(self, typeIndex, sigma, epsilon)Â¶ Set the force field parameters for a particle type. Parameters typeIndex (int) â the index of the particle type sigma (double) â the sigma value for particles of this type epsilon (double) â the epsilon value for particles of this type addTypePair(self, type1, type2, sigma, epsilon) → intÂ¶ Add a type pair. This overrides the standard combining rule for interactions between particles of two particular types. Parameters type1 (int) â the index of the first particle type type2 (int) â the index of the second particle type sigma (double) â the sigma value for interactions between particles of these two types epsilon (double) â the epsilon value for interactions between particles of these two types Returns the index of the type pair that was just added. Return type int getTypePairParameters(self, pairIndex)Â¶ Get the force field parameters for a type pair. This overrides the standard combining rule for interactions between particles of two particular types. Parameters pairIndex (int) â the index of the type pair Returns type1 (int) â the index of the first particle type type2 (int) â the index of the second particle type sigma (double) â the sigma value for interactions between particles of these two types epsilon (double) â the epsilon value for interactions between particles of these two types setTypePairParameters(self, pairIndex, type1, type2, sigma, epsilon)Â¶ Set the force field parameters for a type pair. This overrides the standard combining rule for interactions between particles of two particular types. Parameters pairIndex (int) â the index of the type pair type1 (int) â the index of the first particle type type2 (int) â the index of the second particle type sigma (double) â the sigma value for interactions between particles of these two types epsilon (double) â the epsilon value for interactions between particles of these two types setSigmaCombiningRule(self, sigmaCombiningRule)Â¶ Set sigma combining rule Parameters sigmaCombiningRule (string) â sigma combining rule: âARITHMETICâ, âGEOMETRICâ. âCUBIC-MEANâ getSigmaCombiningRule(self) → std::string const &Â¶ Get sigma combining rule Returns sigmaCombiningRule sigma combining rule: âARITHMETICâ, âGEOMETRICâ. âCUBIC-MEANâ Return type string setEpsilonCombiningRule(self, epsilonCombiningRule)Â¶ Set epsilon combining rule Parameters epsilonCombiningRule (string) â epsilon combining rule: âARITHMETICâ, âGEOMETRICâ. âHARMONICâ, âW-Hâ, âHHGâ getEpsilonCombiningRule(self) → std::string const &Â¶ Get epsilon combining rule Returns epsilonCombiningRule epsilon combining rule: âARITHMETICâ, âGEOMETRICâ. âHARMONICâ, âW-Hâ, âHHGâ Return type string getUseDispersionCorrection(self) → boolÂ¶ Get whether to add a contribution to the energy that approximately represents the effect of VdW interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results. setUseDispersionCorrection(self, useCorrection)Â¶ Set whether to add a contribution to the energy that approximately represents the effect of VdW interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results. getUseParticleTypes(self) → boolÂ¶ Get whether parameters were specified by particle or by particle type. setParticleExclusions(self, particleIndex, exclusions)Â¶ Set exclusions for specified particle Parameters particleIndex (int) â particle index exclusions (vector< int >) â vector of exclusions getParticleExclusions(self, particleIndex)Â¶ Get exclusions for specified particle Parameters particleIndex (int) â particle index Returns exclusions â vector of exclusions Return type vector< int > getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm setCutoff(self, cutoff)Â¶ Set the cutoff distance. Deprecated This method exists only for backward compatibility. Use setCutoffDistance() instead. getCutoff(self) → doubleÂ¶ Get the cutoff distance. Deprecated This method exists only for backward compatibility. Use getCutoffDistance() instead. getNonbondedMethod(self) → OpenMM::AmoebaVdwForce::NonbondedMethodÂ¶ Get the method used for handling long range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long range nonbonded interactions. getPotentialFunction(self) → OpenMM::AmoebaVdwForce::PotentialFunctionÂ¶ Get the potential function to use. setPotentialFunction(self, potential)Â¶ Set the potential function to use. setSoftcorePower(self, n)Â¶ Set the softcore power on lambda (default = 5). getSoftcorePower(self) → intÂ¶ Get the softcore power on lambda. setSoftcoreAlpha(self, alpha)Â¶ Set the softcore alpha value (default = 0.7). getSoftcoreAlpha(self) → doubleÂ¶ Get the softcore alpha value. getAlchemicalMethod(self) → OpenMM::AmoebaVdwForce::AlchemicalMethodÂ¶ Get the method used for alchemical interactions. setAlchemicalMethod(self, method)Â¶ Set the method used for handling long range nonbonded interactions. updateParametersInContext(self, context)Â¶ Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-particle parameters. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if nonbondedMethod uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.AmoebaWcaDispersionForce.html:
AmoebaWcaDispersionForceÂ¶ class openmm.openmm.AmoebaWcaDispersionForce(*args)Â¶ This class implements a nonbonded interaction between pairs of particles typically used along with AmoebaGeneralizedKirkwoodForce as part of an implicit solvent model. To use it, create an AmoebaWcaDispersionForce object then call addParticle() once for each particle. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). __init__(self) → AmoebaWcaDispersionForceÂ¶ __init__(self, other) → AmoebaWcaDispersionForce Create an AmoebaWcaDispersionForce. Methods __init__(->Â AmoebaWcaDispersionForce) Create an AmoebaWcaDispersionForce. addParticle(self,Â radius,Â epsilon) Set the force field parameters for a WCA dispersion particle. getAwater(self) getDispoff(self) getEpsh(self) getEpso(self) getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNumParticles(self) Get the number of particles getParticleParameters(self,Â particleIndex) Get the force field parameters for a WCA dispersion particle. getRminh(self) getRmino(self) getShctd(self) getSlevy(self) setAwater(self,Â inputValue) setDispoff(self,Â inputValue) setEpsh(self,Â inputValue) setEpso(self,Â inputValue) setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setParticleParameters(self,Â particleIndex,Â â¦) Set the force field parameters for a WCA dispersion particle. setRminh(self,Â inputValue) setRmino(self,Â inputValue) setShctd(self,Â inputValue) setSlevy(self,Â inputValue) updateParametersInContext(self,Â context) Update the per-particle parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles setParticleParameters(self, particleIndex, radius, epsilon)Â¶ Set the force field parameters for a WCA dispersion particle. Parameters particleIndex (int) â the particle index radius (double) â radius epsilon (double) â epsilon getParticleParameters(self, particleIndex)Â¶ Get the force field parameters for a WCA dispersion particle. Parameters particleIndex (int) â the particle index Returns radius (double) â radius epsilon (double) â epsilon addParticle(self, radius, epsilon) → intÂ¶ Set the force field parameters for a WCA dispersion particle. Parameters radius (double) â radius epsilon (double) â epsilon Returns index of added particle Return type int updateParametersInContext(self, context)Â¶ Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-particle parameters. All other aspects of the Force are unaffected and can only be changed by reinitializing the Context. getEpso(self) → doubleÂ¶ getEpsh(self) → doubleÂ¶ getRmino(self) → doubleÂ¶ getRminh(self) → doubleÂ¶ getAwater(self) → doubleÂ¶ getShctd(self) → doubleÂ¶ getDispoff(self) → doubleÂ¶ getSlevy(self) → doubleÂ¶ setEpso(self, inputValue)Â¶ setEpsh(self, inputValue)Â¶ setRmino(self, inputValue)Â¶ setRminh(self, inputValue)Â¶ setAwater(self, inputValue)Â¶ setShctd(self, inputValue)Â¶ setDispoff(self, inputValue)Â¶ setSlevy(self, inputValue)Â¶ usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if nonbondedMethod uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.AndersenThermostat.html:
AndersenThermostatÂ¶ class openmm.openmm.AndersenThermostat(*args)Â¶ This class uses the Andersen method to maintain constant temperature. __init__(self, defaultTemperature, defaultCollisionFrequency) → AndersenThermostatÂ¶ __init__(self, other) → AndersenThermostat Create an AndersenThermostat. Parameters defaultTemperature (double) â the default temperature of the heat bath (in Kelvin) defaultCollisionFrequency (double) â the default collision frequency (in 1/ps) Methods CollisionFrequency() This is the name of the parameter which store the current collision frequency (in 1/ps). Temperature() This is the name of the parameter which stores the current temperature of the heat bath (in Kelvin). __init__(->Â AndersenThermostat) Create an AndersenThermostat. getDefaultCollisionFrequency(self) Get the default collision frequency (in 1/ps). getDefaultTemperature(self) Get the default temperature of the heat bath (in Kelvin). getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getRandomNumberSeed(self) Get the random number seed. setDefaultCollisionFrequency(self,Â frequency) Set the default collision frequency. setDefaultTemperature(self,Â temperature) Set the default temperature of the heat bath. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setRandomNumberSeed(self,Â seed) Set the random number seed. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag static Temperature() → std::string const &Â¶ This is the name of the parameter which stores the current temperature of the heat bath (in Kelvin). static CollisionFrequency() → std::string const &Â¶ This is the name of the parameter which store the current collision frequency (in 1/ps). getDefaultTemperature(self) → doubleÂ¶ Get the default temperature of the heat bath (in Kelvin). Returns the default temperature of the heat bath, measured in Kelvin. Return type double setDefaultTemperature(self, temperature)Â¶ Set the default temperature of the heat bath. This will affect any new Contexts you create, but not ones that already exist. Parameters temperature (double) â the default temperature of the heat bath (in Kelvin) getDefaultCollisionFrequency(self) → doubleÂ¶ Get the default collision frequency (in 1/ps). Returns the default collision frequency, measured in 1/ps. Return type double setDefaultCollisionFrequency(self, frequency)Â¶ Set the default collision frequency. This will affect any new Contexts you create, but not ones that already exist. Parameters frequency (double) â the default collision frequency (in 1/ps) getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of collisions will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.ATMForce.html:
ATMForceÂ¶ class openmm.openmm.ATMForce(*args)Â¶ The ATMForce class implements the Alchemical Transfer Method (ATM) for OpenMM. ATM is used to compute the binding free energies of molecular complexes and of other equilibrium processes. ATM and its implementation are described in the open access article: Solmaz Azimi, Sheenam Khuttan, Joe Z. Wu, Rajat K. Pal, and Emilio Gallicchio. Relative Binding Free Energy Calculations for Ligands with Diverse Scaffolds with the Alchemical Transfer Method. J. Chem. Inf. Model. 62, 309 (2022) Refer to the publication above for a detailed description of the ATM method and the parameters used in this API and please cite it to support our work if you use this software in your research. The ATMForce implements an arbitrary potential energy function that depends on the potential energies (u0 and u1) of the system before and after a set of atoms are displaced by a specified amount. For example, you might displace a molecule from the solvent bulk to a receptor binding site to simulate a binding process. The potential energy function typically also depends on one or more parameters that are dialed to implement alchemical transformations. To use this class, create an ATMForce object, passing an algebraic expression to the constructor that defines the potential energy. This expression can be any combination of the variables u0 and u1. Then call addGlobalParameter() to define the parameters on which the potential energy expression depends. The values of global parameters may be modified during a simulation by calling Context::setParameter(). Next, call addForce() to add Force objects that define the terms of the potential energy function that change upon displacement. Finally, call addParticle() to specify the displacement applied to each particle. Displacements can be changed by calling setParticleParameters(). As any per-particle parameters, changes in displacements take effect only after calling updateParametersInContext(). As an example, the following code creates an ATMForce based on the change in energy of two particles when the second particle is displaced by 1 nm in the x direction. The energy change is dialed using an alchemical parameter Lambda, which in this case is set to 1/2: ATMForce *atmforce = new ATMForce("u0 + Lambda*(u1 - u0)"); atm->addGlobalParameter("Lambda", 0.5); atm->addParticle(Vec3(0, 0, 0)); atm->addParticle(Vec3(1, 0, 0)); CustomBondForce* force = new CustomBondForce("0.5*r^2"); atm->addForce(force); Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. If instead of the energy expression the ATMForce constructor specifies the values of a series of parameters, the default energy expression is used: select(step(Direction), u0, u1) + ((Lambda2-Lambda1)/Alpha)*log(1+exp(-Alpha*(usc-Uh))) + Lambda2*usc + W0; usc = select(step(u-Ubcore), (Umax-Ubcore)*fsc+Ubcore, u), u); fsc = (z^Acore-1)/(z^Acore+1); z = 1 + 2*(y/Acore) + 2*(y/Acore)^2; y = (u-Ubcore)/(Umax-Ubcore); u = select(step(Direction), 1, -1)*(u1-u0) which is the same as the soft-core softplus alchemical potential energy function in the Azimi et al. paper above. The ATMForce is then added to the System as any other Force system.addForce(atmforce); after which it will be used for energy/force evaluations for molecular dynamics and energy optimization. You can call getPerturbationEnergy() to query the values of u0 and u1, which are needed for computing free energies. In most cases, particles are only displaced in one of the two states evaluated by this force. It computes the change in energy between the current particle coordinates (as stored in the Context) and the displaced coordinates. In some cases, it is useful to apply displacements to both states. You can do this by providing two displacement vectors to addParticle(): atm->addParticle(Vec3(1, 0, 0), Vec3(-1, 0, 0)); In this case, u1 will be computed after displacing the particle in the positive x direction, and u0 will be computed after displacing it in the negative x direction. This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. __init__(self, energy) → ATMForceÂ¶ __init__(self, lambda1, lambda2, alpha, uh, w0, umax, ubcore, acore, direction) → ATMForce __init__(self, other) → ATMForce Create an ATMForce object with the default softplus energy expression. The values passed to this constructor are the default values of the global parameters for newly created Contexts. Their values can be changed by calling setParameter() on the Context using the parameter names defined by the Lambda1(), Lambda2(), etc. methods below. Parameters lambda1 (double) â the default value of the Lambda1 parameter (dimensionless). This should be a number between 0 and 1. lambda2 (double) â the default value of the Lambda2 parameter (dimensionless). This should be a number between 0 and 1. alpha (double) â the default value of the Alpha parameter (kJ/mol)^-1 uh (double) â the default value of the Uh parameter (kJ/mol) w0 (double) â the default value of the W0 parameter (kJ/mol) umax (double) â the default value of the Umax parameter (kJ/mol) ubcore (double) â the default value of the Ubcore parameter (kJ/mol) acore (double) â the default value of the Acore parameter dimensionless) direction (double) â the default value of the Direction parameter (dimensionless). This should be either 1 for the forward transfer, or -1 for the backward transfer. Methods Acore() Returns the name of the global parameter corresponding to acore. Alpha() Returns the name of the global parameter corresponding to alpha. Direction() Returns the name of the global parameter corresponding to direction. Lambda1() Returns the name of the global parameter corresponding to lambda1. Lambda2() Returns the name of the global parameter corresponding to lambda2. Ubcore() Returns the name of the global parameter corresponding to ubcore. Uh() Returns the name of the global parameter corresponding to uh. Umax() Returns the name of the global parameter corresponding to umax. W0() Returns the name of the global parameter corresponding to w0. __init__(->Â ATMForce Â ->Â ATMForce) Create an ATMForce object with the default softplus energy expression. addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addForce(self,Â force) Add a Force whose energy will be computed by the ATMForce. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addParticle(self,Â displacement1[,Â displacement0]) Add a particle to the force. getEnergyFunction(self) Get the algebraic expression that gives the energy of the system getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getForce(self,Â index) return the force from index getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumForces(self) Get the number of Forces included in the ATMForce. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumParticles(self) Get the number of particles managed by ATMForce. getParticleParameters(self,Â index) Get the parameters for a particle getPerturbationEnergy(self,Â context) Returns the current perturbation energy. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the energy of the system setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setParticleParameters(self,Â index,Â displacement1) Set the parameters for a particle updateParametersInContext(self,Â context) Update the per-particle parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag static Lambda1() → std::string const &Â¶ Returns the name of the global parameter corresponding to lambda1. The value assigned to this parameter should be a number between 0 and 1. static Lambda2() → std::string const &Â¶ Returns the name of the global parameter corresponding to lambda2. The value assigned to this parameter should be a number between 0 and 1. static Alpha() → std::string const &Â¶ Returns the name of the global parameter corresponding to alpha. The value assigned to this parameter should be in units of (kJ/mol)^-1. static Uh() → std::string const &Â¶ Returns the name of the global parameter corresponding to uh. The value assigned to this parameter should be in units of (kJ/mol). static W0() → std::string const &Â¶ Returns the name of the global parameter corresponding to w0. The value assigned to this parameter should be in units of (kJ/mol). static Umax() → std::string const &Â¶ Returns the name of the global parameter corresponding to umax. The value assigned to this parameter should be in units of (kJ/mol). static Ubcore() → std::string const &Â¶ Returns the name of the global parameter corresponding to ubcore. The value assigned to this parameter should be in units of (kJ/mol). static Acore() → std::string const &Â¶ Returns the name of the global parameter corresponding to acore. static Direction() → std::string const &Â¶ Returns the name of the global parameter corresponding to direction. The value assigned to this parameter should be either 1 for the forward transfer, or -1 for the backward transfer. getNumParticles(self) → intÂ¶ Get the number of particles managed by ATMForce. This should be the same number of particles as the System getNumForces(self) → intÂ¶ Get the number of Forces included in the ATMForce. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the energy of the system setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the energy of the system addForce(self, force) → intÂ¶ Add a Force whose energy will be computed by the ATMForce. Parameters force (Force *) â the Force to the be added, which should have been created on the heap with the ânewâ operator. The ATMForce takes over ownership of it, and deletes the Force when the ATMForce itself is deleted. Returns The index within ATMForce of the force that was added Return type int getForce(self, index) → ForceÂ¶ return the force from index addParticle(self, displacement1, displacement0=Vec3()) → intÂ¶ Add a particle to the force. All of the particles in the System must be added to the ATMForce in the same order as they appear in the System. Parameters displacement1 (Vec3) â the displacement of the particle for the target state in nm displacement0 (Vec3) â the displacement of the particle for the initial state in nm Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the parameters for a particle Parameters index (int) â the index in the force for the particle for which to get parameters displacement1 (Vec3) â the displacement of the particle for the target state in nm displacement0 (Vec3) â the displacement of the particle for the initial state in nm setParticleParameters(self, index, displacement1, displacement0=Vec3())Â¶ Set the parameters for a particle Parameters index (int) â the index in the force of the particle for which to set parameters displacement1 (Vec3) â the displacement of the particle for the target state in nm displacement0 (Vec3) â the displacement of the particle for the initial state in nm addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string updateParametersInContext(self, context)Â¶ Update the per-particle parameters in a Context to match those stored in this Force object. This method should be called after updating parameters with setParticleParameters() to copy them over to the Context. The only information this method updates is the values of per-particle parameters. The number of particles cannot be changed. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. getPerturbationEnergy(self, context)Â¶ Returns the current perturbation energy. Parameters context (Context) â the Context for which to return the energy u1 (double) â on exit, the energy of the displaced state u0 (double) â on exit, the energy of the non-displaced state energy (double) â on exit, the value of this forceâs energy function getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.BrownianIntegrator.html:
BrownianIntegratorÂ¶ class openmm.openmm.BrownianIntegrator(*args)Â¶ This is an Integrator which simulates a System using Brownian dynamics. __init__(self, temperature, frictionCoeff, stepSize) → BrownianIntegratorÂ¶ __init__(self, other) → BrownianIntegrator Create a BrownianIntegrator. Parameters temperature (double) â the temperature of the heat bath (in Kelvin) frictionCoeff (double) â the friction coefficient which couples the system to the heat bath, measured in 1/ps stepSize (double) â the step size with which to integrate the system (in picoseconds) Methods __init__(->Â BrownianIntegrator) Create a BrownianIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getFriction(self) Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). getIntegrationForceGroups(self) Get which force groups to use for integration. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTemperature(self) Get the temperature of the heat bath (in Kelvin). setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setFriction(self,Â coeff) Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). setIntegrationForceGroups(groups) Set which force groups to use for integration. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. setTemperature(self,Â temp) Set the temperature of the heat bath (in Kelvin). step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag getTemperature(self) → doubleÂ¶ Get the temperature of the heat bath (in Kelvin). Returns the temperature of the heat bath (in Kelvin). Return type double setTemperature(self, temp)Â¶ Set the temperature of the heat bath (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin. getFriction(self) → doubleÂ¶ Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Returns the friction coefficient, measured in 1/ps Return type double setFriction(self, coeff)Â¶ Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Parameters coeff (double) â the friction coefficient, measured in 1/ps getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CMAPTorsionForce.html:
CMAPTorsionForceÂ¶ class openmm.openmm.CMAPTorsionForce(*args)Â¶ This class implements an interaction between pairs of dihedral angles. The interaction energy is defined by an âenergy correction mapâ (CMAP), which is simply a set of tabulated energy values on a regular grid of (phi, psi) angles. Natural cubic spline interpolation is used to compute forces and energies at arbitrary values of the two angles. To use this class, first create one or more energy correction maps by calling addMap(). For each one, you provide an array of energies at uniformly spaced values of the two angles. Next, add interactions by calling addTorsion(). For each one, you specify the sequence of particles used to calculate each of the two dihedral angles, and the index of the map used to calculate their interaction energy. __init__(self) → CMAPTorsionForceÂ¶ __init__(self, other) → CMAPTorsionForce Create a CMAPTorsionForce. Methods __init__(->Â CMAPTorsionForce) Create a CMAPTorsionForce. addMap(self,Â size,Â energy) Create a new map that can be used for torsion pairs. addTorsion(self,Â map,Â a1,Â a2,Â a3,Â a4,Â b1,Â â¦) Add a CMAP torsion term to the force field. getForceGroup(self) Get the force group this Force belongs to. getMapParameters(self,Â index) Get the energy values of a map. getName(self) Get the name of this Force. getNumMaps(self) Get the number of maps that have been defined. getNumTorsions(self) Get the number of CMAP torsion terms in the potential function getTorsionParameters(self,Â index) Get the force field parameters for a CMAP torsion term. setForceGroup(self,Â group) Set the force group this Force belongs to. setMapParameters(self,Â index,Â size,Â energy) Set the energy values of a map. setName(self,Â name) Set the name of this Force. setTorsionParameters(self,Â index,Â map,Â a1,Â â¦) Set the force field parameters for a CMAP torsion term. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the map and torsion parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumMaps(self) → intÂ¶ Get the number of maps that have been defined. getNumTorsions(self) → intÂ¶ Get the number of CMAP torsion terms in the potential function addMap(self, size, energy) → intÂ¶ Create a new map that can be used for torsion pairs. Parameters size (int) â the size of the map along each dimension energy (vector< double >) â the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size. Returns the index of the map that was added Return type int getMapParameters(self, index)Â¶ Get the energy values of a map. Parameters index (int) â the index of the map for which to get energy values Returns size (int) â the size of the map along each dimension energy (vector< double >) â the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size. setMapParameters(self, index, size, energy)Â¶ Set the energy values of a map. Parameters index (int) â the index of the map for which to set energy values size (int) â the size of the map along each dimension energy (vector< double >) â the energy values for the map. This must be of length size*size. The element energy[i+size*j] contains the energy when the first torsion angle equals i*2*PI/size and the second torsion angle equals j*2*PI/size. addTorsion(self, map, a1, a2, a3, a4, b1, b2, b3, b4) → intÂ¶ Add a CMAP torsion term to the force field. Parameters map (int) â the index of the map to use for this term a1 (int) â the index of the first particle forming the first torsion a2 (int) â the index of the second particle forming the first torsion a3 (int) â the index of the third particle forming the first torsion a4 (int) â the index of the fourth particle forming the first torsion b1 (int) â the index of the first particle forming the second torsion b2 (int) â the index of the second particle forming the second torsion b3 (int) â the index of the third particle forming the second torsion b4 (int) â the index of the fourth particle forming the second torsion Returns the index of the torsion that was added Return type int getTorsionParameters(self, index)Â¶ Get the force field parameters for a CMAP torsion term. Parameters index (int) â the index of the torsion for which to get parameters Returns map (int) â the index of the map to use for this term a1 (int) â the index of the first particle forming the first torsion a2 (int) â the index of the second particle forming the first torsion a3 (int) â the index of the third particle forming the first torsion a4 (int) â the index of the fourth particle forming the first torsion b1 (int) â the index of the first particle forming the second torsion b2 (int) â the index of the second particle forming the second torsion b3 (int) â the index of the third particle forming the second torsion b4 (int) â the index of the fourth particle forming the second torsion setTorsionParameters(self, index, map, a1, a2, a3, a4, b1, b2, b3, b4)Â¶ Set the force field parameters for a CMAP torsion term. Parameters index (int) â the index of the torsion for which to set parameters map (int) â the index of the map to use for this term a1 (int) â the index of the first particle forming the first torsion a2 (int) â the index of the second particle forming the first torsion a3 (int) â the index of the third particle forming the first torsion a4 (int) â the index of the fourth particle forming the first torsion b1 (int) â the index of the first particle forming the second torsion b2 (int) â the index of the second particle forming the second torsion b3 (int) â the index of the third particle forming the second torsion b4 (int) â the index of the fourth particle forming the second torsion updateParametersInContext(self, context)Â¶ Update the map and torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setMapParameters() and setTorsionParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information that can be updated with this method is the energy values for a map, and the map index for a torsion. The size of a map and the set of particles involved in a torsion cannot be changed. Also, new bonds and torsions cannot be added. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CMMotionRemover.html:
CMMotionRemoverÂ¶ class openmm.openmm.CMMotionRemover(*args)Â¶ This class prevents the center of mass of a System from drifting. At each time step, it calculates the center of mass momentum, then adjusts the individual particle velocities to make it zero. __init__(self, frequency=1) → CMMotionRemoverÂ¶ __init__(self, other) → CMMotionRemover Create a CMMotionRemover. Methods __init__(->Â CMMotionRemover) Create a CMMotionRemover. getForceGroup(self) Get the force group this Force belongs to. getFrequency(self) Get the frequency (in time steps) at which center of mass motion should be removed getName(self) Get the name of this Force. setForceGroup(self,Â group) Set the force group this Force belongs to. setFrequency(self,Â freq) Set the frequency (in time steps) at which center of mass motion should be removed setName(self,Â name) Set the name of this Force. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getFrequency(self) → intÂ¶ Get the frequency (in time steps) at which center of mass motion should be removed setFrequency(self, freq)Â¶ Set the frequency (in time steps) at which center of mass motion should be removed usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CompoundIntegrator.html:
CompoundIntegratorÂ¶ class openmm.openmm.CompoundIntegrator(*args)Â¶ This class allows you to use multiple integration algorithms within a single simulation, switching back and forth between them. To use it, create whatever other Integrators you need, then add all of them to a CustomIntegrator: CompoundIntegrator compoundIntegrator; compoundIntegrator.addIntegrator(new VerletIntegrator(0.001)); compoundIntegrator.addIntegrator(new LangevinIntegrator(300.0, 1.0, 0.001)); Next create a Context, specifying the CompoundIntegrator as the Integrator to use for the Context: Context context(system, compoundIntegrator); Finally, call setCurrentIntegrator() to set which Integrator is active. That one will be used for all calls to step() until the next time you change it. compoundIntegrator.setCurrentIntegrator(0); compoundIntegrator.step(1000); // Take 1000 steps of Verlet dynamics compoundIntegrator.setCurrentIntegrator(1); compoundIntegrator.step(1000); // Take 1000 steps of Langevin dynamics When switching between integrators, it is important to make sure they are compatible with each other, and that they will interpret the positions and velocities in the same way. Remember that leapfrog style integrators assume the positions and velocities are offset from each other by half a time step. When switching between a leapfrog and non-leapfrog integrator, you must first adjust the velocities to avoid introducing error. This is also true when switching between two leapfrog integrators that use different step sizes, since they will interpret the velocities as corresponding to different times. __init__(self) → CompoundIntegratorÂ¶ __init__(self, other) → CompoundIntegrator Create a CompoundIntegrator. Methods __init__(->Â CompoundIntegrator) Create a CompoundIntegrator. addIntegrator(self,Â integrator) Add an Integrator to this CompoundIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getCurrentIntegrator(self) Get the index of the current Integrator. getIntegrationForceGroups(self) Get which force groups to use for integration. getIntegrator(->Â Integrator) Get a const reference to one of the Integrators that have been added to this CompoundIntegrator. getNumIntegrators(self) Get the number of Integrators that have been added to this CompoundIntegrator. getStepSize(self) Get the size of each time step, in picoseconds. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setCurrentIntegrator(self,Â index) Set the current Integrator. setIntegrationForceGroups(groups) Set which force groups to use for integration. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumIntegrators(self) → intÂ¶ Get the number of Integrators that have been added to this CompoundIntegrator. addIntegrator(self, integrator) → intÂ¶ Add an Integrator to this CompoundIntegrator. The Integrator object should have been created on the heap with the ânewâ operator. The CompoundIntegrator takes over ownership of it, and deletes it when the CompoundIntegrator itself is deleted. All Integrators must be added before the Context is created. Parameters integrator (Integrator *) â the Integrator to add Returns the index of the Integrator that was added Return type int getIntegrator(self, index) → IntegratorÂ¶ getIntegrator(self, index) → Integrator Get a const reference to one of the Integrators that have been added to this CompoundIntegrator. Parameters index (int) â the index of the Integrator to get getCurrentIntegrator(self) → intÂ¶ Get the index of the current Integrator. setCurrentIntegrator(self, index)Â¶ Set the current Integrator. Parameters index (int) â the index of the Integrator to use getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. This method calls getStepSize() on whichever Integrator has been set as current. Returns the step size, measured in ps Return type double setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. This method calls setStepSize() on whichever Integrator has been set as current. Parameters size (double) â the step size, measured in ps getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. This method calls getConstraintTolerance() on whichever Integrator has been set as current. setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. This method calls setConstraintTolerance() on whichever Integrator has been set as current. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. This method calls step() on whichever Integrator has been set as current. Parameters steps (int) â the number of time steps to take getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Context.html:
ContextÂ¶ class openmm.openmm.Context(*args)Â¶ A Context stores the complete state of a simulation. More specifically, it includes: The current time The position of each particle The velocity of each particle The values of configurable parameters defined by Force objects in the System You can retrieve a snapshot of the current state at any time by calling getState(). This allows you to record the state of the simulation at various points, either for analysis or for checkpointing. getState() can also be used to retrieve the current forces on each particle and the current energy of the System. __init__(self, system, integrator) → ContextÂ¶ __init__(self, system, integrator, platform) → Context __init__(self, system, integrator, platform, properties) → Context __init__(self, other) → Context Construct a new Context in which to run a simulation, explicitly specifying what Platform should be used to perform calculations and the values of platform-specific properties. Parameters system (System) â the System which will be simulated integrator (Integrator) â the Integrator which will be used to simulate the System platform (Platform) â the Platform to use for calculations properties (map< std::string, std::string >) â a set of values for platform-specific properties. Keys are the property names. Methods __init__(->Â Context Â ->Â Context Â ->Â Context) Construct a new Context in which to run a simulation, explicitly specifying what Platform should be used to perform calculations and the values of platform-specific properties. applyConstraints(self,Â tol) Update the positions of particles so that all distance constraints are satisfied. applyVelocityConstraints(self,Â tol) Update the velocities of particles so the net velocity of each constrained distance is zero. computeVirtualSites(self) Recompute the locations of all virtual sites. createCheckpoint(self) Create a checkpoint recording the current state of the Context. getIntegrator() getMolecules(self) Get a description of how the particles in the system are grouped into molecules. getParameter(self,Â name) Get the value of an adjustable parameter defined by a Force object in the System. getParameters(self) Get all adjustable parameters that have been defined by Force objects in the System, along with their current values. getPlatform(->Â Platform) Get the Platform being used for calculations. getState([getPositions,Â getVelocities,Â â¦]) Get a State object recording the current state information stored in this context. getStepCount(self) Get the current step count. getSystem(self) Get System being simulated in this context. getTime(self) Get the current time of the simulation (in picoseconds). loadCheckpoint(self,Â checkpoint) Load a checkpoint that was written by createCheckpoint(). reinitialize(self[,Â preserveState]) When a Context is created, it caches information about the System being simulated and the Force objects contained in it. setParameter(self,Â name,Â value) Set the value of an adjustable parameter defined by a Force object in the System. setPeriodicBoxVectors(self,Â a,Â b,Â c) Set the vectors defining the axes of the periodic box (measured in nm). setPositions(self,Â positions) Set the positions of all particles in the System (measured in nm). setState(self,Â state) Copy information from a State object into this Context. setStepCount(self,Â count) Set the current step count. setTime(self,Â time) Set the current time of the simulation (in picoseconds). setVelocities(self,Â velocities) Set the velocities of all particles in the System (measured in nm/picosecond). setVelocitiesToTemperature(self,Â temperature) Set the velocities of all particles in the System to random values chosen from a Boltzmann distribution at a given temperature. Attributes thisown The membership flag property thisownÂ¶ The membership flag getSystem(self) → SystemÂ¶ Get System being simulated in this context. getPlatform(self) → PlatformÂ¶ getPlatform(self) → Platform Get the Platform being used for calculations. setState(self, state)Â¶ Copy information from a State object into this Context. This restores the Context to approximately the same state it was in when the State was created. If the State does not include a piece of information (e.g. positions or velocities), that aspect of the Context is left unchanged. Even when all possible information is included in the State, the effect of calling this method is still less complete than loadCheckpoint(). For example, it does not restore the internal states of random number generators. On the other hand, it has the advantage of not being hardware specific. getTime(self) → doubleÂ¶ Get the current time of the simulation (in picoseconds). setTime(self, time)Â¶ Set the current time of the simulation (in picoseconds). getStepCount(self) → long longÂ¶ Get the current step count. setStepCount(self, count)Â¶ Set the current step count. setPositions(self, positions)Â¶ Set the positions of all particles in the System (measured in nm). This method simply sets the positions without checking to see whether they satisfy distance constraints. If you want constraints to be enforced, call applyConstraints() after setting the positions. Parameters positions (vector< Vec3 >) â a vector whose length equals the number of particles in the System. The iâth element contains the position of the iâth particle. setVelocities(self, velocities)Â¶ Set the velocities of all particles in the System (measured in nm/picosecond). Parameters velocities (vector< Vec3 >) â a vector whose length equals the number of particles in the System. The iâth element contains the velocity of the iâth particle. setVelocitiesToTemperature(self, temperature, randomSeed=osrngseed())Â¶ Set the velocities of all particles in the System to random values chosen from a Boltzmann distribution at a given temperature. Parameters temperature (double) â the temperature for which to select the velocities (measured in Kelvin) randomSeed (int) â the random number seed to use when selecting velocities getParameters(self) → mapstringdoubleÂ¶ Get all adjustable parameters that have been defined by Force objects in the System, along with their current values. getParameter(self, name) → doubleÂ¶ Get the value of an adjustable parameter defined by a Force object in the System. Parameters name (string) â the name of the parameter to get setParameter(self, name, value)Â¶ Set the value of an adjustable parameter defined by a Force object in the System. Parameters name (string) â the name of the parameter to set value (double) â the value of the parameter setPeriodicBoxVectors(self, a, b, c)Â¶ Set the vectors defining the axes of the periodic box (measured in nm). They will affect any Force that uses periodic boundary conditions. Triclinic boxes are supported, but the vectors must satisfy certain requirements. In particular, a must point in the x direction, b must point âmostlyâ in the y direction, and c must point âmostlyâ in the z direction. See the documentation for details. Parameters a (Vec3) â the vector defining the first edge of the periodic box b (Vec3) â the vector defining the second edge of the periodic box c (Vec3) â the vector defining the third edge of the periodic box applyConstraints(self, tol)Â¶ Update the positions of particles so that all distance constraints are satisfied. This also recomputes the locations of all virtual sites. Parameters tol (double) â the distance tolerance within which constraints must be satisfied. applyVelocityConstraints(self, tol)Â¶ Update the velocities of particles so the net velocity of each constrained distance is zero. Parameters tol (double) â the velocity tolerance within which constraints must be satisfied. computeVirtualSites(self)Â¶ Recompute the locations of all virtual sites. There is rarely a reason to call this, since virtual sites are also updated by applyConstraints(). This is only for the rare situations when you want to enforce virtual sites but not constraints. reinitialize(self, preserveState=False)Â¶ When a Context is created, it caches information about the System being simulated and the Force objects contained in it. This means that, if the System or Forces are then modified, the Context does not see the changes. Call reinitialize() to force the Context to rebuild its internal representation of the System and pick up any changes that have been made. This is an expensive operation, so you should try to avoid calling it too frequently. Most Force classes have an updateParametersInContext() method that provides a less expensive way of updating certain types of information. However, this method is the only way to make some types of changes, so it is sometimes necessary to call it. By default, reinitializing a Context causes all state information (positions, velocities, etc.) to be discarded. You can optionally tell it to try to preserve state information. It does this by internally creating a checkpoint, then reinitializing the Context, then loading the checkpoint. Be aware that if the System has changed in a way that prevents the checkpoint from being loaded (such as changing the number of particles), this will throw an exception and the state information will be lost. getMolecules(self) → vectoriiÂ¶ Get a description of how the particles in the system are grouped into molecules. Two particles are in the same molecule if they are connected by constraints or bonds, where every Force object can define bonds in whatever way are appropriate to that force. Each element lists the indices of all particles in a single molecule. Every particle is guaranteed to belong to exactly one molecule. getState(getPositions=False, getVelocities=False, getForces=False, getEnergy=False, getParameters=False, getParameterDerivatives=False, getIntegratorParameters=False, enforcePeriodicBox=False, groups=- 1)Â¶ Get a State object recording the current state information stored in this context. Parameters getPositions (bool=False) â whether to store particle positions in the State getVelocities (bool=False) â whether to store particle velocities in the State getForces (bool=False) â whether to store the forces acting on particles in the State getEnergy (bool=False) â whether to store potential and kinetic energy in the State getParameters (bool=False) â whether to store context parameters in the State getParameterDerivatives (bool=False) â whether to store parameter derivatives in the State getIntegratorParameters (bool=False) â whether to store integrator parameters in the State enforcePeriodicBox (bool=False) â if false, the position of each particle will be whatever position is stored in the Context, regardless of periodic boundary conditions. If true, particle positions will be translated so the center of every molecule lies in the same periodic box. groups (set={0,1,2,...,31}) â a set of indices for which force groups to include when computing forces and energies. The default value includes all groups. groups can also be passed as an unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. createCheckpoint(self) → std::stringÂ¶ Create a checkpoint recording the current state of the Context. This should be treated as an opaque block of binary data. See loadCheckpoint() for more details. Returns: a string containing the checkpoint data loadCheckpoint(self, checkpoint)Â¶ Load a checkpoint that was written by createCheckpoint(). A checkpoint contains not only publicly visible data such as the particle positions and velocities, but also internal data such as the states of random number generators. Ideally, loading a checkpoint should restore the Context to an identical state to when it was written, such that continuing the simulation will produce an identical trajectory. This is not strictly guaranteed to be true, however, and should not be relied on. For most purposes, however, the internal state should be close enough to be reasonably considered equivalent. A checkpoint contains data that is highly specific to the Context from which it was created. It depends on the details of the System, the Platform being used, and the hardware and software of the computer it was created on. If you try to load it on a computer with different hardware, or for a System that is different in any way, loading is likely to fail. Checkpoints created with different versions of OpenMM are also often incompatible. If a checkpoint cannot be loaded, that is signaled by throwing an exception. Parameters: checkpoint (string) the checkpoint data to load

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Continuous1DFunction.html:
Continuous1DFunctionÂ¶ class openmm.openmm.Continuous1DFunction(*args)Â¶ This is a TabulatedFunction that computes a continuous one dimensional function. __init__(self, values, min, max, periodic=False) → Continuous1DFunctionÂ¶ __init__(self, other) → Continuous1DFunction Create a Continuous1DFunction f(x) based on a set of tabulated values. Parameters values (vector< double >) â the tabulated values of the function f(x) at uniformly spaced values of x between min and max. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero for x < min or x > max. min (double) â the value of x corresponding to the first element of values max (double) â the value of x corresponding to the last element of values periodic (bool) â whether the interpolated function is periodic Methods Copy(self) Create a deep copy of the tabulated function. __init__(->Â Continuous1DFunction) Create a Continuous1DFunction f(x) based on a set of tabulated values. getFunctionParameters(self) Get the parameters for the tabulated function. getPeriodic(self) Get the periodicity status of the tabulated function. getUpdateCount(self) Get the value of a counter that is updated every time setFunctionParameters() is called. setFunctionParameters(self,Â values,Â min,Â max) Set the parameters for the tabulated function. Attributes thisown The membership flag property thisownÂ¶ The membership flag getFunctionParameters(self)Â¶ Get the parameters for the tabulated function. Returns values (vector< double >) â the tabulated values of the function f(x) at uniformly spaced values of x between min and max. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero for x < min or x > max. min (double) â the value of x corresponding to the first element of values max (double) â the value of x corresponding to the last element of values setFunctionParameters(self, values, min, max)Â¶ Set the parameters for the tabulated function. Parameters values (vector< double >) â the tabulated values of the function f(x) at uniformly spaced values of x between min and max. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero for x < min or x > max. min (double) â the value of x corresponding to the first element of values max (double) â the value of x corresponding to the last element of values Copy(self) → Continuous1DFunctionÂ¶ Create a deep copy of the tabulated function. Deprecated This will be removed in a future release. __eq__(self, other) → boolÂ¶ __ne__(self, other) → boolÂ¶ getPeriodic(self) → boolÂ¶ Get the periodicity status of the tabulated function. getUpdateCount(self) → intÂ¶ Get the value of a counter that is updated every time setFunctionParameters() is called. This provides a fast way to detect when a function has changed.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Continuous2DFunction.html:
Continuous2DFunctionÂ¶ class openmm.openmm.Continuous2DFunction(*args)Â¶ This is a TabulatedFunction that computes a continuous two dimensional function. __init__(self, xsize, ysize, values, xmin, xmax, ymin, ymax, periodic=False) → Continuous2DFunctionÂ¶ __init__(self, other) → Continuous2DFunction Create a Continuous2DFunction f(x,y) based on a set of tabulated values. Parameters values (int) â the tabulated values of the function f(x,y) at xsize uniformly spaced values of x between xmin and xmax, and ysize values of y between ymin and ymax. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero when x or y is outside its specified range. The values should be ordered so that values[i+xsize*j] = f(x_i,y_j), where x_i is the iâth uniformly spaced value of x. This must be of length xsize*ysize. xsize (int) â the number of table elements along the x direction ysize (vector< double >) â the number of table elements along the y direction xmin (double) â the value of x corresponding to the first element of values xmax (double) â the value of x corresponding to the last element of values ymin (double) â the value of y corresponding to the first element of values ymax (double) â the value of y corresponding to the last element of values periodic (bool) â whether the interpolated function is periodic Methods Copy(self) Create a deep copy of the tabulated function __init__(->Â Continuous2DFunction) Create a Continuous2DFunction f(x,y) based on a set of tabulated values. getFunctionParameters(self) Get the parameters for the tabulated function. getPeriodic(self) Get the periodicity status of the tabulated function. getUpdateCount(self) Get the value of a counter that is updated every time setFunctionParameters() is called. setFunctionParameters(self,Â xsize,Â ysize,Â â¦) Set the parameters for the tabulated function. Attributes thisown The membership flag property thisownÂ¶ The membership flag getFunctionParameters(self)Â¶ Get the parameters for the tabulated function. Returns values (int) â the tabulated values of the function f(x,y) at xsize uniformly spaced values of x between xmin and xmax, and ysize values of y between ymin and ymax. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero when x or y is outside its specified range. The values should be ordered so that values[i+xsize*j] = f(x_i,y_j), where x_i is the iâth uniformly spaced value of x. This must be of length xsize*ysize. xsize (int) â the number of table elements along the x direction ysize (vector< double >) â the number of table elements along the y direction xmin (double) â the value of x corresponding to the first element of values xmax (double) â the value of x corresponding to the last element of values ymin (double) â the value of y corresponding to the first element of values ymax (double) â the value of y corresponding to the last element of values setFunctionParameters(self, xsize, ysize, values, xmin, xmax, ymin, ymax)Â¶ Set the parameters for the tabulated function. Parameters values (int) â the tabulated values of the function f(x,y) at xsize uniformly spaced values of x between xmin and xmax, and ysize values of y between ymin and ymax. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero when x or y is outside its specified range. The values should be ordered so that values[i+xsize*j] = f(x_i,y_j), where x_i is the iâth uniformly spaced value of x. This must be of length xsize*ysize. xsize (int) â the number of table elements along the x direction ysize (vector< double >) â the number of table elements along the y direction xmin (double) â the value of x corresponding to the first element of values xmax (double) â the value of x corresponding to the last element of values ymin (double) â the value of y corresponding to the first element of values ymax (double) â the value of y corresponding to the last element of values Copy(self) → Continuous2DFunctionÂ¶ Create a deep copy of the tabulated function Deprecated This will be removed in a future release. __eq__(self, other) → boolÂ¶ __ne__(self, other) → boolÂ¶ getPeriodic(self) → boolÂ¶ Get the periodicity status of the tabulated function. getUpdateCount(self) → intÂ¶ Get the value of a counter that is updated every time setFunctionParameters() is called. This provides a fast way to detect when a function has changed.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Continuous3DFunction.html:
Continuous3DFunctionÂ¶ class openmm.openmm.Continuous3DFunction(*args)Â¶ This is a TabulatedFunction that computes a continuous three dimensional function. __init__(self, xsize, ysize, zsize, values, xmin, xmax, ymin, ymax, zmin, zmax, periodic=False) → Continuous3DFunctionÂ¶ __init__(self, other) → Continuous3DFunction Create a Continuous3DFunction f(x,y,z) based on a set of tabulated values. Parameters values (int) â the tabulated values of the function f(x,y,z) at xsize uniformly spaced values of x between xmin and xmax, ysize values of y between ymin and ymax, and zsize values of z between zmin and zmax. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero when x, y, or z is outside its specified range. The values should be ordered so that values[i+xsize*j+xsize*ysize*k] = f(x_i,y_j,z_k), where x_i is the iâth uniformly spaced value of x. This must be of length xsize*ysize*zsize. xsize (int) â the number of table elements along the x direction ysize (vector< double >) â the number of table elements along the y direction ysize â the number of table elements along the z direction xmin (double) â the value of x corresponding to the first element of values xmax (double) â the value of x corresponding to the last element of values ymin (double) â the value of y corresponding to the first element of values ymax (double) â the value of y corresponding to the last element of values zmin (double) â the value of z corresponding to the first element of values zmax (double) â the value of z corresponding to the last element of values periodic (bool) â whether the interpolated function is periodic Methods Copy(self) Create a deep copy of the tabulated function __init__(->Â Continuous3DFunction) Create a Continuous3DFunction f(x,y,z) based on a set of tabulated values. getFunctionParameters(self) Get the parameters for the tabulated function. getPeriodic(self) Get the periodicity status of the tabulated function. getUpdateCount(self) Get the value of a counter that is updated every time setFunctionParameters() is called. setFunctionParameters(self,Â xsize,Â ysize,Â â¦) Set the parameters for the tabulated function. Attributes thisown The membership flag property thisownÂ¶ The membership flag getFunctionParameters(self)Â¶ Get the parameters for the tabulated function. Returns values (int) â the tabulated values of the function f(x,y,z) at xsize uniformly spaced values of x between xmin and xmax, ysize values of y between ymin and ymax, and zsize values of z between zmin and zmax. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero when x, y, or z is outside its specified range. The values should be ordered so that values[i+xsize*j+xsize*ysize*k] = f(x_i,y_j,z_k), where x_i is the iâth uniformly spaced value of x. This must be of length xsize*ysize*zsize. xsize (int) â the number of table elements along the x direction ysize (int) â the number of table elements along the y direction zsize (vector< double >) â the number of table elements along the z direction xmin (double) â the value of x corresponding to the first element of values xmax (double) â the value of x corresponding to the last element of values ymin (double) â the value of y corresponding to the first element of values ymax (double) â the value of y corresponding to the last element of values zmin (double) â the value of z corresponding to the first element of values zmax (double) â the value of z corresponding to the last element of values setFunctionParameters(self, xsize, ysize, zsize, values, xmin, xmax, ymin, ymax, zmin, zmax)Â¶ Set the parameters for the tabulated function. Parameters values (int) â the tabulated values of the function f(x,y,z) at xsize uniformly spaced values of x between xmin and xmax, ysize values of y between ymin and ymax, and zsize values of z between zmin and zmax. A natural cubic spline is used to interpolate between the tabulated values. The function is assumed to be zero when x, y, or z is outside its specified range. The values should be ordered so that values[i+xsize*j+xsize*ysize*k] = f(x_i,y_j,z_k), where x_i is the iâth uniformly spaced value of x. This must be of length xsize*ysize*zsize. xsize (int) â the number of table elements along the x direction ysize (int) â the number of table elements along the y direction zsize (vector< double >) â the number of table elements along the z direction xmin (double) â the value of x corresponding to the first element of values xmax (double) â the value of x corresponding to the last element of values ymin (double) â the value of y corresponding to the first element of values ymax (double) â the value of y corresponding to the last element of values zmin (double) â the value of z corresponding to the first element of values zmax (double) â the value of z corresponding to the last element of values Copy(self) → Continuous3DFunctionÂ¶ Create a deep copy of the tabulated function Deprecated This will be removed in a future release. __eq__(self, other) → boolÂ¶ __ne__(self, other) → boolÂ¶ getPeriodic(self) → boolÂ¶ Get the periodicity status of the tabulated function. getUpdateCount(self) → intÂ¶ Get the value of a counter that is updated every time setFunctionParameters() is called. This provides a fast way to detect when a function has changed.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomAngleForce.html:
CustomAngleForceÂ¶ class openmm.openmm.CustomAngleForce(*args)Â¶ This class implements interactions between sets of three particles that depend on the angle between them. Unlike HarmonicAngleForce, the functional form of the interaction is completely customizable, and may involve arbitrary algebraic expressions. In addition to the angle formed by the particles, it may depend on arbitrary global and per-angle parameters. To use this class, create a CustomAngleForce object, passing an algebraic expression to the constructor that defines the interaction energy between each set of particles. The expression may depend on theta, the angle formed by the particles, as well as on any parameters you choose. Then call addPerAngleParameter() to define per-angle parameters, and addGlobalParameter() to define global parameters. The values of per-angle parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Finally, call addAngle() once for each angle. After an angle has been added, you can modify its parameters by calling setAngleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). As an example, the following code creates a CustomAngleForce that implements a harmonic potential: CustomAngleForce* force = new CustomAngleForce("0.5*k*(theta-theta0)^2"); This force depends on two parameters: the spring constant k and equilibrium angle theta0. The following code defines these parameters: force->addPerAngleParameter("k"); force->addPerAngleParameter("theta0"); This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. __init__(self, energy) → CustomAngleForceÂ¶ __init__(self, other) → CustomAngleForce Create a CustomAngleForce. Parameters energy (string) â an algebraic expression giving the interaction energy between three particles as a function of theta, the angle between them Methods __init__(->Â CustomAngleForce) Create a CustomAngleForce. addAngle(self,Â particle1,Â particle2,Â particle3) Add an angle term to the force field. addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addPerAngleParameter(self,Â name) Add a new per-angle parameter that the interaction may depend on. getAngleParameters(self,Â index) Get the force field parameters for an angle term. getEnergyFunction(self) Get the algebraic expression that gives the interaction energy for each angle getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNumAngles(self) Get the number of angles for which force field parameters have been defined. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumPerAngleParameters(self) Get the number of per-angle parameters that the interaction depends on. getPerAngleParameterName(self,Â index) Get the name of a per-angle parameter. setAngleParameters(self,Â index,Â particle1,Â â¦) Set the force field parameters for an angle term. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the interaction energy for each angle setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setPerAngleParameterName(self,Â index,Â name) Set the name of a per-angle parameter. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-angle parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumAngles(self) → intÂ¶ Get the number of angles for which force field parameters have been defined. getNumPerAngleParameters(self) → intÂ¶ Get the number of per-angle parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the interaction energy for each angle setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the interaction energy for each angle addPerAngleParameter(self, name) → intÂ¶ Add a new per-angle parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerAngleParameterName(self, index) → std::string const &Â¶ Get the name of a per-angle parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerAngleParameterName(self, index, name)Â¶ Set the name of a per-angle parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string addAngle(self, particle1, particle2, particle3, parameters=std::vector< double >()) → intÂ¶ Add an angle term to the force field. Parameters particle1 (int) â the index of the first particle connected by the angle particle2 (int) â the index of the second particle connected by the angle particle3 (int) â the index of the third particle connected by the angle parameters (vector< double >) â the list of parameters for the new angle Returns the index of the angle that was added Return type int getAngleParameters(self, index)Â¶ Get the force field parameters for an angle term. Parameters index (int) â the index of the angle for which to get parameters Returns particle1 (int) â the index of the first particle connected by the angle particle2 (int) â the index of the second particle connected by the angle particle3 (int) â the index of the third particle connected by the angle parameters (vector< double >) â the list of parameters for the angle setAngleParameters(self, index, particle1, particle2, particle3, parameters=std::vector< double >())Â¶ Set the force field parameters for an angle term. Parameters index (int) â the index of the angle for which to set parameters particle1 (int) â the index of the first particle connected by the angle particle2 (int) â the index of the second particle connected by the angle particle3 (int) â the index of the third particle connected by the angle parameters (vector< double >) â the list of parameters for the angle updateParametersInContext(self, context)Â¶ Update the per-angle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setAngleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-angle parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a angle cannot be changed, nor can new angles be added. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomBondForce.html:
CustomBondForceÂ¶ class openmm.openmm.CustomBondForce(*args)Â¶ This class implements bonded interactions between pairs of particles. Unlike HarmonicBondForce, the functional form of the interaction is completely customizable, and may involve arbitrary algebraic expressions. It may depend on the distance between particles, as well as on arbitrary global and per-bond parameters. To use this class, create a CustomBondForce object, passing an algebraic expression to the constructor that defines the interaction energy between each pair of bonded particles. The expression may depend on r, the distance between the particles, as well as on any parameters you choose. Then call addPerBondParameter() to define per-bond parameters, and addGlobalParameter() to define global parameters. The values of per-bond parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Finally, call addBond() once for each bond. After a bond has been added, you can modify its parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). As an example, the following code creates a CustomBondForce that implements a harmonic potential: CustomBondForce* force = new CustomBondForce("0.5*k*(r-r0)^2"); This force depends on two parameters: the spring constant k and equilibrium distance r0. The following code defines these parameters: force->addPerBondParameter("k"); force->addPerBondParameter("r0"); This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. __init__(self, energy) → CustomBondForceÂ¶ __init__(self, other) → CustomBondForce Create a CustomBondForce. Parameters energy (string) â an algebraic expression giving the interaction energy between two bonded particles as a function of r, the distance between them Methods __init__(->Â CustomBondForce) Create a CustomBondForce. addBond(self,Â particle1,Â particle2[,Â parameters]) Add a bond term to the force field. addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addPerBondParameter(self,Â name) Add a new per-bond parameter that the interaction may depend on. getBondParameters(self,Â index) Get the force field parameters for a bond term. getEnergyFunction(self) Get the algebraic expression that gives the interaction energy for each bond getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNumBonds(self) Get the number of bonds for which force field parameters have been defined. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumPerBondParameters(self) Get the number of per-bond parameters that the interaction depends on. getPerBondParameterName(self,Â index) Get the name of a per-bond parameter. setBondParameters(self,Â index,Â particle1,Â â¦) Set the force field parameters for a bond term. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the interaction energy for each bond setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setPerBondParameterName(self,Â index,Â name) Set the name of a per-bond parameter. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-bond parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumBonds(self) → intÂ¶ Get the number of bonds for which force field parameters have been defined. getNumPerBondParameters(self) → intÂ¶ Get the number of per-bond parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the interaction energy for each bond setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the interaction energy for each bond addPerBondParameter(self, name) → intÂ¶ Add a new per-bond parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerBondParameterName(self, index) → std::string const &Â¶ Get the name of a per-bond parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerBondParameterName(self, index, name)Â¶ Set the name of a per-bond parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string addBond(self, particle1, particle2, parameters=std::vector< double >()) → intÂ¶ Add a bond term to the force field. Parameters particle1 (int) â the index of the first particle connected by the bond particle2 (int) â the index of the second particle connected by the bond parameters (vector< double >) â the list of parameters for the new bond Returns the index of the bond that was added Return type int getBondParameters(self, index)Â¶ Get the force field parameters for a bond term. Parameters index (int) â the index of the bond for which to get parameters Returns particle1 (int) â the index of the first particle connected by the bond particle2 (int) â the index of the second particle connected by the bond parameters (vector< double >) â the list of parameters for the bond setBondParameters(self, index, particle1, particle2, parameters=std::vector< double >())Â¶ Set the force field parameters for a bond term. Parameters index (int) â the index of the bond for which to set parameters particle1 (int) â the index of the first particle connected by the bond particle2 (int) â the index of the second particle connected by the bond parameters (vector< double >) â the list of parameters for the bond updateParametersInContext(self, context)Â¶ Update the per-bond parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-bond parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a bond cannot be changed, nor can new bonds be added. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomCentroidBondForce.html:
CustomCentroidBondForceÂ¶ class openmm.openmm.CustomCentroidBondForce(*args)Â¶ This class is similar to CustomCompoundBondForce, but instead of applying forces between individual particles, it applies them between the centers of groups of particles. This is useful for a variety of purposes, such as restraints to keep two molecules from moving too far apart. When using this class, you define groups of particles, and the center of each group is calculated as a weighted average of the particle positions. By default, the particle masses are used as weights, so the center position is the center of mass. You can optionally specify different weights to use. You then add bonds just as with CustomCompoundBondForce, but instead of specifying the particles that make up a bond, you specify the groups. When creating a CustomCentroidBondForce, you specify the number of groups involved in a bond, and an expression for the energy of each bond. It may depend on the center positions of individual groups, the distances between the centers of pairs of groups, the angles formed by sets of three groups, and the dihedral angles formed by sets of four groups. We refer to the groups in a bond as g1, g2, g3, etc. For each bond, CustomCentroidBondForce evaluates a user supplied algebraic expression to determine the interaction energy. The expression may depend on the following variables and functions: x1, y1, z1, x2, y2, z2, etc.: The x, y, and z coordinates of the centers of the groups. For example, x1 is the x coordinate of the center of group g1, and y3 is the y coordinate of the center of group g3. distance(g1, g2): the distance between the centers of groups g1 and g2 (where âg1â and âg2â may be replaced by the names of whichever groups you want to calculate the distance between). angle(g1, g2, g3): the angle formed by the centers of the three specified groups. dihedral(g1, g2, g3, g4): the dihedral angle formed by the centers of the four specified groups. The expression also may involve tabulated functions, and may depend on arbitrary global and per-bond parameters. To use this class, create a CustomCentroidBondForce object, passing an algebraic expression to the constructor that defines the interaction energy of each bond. Then call addPerBondParameter() to define per-bond parameters and addGlobalParameter() to define global parameters. The values of per-bond parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Next call addGroup() to define the particle groups. Each group is specified by the particles it contains, and the weights to use when computing the center position. Then call addBond() to define bonds and specify their parameter values. After a bond has been added, you can modify its parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). As an example, the following code creates a CustomCentroidBondForce that implements a harmonic force between the centers of mass of two groups of particles. CustomCentroidBondForce* force = new CustomCentroidBondForce(2, "0.5*k*distance(g1,g2)^2"); force->addPerBondParameter("k"); force->addGroup(particles1); force->addGroup(particles2); vector<int> bondGroups; bondGroups.push_back(0); bondGroups.push_back(1); vector<double> bondParameters; bondParameters.push_back(k); force->addBond(bondGroups, bondParameters); This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. This class also supports the functions pointdistance(x1, y1, z1, x2, y2, z2), pointangle(x1, y1, z1, x2, y2, z2, x3, y3, z3), and pointdihedral(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4). These functions are similar to distance(), angle(), and dihedral(), but the arguments are the coordinates of points to perform the calculation based on rather than the names of groups. This enables more flexible geometric calculations. For example, the following computes the distance from group g1 to the midpoint between groups g2 and g3. CustomCentroidBondForce* force = new CustomCentroidBondForce(3, "pointdistance(x1, y1, z1, (x2+x3)/2, (y2+y3)/2, (z2+z3)/2)"); In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression. __init__(self, numGroups, energy) → CustomCentroidBondForceÂ¶ __init__(self, other) → CustomCentroidBondForce Create a CustomCentroidBondForce. Parameters numGroups (int) â the number of groups used to define each bond energy (string) â an algebraic expression giving the interaction energy of each bond as a function of particle positions, inter-particle distances, angles, and dihedrals, and any global and per-bond parameters Methods __init__(->Â CustomCentroidBondForce) Create a CustomCentroidBondForce. addBond(self,Â groups[,Â parameters]) Add a bond to the force addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addGroup(self,Â particles[,Â weights]) Add a particle group. addPerBondParameter(self,Â name) Add a new per-bond parameter that the interaction may depend on. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in the energy expression. getBondParameters(self,Â index) Get the properties of a bond. getEnergyFunction(self) Get the algebraic expression that gives the interaction energy of each bond getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getGroupParameters(self,Â index) Get the properties of a group. getName(self) Get the name of this Force. getNumBonds(self) Get the number of bonds for which force field parameters have been defined. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumFunctions(self) Get the number of tabulated functions that have been defined. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumGroups(self) Get the number of particle groups that have been defined. getNumGroupsPerBond(self) Get the number of groups used to define each bond. getNumPerBondParameters(self) Get the number of per-bond parameters that the interaction depends on. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerBondParameterName(self,Â index) Get the name of a per-bond parameter. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in the energy expression. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in the energy expression. setBondParameters(self,Â index,Â groups[,Â â¦]) Set the properties of a bond. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the interaction energy of each bond setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setGroupParameters(self,Â index,Â particles[,Â â¦]) Set the properties of a group. setName(self,Â name) Set the name of this Force. setPerBondParameterName(self,Â index,Â name) Set the name of a per-bond parameter. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-bond parameters and tabulated functions in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumGroupsPerBond(self) → intÂ¶ Get the number of groups used to define each bond. getNumGroups(self) → intÂ¶ Get the number of particle groups that have been defined. getNumBonds(self) → intÂ¶ Get the number of bonds for which force field parameters have been defined. getNumPerBondParameters(self) → intÂ¶ Get the number of per-bond parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getNumFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. Deprecated This method exists only for backward compatibility. Use getNumTabulatedFunctions() instead. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the interaction energy of each bond setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the interaction energy of each bond addPerBondParameter(self, name) → intÂ¶ Add a new per-bond parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerBondParameterName(self, index) → std::string const &Â¶ Get the name of a per-bond parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerBondParameterName(self, index, name)Â¶ Set the name of a per-bond parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string addGroup(self, particles, weights=std::vector< double >()) → intÂ¶ Add a particle group. Parameters particles (vector< int >) â the indices of the particles to include in the group weights (vector< double >) â the weight to use for each particle when computing the center position. If this is omitted, then particle masses will be used as weights. Returns the index of the group that was added Return type int getGroupParameters(self, index)Â¶ Get the properties of a group. Parameters index (int) â the index of the group to get Returns particles (vector< int >) â the indices of the particles in the group weights (vector< double >) â the weight used for each particle when computing the center position. If no weights were specified, this vector will be empty indicating that particle masses should be used as weights. setGroupParameters(self, index, particles, weights=std::vector< double >())Â¶ Set the properties of a group. Parameters index (int) â the index of the group to set particles (vector< int >) â the indices of the particles in the group weights (vector< double >) â the weight to use for each particle when computing the center position. If this is omitted, then particle masses will be used as weights. addBond(self, groups, parameters=std::vector< double >()) → intÂ¶ Add a bond to the force Parameters groups (vector< int >) â the indices of the groups the bond depends on parameters (vector< double >) â the list of per-bond parameter values for the new bond Returns the index of the bond that was added Return type int getBondParameters(self, index)Â¶ Get the properties of a bond. Parameters index (int) â the index of the bond to get Returns groups (vector< int >) â the indices of the groups in the bond parameters (vector< double >) â the list of per-bond parameter values for the bond setBondParameters(self, index, groups, parameters=std::vector< double >())Â¶ Set the properties of a bond. Parameters index (int) â the index of the bond to set groups (vector< int >) â the indices of the groups in the bond parameters (vector< double >) â the list of per-bond parameter values for the bond addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in the energy expression. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted. Returns the index of the function that was added Return type int getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string updateParametersInContext(self, context)Â¶ Update the per-bond parameters and tabulated functions in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-bond parameters and tabulated functions. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. Neither the definitions of groups nor the set of groups involved in a bond can be changed, nor can new bonds be added. Also, while the tabulated values of a function can change, everything else about it (its dimensions, the data range) must not be changed. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomCompoundBondForce.html:
CustomCompoundBondForceÂ¶ class openmm.openmm.CustomCompoundBondForce(*args)Â¶ This class supports a wide variety of bonded interactions. It defines a âbondâ as a single energy term that depends on the positions of a fixed set of particles. The number of particles involved in a bond, and how the energy depends on their positions, is configurable. It may depend on the positions of individual particles, the distances between pairs of particles, the angles formed by sets of three particles, and the dihedral angles formed by sets of four particles. We refer to the particles in a bond as p1, p2, p3, etc. For each bond, CustomCompoundBondForce evaluates a user supplied algebraic expression to determine the interaction energy. The expression may depend on the following variables and functions: x1, y1, z1, x2, y2, z2, etc.: The x, y, and z coordinates of the particle positions. For example, x1 is the x coordinate of particle p1, and y3 is the y coordinate of particle p3. distance(p1, p2): the distance between particles p1 and p2 (where âp1â and âp2â may be replaced by the names of whichever particles you want to calculate the distance between). angle(p1, p2, p3): the angle formed by the three specified particles. dihedral(p1, p2, p3, p4): the dihedral angle formed by the four specified particles, guaranteed to be in the range [-pi,+pi]. The expression also may involve tabulated functions, and may depend on arbitrary global and per-bond parameters. To use this class, create a CustomCompoundBondForce object, passing an algebraic expression to the constructor that defines the interaction energy of each bond. Then call addPerBondParameter() to define per-bond parameters and addGlobalParameter() to define global parameters. The values of per-bond parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Next, call addBond() to define bonds and specify their parameter values. After a bond has been added, you can modify its parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). As an example, the following code creates a CustomCompoundBondForce that implements a Urey-Bradley potential. This is an interaction between three particles that depends on the angle formed by p1-p2-p3, and on the distance between p1 and p3. CustomCompoundBondForce* force = new CustomCompoundBondForce(3, "0.5*(kangle*(angle(p1,p2,p3)-theta0)^2+kbond*(distance(p1,p3)-r0)^2)"); This force depends on four parameters: kangle, kbond, theta0, and r0. The following code defines these as per-bond parameters: force->addPerBondParameter("kangle"); force->addPerBondParameter("kbond"); force->addPerBondParameter("theta0"); force->addPerBondParameter("r0"); This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. This class also supports the functions pointdistance(x1, y1, z1, x2, y2, z2), pointangle(x1, y1, z1, x2, y2, z2, x3, y3, z3), and pointdihedral(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4). These functions are similar to distance(), angle(), and dihedral(), but the arguments are the coordinates of points to perform the calculation based on rather than the names of particles. This enables more flexible geometric calculations. For example, the following computes the distance from particle p1 to the midpoint between particles p2 and p3. CustomCompoundBondForce* force = new CustomCompoundBondForce(3, "pointdistance(x1, y1, z1, (x2+x3)/2, (y2+y3)/2, (z2+z3)/2)"); In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression. __init__(self, numParticles, energy) → CustomCompoundBondForceÂ¶ __init__(self, other) → CustomCompoundBondForce Create a CustomCompoundBondForce. Parameters numParticles (int) â the number of particles used to define each bond energy (string) â an algebraic expression giving the interaction energy of each bond as a function of particle positions, inter-particle distances, angles, and dihedrals, and any global and per-bond parameters Methods __init__(->Â CustomCompoundBondForce) Create a CustomCompoundBondForce. addBond(self,Â particles[,Â parameters]) Add a bond to the force addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addFunction(self,Â name,Â values,Â min,Â max) Add a tabulated function that may appear in the energy expression. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addPerBondParameter(self,Â name) Add a new per-bond parameter that the interaction may depend on. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in the energy expression. getBondParameters(self,Â index) Get the properties of a bond. getEnergyFunction(self) Get the algebraic expression that gives the interaction energy of each bond getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getForceGroup(self) Get the force group this Force belongs to. getFunctionParameters(self,Â index) Get the parameters for a tabulated function that may appear in the energy expression. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNumBonds(self) Get the number of bonds for which force field parameters have been defined. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumFunctions(self) Get the number of tabulated functions that have been defined. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumParticlesPerBond(self) Get the number of particles used to define each bond. getNumPerBondParameters(self) Get the number of per-bond parameters that the interaction depends on. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerBondParameterName(self,Â index) Get the name of a per-bond parameter. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in the energy expression. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in the energy expression. setBondParameters(self,Â index,Â particles[,Â â¦]) Set the properties of a bond. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the interaction energy of each bond setForceGroup(self,Â group) Set the force group this Force belongs to. setFunctionParameters(self,Â index,Â name,Â â¦) Set the parameters for a tabulated function that may appear in the energy expression. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setPerBondParameterName(self,Â index,Â name) Set the name of a per-bond parameter. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-bond parameters and tabulated functions in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumParticlesPerBond(self) → intÂ¶ Get the number of particles used to define each bond. getNumBonds(self) → intÂ¶ Get the number of bonds for which force field parameters have been defined. getNumPerBondParameters(self) → intÂ¶ Get the number of per-bond parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getNumFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. Deprecated This method exists only for backward compatibility. Use getNumTabulatedFunctions() instead. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the interaction energy of each bond setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the interaction energy of each bond addPerBondParameter(self, name) → intÂ¶ Add a new per-bond parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerBondParameterName(self, index) → std::string const &Â¶ Get the name of a per-bond parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerBondParameterName(self, index, name)Â¶ Set the name of a per-bond parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string addBond(self, particles, parameters=std::vector< double >()) → intÂ¶ Add a bond to the force Parameters particles (vector< int >) â the indices of the particles the bond depends on parameters (vector< double >) â the list of per-bond parameter values for the new bond Returns the index of the bond that was added Return type int getBondParameters(self, index)Â¶ Get the properties of a bond. Parameters index (int) â the index of the bond to get Returns particles (vector< int >) â the indices of the particles in the bond parameters (vector< double >) â the list of per-bond parameter values for the bond setBondParameters(self, index, particles, parameters=std::vector< double >())Â¶ Set the properties of a bond. Parameters index (int) â the index of the bond to set particles (vector< int >) â the indices of the particles in the bond parameters (vector< double >) â the list of per-bond parameter values for the bond addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in the energy expression. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted. Returns the index of the function that was added Return type int getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string addFunction(self, name, values, min, max) → intÂ¶ Add a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Use addTabulatedFunction() instead. getFunctionParameters(self, index)Â¶ Get the parameters for a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Call getFunctionParameters() on the TabulatedFunction object instead. If the specified function is not a Continuous1DFunction, this throws an exception. setFunctionParameters(self, index, name, values, min, max)Â¶ Set the parameters for a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Call setFunctionParameters() on the TabulatedFunction object instead. If the specified function is not a Continuous1DFunction, this throws an exception. updateParametersInContext(self, context)Â¶ Update the per-bond parameters and tabulated functions in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-bond parameters and tabulated functions. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a bond cannot be changed, nor can new bonds be added. Also, while the tabulated values of a function can change, everything else about it (its dimensions, the data range) must not be changed. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomCVForce.html:
CustomCVForceÂ¶ class openmm.openmm.CustomCVForce(*args)Â¶ This class supports energy functions that depend on collective variables. To use it, you define a set of collective variables (scalar valued functions that depend on the particle positions), and an algebraic expression for the energy as a function of the collective variables. The expression also may involve tabulated functions, and may depend on arbitrary global parameters. Each collective variable is defined by a Force object. The Forceâs potential energy is computed, and that becomes the value of the variable. This provides enormous flexibility in defining collective variables, especially by using custom forces. Anything that can be computed as a potential function can also be used as a collective variable. To use this class, create a CustomCVForce object, passing an algebraic expression to the constructor that defines the potential energy. Then call addCollectiveVariable() to define collective variables and addGlobalParameter() to define global parameters. The values of global parameters may be modified during a simulation by calling Context::setParameter(). This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression. __init__(self, energy) → CustomCVForceÂ¶ __init__(self, other) → CustomCVForce Create a CustomCVForce. Parameters energy (string) â an algebraic expression giving the energy of the system as a function of the collective variables and global parameters Methods __init__(->Â CustomCVForce) Create a CustomCVForce. addCollectiveVariable(self,Â name,Â variable) Add a collective variable that the force may depend on. addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in the energy expression. getCollectiveVariable(->Â Force) Get a const reference to the Force object that computes a collective variable. getCollectiveVariableName(self,Â index) Get the name of a collective variable. getCollectiveVariableValues(self,Â context) Get the current values of the collective variables in a Context. getEnergyFunction(self) Get the algebraic expression that gives the energy of the system getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getInnerContext(self,Â context) Get the inner Context used for evaluating collective variables. getName(self) Get the name of this Force. getNumCollectiveVariables(self) Get the number of collective variables that the interaction depends on. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in the energy expression. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in the energy expression. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the energy of the system setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. updateParametersInContext(self,Â context) Update the tabulated function parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumCollectiveVariables(self) → intÂ¶ Get the number of collective variables that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the energy of the system setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the energy of the system addCollectiveVariable(self, name, variable) → intÂ¶ Add a collective variable that the force may depend on. The collective variable is represented by a Force object, which should have been created on the heap with the ânewâ operator. The CustomCVForce takes over ownership of it, and deletes the Force when the CustomCVForce itself is deleted. Parameters name (string) â the name of the collective variable, as it will appear in the energy expression variable (Force *) â the collective variable, represented by a Force object. The value of the variable is the energy computed by the Force. Returns the index within the Force of the variable that was added Return type int getCollectiveVariableName(self, index) → std::string const &Â¶ Get the name of a collective variable. Parameters index (int) â the index of the collective variable for which to get the name Returns the variable name Return type string getCollectiveVariable(self, index) → ForceÂ¶ getCollectiveVariable(self, index) → Force Get a const reference to the Force object that computes a collective variable. Parameters index (int) â the index of the collective variable to get Returns the Force object Return type Force addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in the energy expression. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted. Returns the index of the function that was added Return type int getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string getCollectiveVariableValues(self, context)Â¶ Get the current values of the collective variables in a Context. Parameters context (Context) â the Context for which to get the values Returns values â the values of the collective variables are computed and stored into this Return type vector< double > getInnerContext(self, context) → ContextÂ¶ Get the inner Context used for evaluating collective variables. When you create a Context for a System that contains a CustomCVForce, internally it creates a new System, adds the Forces that define the CVs to it, creates a new Context for that System, and uses it to evaluate the variables. In most cases you can ignore all of this. It is just an implementation detail. However, there are a few cases where you need to directly access that internal Context. For example, if you want to modify one of the Forces that defines a collective variable and call updateParametersInContext() on it, you need to pass that inner Context to it. This method returns a reference to it. Parameters context (Context) â the Context containing the CustomCVForce Returns the inner Context used to evaluate the collective variables Return type Context updateParametersInContext(self, context)Â¶ Update the tabulated function parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call getTabulatedFunction(index).setFunctionParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method is very limited. The only information it updates is the parameters of tabulated functions. All other aspects of the Force (the energy expression, the set of collective variables, etc.) are unaffected and can only be changed by reinitializing the Context. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomExternalForce.html:
CustomExternalForceÂ¶ class openmm.openmm.CustomExternalForce(*args)Â¶ This class implements an âexternalâ force on particles. The force may be applied to any subset of the particles in the System. The force on each particle is specified by an arbitrary algebraic expression, which may depend on the current position of the particle as well as on arbitrary global and per-particle parameters. To use this class, create a CustomExternalForce object, passing an algebraic expression to the constructor that defines the potential energy of each affected particle. The expression may depend on the particleâs x, y, and z coordinates, as well as on any parameters you choose. Then call addPerParticleParameter() to define per-particle parameters, and addGlobalParameter() to define global parameters. The values of per-particle parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Finally, call addParticle() once for each particle that should be affected by the force. After a particle has been added, you can modify its parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). As an example, the following code creates a CustomExternalForce that attracts each particle to a target position (x0, y0, z0) via a harmonic potential: CustomExternalForce* force = new CustomExternalForce("k*((x-x0)^2+(y-y0)^2+(z-z0)^2)"); This force depends on four parameters: the spring constant k and equilibrium coordinates x0, y0, and z0. The following code defines these parameters: force->addGlobalParameter("k", 100.0); force->addPerParticleParameter("x0"); force->addPerParticleParameter("y0"); force->addPerParticleParameter("z0"); Special care is needed in systems that use periodic boundary conditions. In that case, each particle really represents an infinite set of particles repeating through space. The variables x, y, and z contain the coordinates of one of those periodic copies, but there is no guarantee about which. It might even change from one time step to the next. You can handle this situation by using the function periodicdistance(x1, y1, z1, x2, y2, z2), which returns the minimum distance between periodic copies of the points (x1, y1, z1) and (x2, y2, z2). For example, the force given above would be rewritten as CustomExternalForce* force = new CustomExternalForce("k*periodicdistance(x, y, z, x0, y0, z0)^2"); Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. __init__(self, energy) → CustomExternalForceÂ¶ __init__(self, other) → CustomExternalForce Create a CustomExternalForce. Parameters energy (string) â an algebraic expression giving the potential energy of each particle as a function of its x, y, and z coordinates Methods __init__(->Â CustomExternalForce) Create a CustomExternalForce. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addParticle(self,Â particle[,Â parameters]) Add a particle term to the force field. addPerParticleParameter(self,Â name) Add a new per-particle parameter that the force may depend on. getEnergyFunction(self) Get the algebraic expression that gives the potential energy of each particle getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNumGlobalParameters(self) Get the number of global parameters that the force depends on. getNumParticles(self) Get the number of particles for which force field parameters have been defined. getNumPerParticleParameters(self) Get the number of per-particle parameters that the force depends on getParticleParameters(self,Â index) Get the force field parameters for a force field term. getPerParticleParameterName(self,Â index) Get the name of a per-particle parameter. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the potential energy of each particle setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setParticleParameters(self,Â index,Â particle) Set the force field parameters for a force field term. setPerParticleParameterName(self,Â index,Â name) Set the name of a per-particle parameter. updateParametersInContext(self,Â context) Update the per-particle parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles for which force field parameters have been defined. getNumPerParticleParameters(self) → intÂ¶ Get the number of per-particle parameters that the force depends on getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the force depends on. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the potential energy of each particle setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the potential energy of each particle addPerParticleParameter(self, name) → intÂ¶ Add a new per-particle parameter that the force may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerParticleParameterName(self, index) → std::string const &Â¶ Get the name of a per-particle parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerParticleParameterName(self, index, name)Â¶ Set the name of a per-particle parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addParticle(self, particle, parameters=std::vector< double >()) → intÂ¶ Add a particle term to the force field. Parameters particle (int) â the index of the particle this term is applied to parameters (vector< double >) â the list of parameters for the new force term Returns the index of the particle term that was added Return type int getParticleParameters(self, index)Â¶ Get the force field parameters for a force field term. Parameters index (int) â the index of the particle term for which to get parameters Returns particle (int) â the index of the particle this term is applied to parameters (vector< double >) â the list of parameters for the force field term setParticleParameters(self, index, particle, parameters=std::vector< double >())Â¶ Set the force field parameters for a force field term. Parameters index (int) â the index of the particle term for which to set parameters particle (int) â the index of the particle this term is applied to parameters (vector< double >) â the list of parameters for the force field term updateParametersInContext(self, context)Â¶ Update the per-particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-particle parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. Also, this method cannot be used to add new particles, only to change the parameters of existing ones. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns false Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomGBForce.html:
CustomGBForceÂ¶ class openmm.openmm.CustomGBForce(*args)Â¶ This class implements complex, multiple stage nonbonded interactions between particles. It is designed primarily for implementing Generalized Born implicit solvation models, although it is not strictly limited to that purpose. The interaction is specified as a series of computations, each defined by an arbitrary algebraic expression. It also allows tabulated functions to be defined and used with the computations. It optionally supports periodic boundary conditions and cutoffs for long range interactions. The computation consists of calculating some number of per-particle computed values, followed by one or more energy terms. A computed value is a scalar value that is computed for each particle in the system. It may depend on an arbitrary set of global and per-particle parameters, and well as on other computed values that have been calculated before it. Once all computed values have been calculated, the energy terms and their derivatives are evaluated to determine the system energy and particle forces. The energy terms may depend on global parameters, per-particle parameters, and per-particle computed values. When specifying a computed value or energy term, you provide an algebraic expression to evaluate and a computation type describing how the expression is to be evaluated. There are two main types of computations: Single Particle: The expression is evaluated once for each particle in the System. In the case of a computed value, this means the value for a particle depends only on other properties of that particle (its position, parameters, and other computed values). In the case of an energy term, it means each particle makes an independent contribution to the System energy. Particle Pairs: The expression is evaluated for every pair of particles in the system. In the case of a computed value, the value for a particular particle is calculated by pairing it with every other particle in the system, evaluating the expression for each pair, and summing them. For an energy term, each particle pair makes an independent contribution to the System energy. (Note that energy terms are assumed to be symmetric with respect to the two interacting particles, and therefore are evaluated only once per pair. In contrast, expressions for computed values need not be symmetric and therefore are calculated twice for each pair: once when calculating the value for the first particle, and again when calculating the value for the second particle.) Be aware that, although this class is extremely general in the computations it can define, particular Platforms may only support more restricted types of computations. In particular, all currently existing Platforms require that the first computed value _must_ be a particle pair computation, and all computed values after the first _must_ be single particle computations. This is sufficient for most Generalized Born models, but might not permit some other types of calculations to be implemented. This is a complicated class to use, and an example may help to clarify it. The following code implements the OBC variant of the GB/SA solvation model, using the ACE approximation to estimate surface area: CustomGBForce* custom = new CustomGBForce(); custom->addPerParticleParameter("q"); custom->addPerParticleParameter("radius"); custom->addPerParticleParameter("scale"); custom->addGlobalParameter("solventDielectric", obc->getSolventDielectric()); custom->addGlobalParameter("soluteDielectric", obc->getSoluteDielectric()); custom->addComputedValue("I", "step(r+sr2-or1)*0.5*(1/L-1/U+0.25*(1/U^2-1/L^2)*(r-sr2*sr2/r)+0.5*log(L/U)/r+C);" "U=r+sr2;" "C=2*(1/or1-1/L)*step(sr2-r-or1);" "L=max(or1, D);" "D=abs(r-sr2);" "sr2 = scale2*or2;" "or1 = radius1-0.009; or2 = radius2-0.009", CustomGBForce::ParticlePairNoExclusions); custom->addComputedValue("B", "1/(1/or-tanh(1*psi-0.8*psi^2+4.85*psi^3)/radius);" "psi=I*or; or=radius-0.009", CustomGBForce::SingleParticle); custom->addEnergyTerm("28.3919551*(radius+0.14)^2*(radius/B)^6-0.5*138.935456*(1/soluteDielectric-1/solventDielectric)*q^2/B", CustomGBForce::SingleParticle); custom->addEnergyTerm("-138.935456*(1/soluteDielectric-1/solventDielectric)*q1*q2/f;" "f=sqrt(r^2+B1*B2*exp(-r^2/(4*B1*B2)))", CustomGBForce::ParticlePair); It begins by defining three per-particle parameters (charge, atomic radius, and scale factor) and two global parameters (the dielectric constants for the solute and solvent). It then defines a computed value âIâ of type ParticlePair. The expression for evaluating it is a complicated function of the distance between each pair of particles (r), their atomic radii (radius1 and radius2), and their scale factors (scale1 and scale2). Very roughly speaking, it is a measure of the distance between each particle and other nearby particles. Next a computation is defined for the Born Radius (B). It is computed independently for each particle, and is a function of that particleâs atomic radius and the intermediate value I defined above. Finally, two energy terms are defined. The first one is computed for each particle and represents the surface area term, as well as the self interaction part of the polarization energy. The second term is calculated for each pair of particles, and represents the screening of electrostatic interactions by the solvent. After defining the force as shown above, you should then call addParticle() once for each particle in the System to set the values of its per-particle parameters (q, radius, and scale). The number of particles for which you set parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). CustomGBForce also lets you specify âexclusionsâ, particular pairs of particles whose interactions should be omitted from calculations. This is most often used for particles that are bonded to each other. Even if you specify exclusions, however, you can use the computation type ParticlePairNoExclusions to indicate that exclusions should not be applied to a particular piece of the computation. This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. In expressions for particle pair calculations, the names of per-particle parameters and computed values have the suffix â1â or â2â appended to them to indicate the values for the two interacting particles. As seen in the above example, an expression may also involve intermediate quantities that are defined following the main expression, using â;â as a separator. In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in expressions. __init__(self) → CustomGBForceÂ¶ __init__(self, other) → CustomGBForce Create a CustomGBForce. Methods __init__(->Â CustomGBForce) Create a CustomGBForce. addComputedValue(self,Â name,Â expression,Â type) Add a computed value to calculate for each particle. addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addEnergyTerm(self,Â expression,Â type) Add a term to the energy computation. addExclusion(self,Â particle1,Â particle2) Add a particle pair to the list of interactions that should be excluded. addFunction(self,Â name,Â values,Â min,Â max) Add a tabulated function that may appear in expressions. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addParticle(self[,Â parameters]) Add the nonbonded force parameters for a particle. addPerParticleParameter(self,Â name) Add a new per-particle parameter that the interaction may depend on. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in expressions. getComputedValueParameters(self,Â index) Get the properties of a computed value. getCutoffDistance(self) Get the cutoff distance (in nm) being used for nonbonded interactions. getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getEnergyTermParameters(self,Â index) Get the properties of a term to the energy computation. getExclusionParticles(self,Â index) Get the particles in a pair whose interaction should be excluded. getForceGroup(self) Get the force group this Force belongs to. getFunctionParameters(self,Â index) Get the parameters for a tabulated function that may appear in expressions. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long range nonbonded interactions. getNumComputedValues(self) Get the number of per-particle computed values the interaction depends on. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumEnergyTerms(self) Get the number of terms in the energy computation. getNumExclusions(self) Get the number of particle pairs whose interactions should be excluded. getNumFunctions(self) Get the number of tabulated functions that have been defined. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumParticles(self) Get the number of particles for which force field parameters have been defined. getNumPerParticleParameters(self) Get the number of per-particle parameters that the interaction depends on. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getParticleParameters(self,Â index) Get the nonbonded force parameters for a particle. getPerParticleParameterName(self,Â index) Get the name of a per-particle parameter. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in expressions. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in expressions. setComputedValueParameters(self,Â index,Â â¦) Set the properties of a computed value. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for nonbonded interactions. setEnergyTermParameters(self,Â index,Â â¦) Set the properties of a term to the energy computation. setExclusionParticles(self,Â index,Â â¦) Set the particles in a pair whose interaction should be excluded. setForceGroup(self,Â group) Set the force group this Force belongs to. setFunctionParameters(self,Â index,Â name,Â â¦) Set the parameters for a tabulated function that may appear in expressions. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long range nonbonded interactions. setParticleParameters(self,Â index,Â parameters) Set the nonbonded force parameters for a particle. setPerParticleParameterName(self,Â index,Â name) Set the name of a per-particle parameter. updateParametersInContext(self,Â context) Update the per-particle parameters and tabulated functions in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes CutoffNonPeriodic CutoffPeriodic NoCutoff ParticlePair ParticlePairNoExclusions SingleParticle thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles for which force field parameters have been defined. getNumExclusions(self) → intÂ¶ Get the number of particle pairs whose interactions should be excluded. getNumPerParticleParameters(self) → intÂ¶ Get the number of per-particle parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getNumFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. Deprecated This method exists only for backward compatibility. Use getNumTabulatedFunctions() instead. getNumComputedValues(self) → intÂ¶ Get the number of per-particle computed values the interaction depends on. getNumEnergyTerms(self) → intÂ¶ Get the number of terms in the energy computation. getNonbondedMethod(self) → OpenMM::CustomGBForce::NonbondedMethodÂ¶ Get the method used for handling long range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long range nonbonded interactions. getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm addPerParticleParameter(self, name) → intÂ¶ Add a new per-particle parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerParticleParameterName(self, index) → std::string const &Â¶ Get the name of a per-particle parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerParticleParameterName(self, index, name)Â¶ Set the name of a per-particle parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string addParticle(self, parameters=std::vector< double >()) → intÂ¶ Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. Parameters parameters (vector< double >) â the list of parameters for the new particle Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to get parameters Returns parameters â the list of parameters for the specified particle Return type vector< double > setParticleParameters(self, index, parameters)Â¶ Set the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to set parameters parameters (vector< double >) â the list of parameters for the specified particle addComputedValue(self, name, expression, type) → intÂ¶ Add a computed value to calculate for each particle. Parameters name (string) â the name of the value expression (string) â an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append â1â to a variable name to indicate the parameter for the particle whose value is being calculated, and â2â to indicate the particle it is interacting with. type (ComputationType) â the method to use for computing this value getComputedValueParameters(self, index)Â¶ Get the properties of a computed value. Parameters index (int) â the index of the computed value for which to get parameters Returns name (string) â the name of the value expression (string) â an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append â1â to a variable name to indicate the parameter for the particle whose value is being calculated, and â2â to indicate the particle it is interacting with. type (ComputationType) â the method to use for computing this value setComputedValueParameters(self, index, name, expression, type)Â¶ Set the properties of a computed value. Parameters index (int) â the index of the computed value for which to set parameters name (string) â the name of the value expression (string) â an algebraic expression to evaluate when calculating the computed value. If the ComputationType is SingleParticle, the expression is evaluated independently for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and previous computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every other particle in the system and summed to get the final value. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and previous computed values for each of them. Append â1â to a variable name to indicate the parameter for the particle whose value is being calculated, and â2â to indicate the particle it is interacting with. type (ComputationType) â the method to use for computing this value addEnergyTerm(self, expression, type) → intÂ¶ Add a term to the energy computation. Parameters expression (string) â an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append â1â to a variable name to indicate the parameter for the first particle in the pair and â2â to indicate the second particle in the pair. type (ComputationType) â the method to use for computing this value getEnergyTermParameters(self, index)Â¶ Get the properties of a term to the energy computation. Parameters index (int) â the index of the term for which to get parameters Returns expression (string) â an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append â1â to a variable name to indicate the parameter for the first particle in the pair and â2â to indicate the second particle in the pair. type (ComputationType) â the method to use for computing this value setEnergyTermParameters(self, index, expression, type)Â¶ Set the properties of a term to the energy computation. Parameters index (int) â the index of the term for which to set parameters expression (string) â an algebraic expression to evaluate when calculating the energy. If the ComputationType is SingleParticle, the expression is evaluated once for each particle, and may depend on its x, y, and z coordinates, as well as the per-particle parameters and computed values for that particle. If the ComputationType is ParticlePair or ParticlePairNoExclusions, the expression is evaluated once for every pair of particles in the system. In the latter case, the expression may depend on the distance r between the two particles, and on the per-particle parameters and computed values for each of them. Append â1â to a variable name to indicate the parameter for the first particle in the pair and â2â to indicate the second particle in the pair. type (ComputationType) â the method to use for computing this value addExclusion(self, particle1, particle2) → intÂ¶ Add a particle pair to the list of interactions that should be excluded. Parameters particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair Returns the index of the exclusion that was added Return type int getExclusionParticles(self, index)Â¶ Get the particles in a pair whose interaction should be excluded. Parameters index (int) â the index of the exclusion for which to get particle indices Returns particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair setExclusionParticles(self, index, particle1, particle2)Â¶ Set the particles in a pair whose interaction should be excluded. Parameters index (int) â the index of the exclusion for which to set particle indices particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in expressions. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted. Returns the index of the function that was added Return type int getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string addFunction(self, name, values, min, max) → intÂ¶ Add a tabulated function that may appear in expressions. Deprecated This method exists only for backward compatibility. Use addTabulatedFunction() instead. getFunctionParameters(self, index)Â¶ Get the parameters for a tabulated function that may appear in expressions. Deprecated This method exists only for backward compatibility. Use getTabulatedFunctionParameters() instead. If the specified function is not a Continuous1DFunction, this throws an exception. setFunctionParameters(self, index, name, values, min, max)Â¶ Set the parameters for a tabulated function that may appear in expressions. Deprecated This method exists only for backward compatibility. Use setTabulatedFunctionParameters() instead. If the specified function is not a Continuous1DFunction, this throws an exception. updateParametersInContext(self, context)Â¶ Update the per-particle parameters and tabulated functions in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-particle parameters and tabulated functions. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. Also, this method cannot be used to add new particles, only to change the parameters of existing ones. While the tabulated values of a function can change, everything else about it (its dimensions, the data range) must not be changed. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomHbondForce.html:
CustomHbondForceÂ¶ class openmm.openmm.CustomHbondForce(*args)Â¶ This class supports a wide variety of energy functions used to represent hydrogen bonding. It computes interactions between âdonorâ particle groups and âacceptorâ particle groups, where each group may include up to three particles. Typically a donor group consists of a hydrogen atom and the atoms it is bonded to, and an acceptor group consists of a negatively charged atom and the atoms it is bonded to. We refer to the particles in a donor group as d1, d2 and d3, and the particles in an acceptor group as a1, a2, and a3. For each donor and each acceptor, CustomHbondForce evaluates a user supplied algebraic expression to determine the interaction energy. The expression may depend on arbitrary distances, angles, and dihedral angles defined by any of the six particles involved. The function distance(p1, p2) is the distance between the particles p1 and p2 (where âp1â and âp2â should be replaced by the names of the actual particles to calculate the distance between), angle(p1, p2, p3) is the angle formed by the three specified particles, and dihedral(p1, p2, p3, p4) is the dihedral angle formed by the four specified particles. The expression also may involve tabulated functions, and may depend on arbitrary global, per-donor, and per-acceptor parameters. It also optionally supports periodic boundary conditions and cutoffs for long range interactions. To use this class, create a CustomHbondForce object, passing an algebraic expression to the constructor that defines the interaction energy between each donor and acceptor. Then call addPerDonorParameter() to define per-donor parameters, addPerAcceptorParameter() to define per-acceptor parameters, and addGlobalParameter() to define global parameters. The values of per-donor and per-acceptor parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Next, call addDonor() and addAcceptor() to define donors and acceptors and specify their parameter values. After a donor or acceptor has been added, you can modify its parameters by calling setDonorParameters() or setAcceptorParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). CustomHbondForce also lets you specify âexclusionsâ, particular combinations of donors and acceptors whose interactions should be omitted from force and energy calculations. This is most often used for particles that are bonded to each other. As an example, the following code creates a CustomHbondForce that implements a simple harmonic potential to keep the distance between a1 and d1, and the angle formed by a1-d1-d2, near ideal values: CustomHbondForce* force = new CustomHbondForce("k*(distance(a1,d1)-r0)^2*(angle(a1,d1,d2)-theta0)^2"); This force depends on three parameters: k, r0, and theta0. The following code defines these as per-donor parameters: force->addPerDonorParameter("k"); force->addPerDonorParameter("r0"); force->addPerDonorParameter("theta0"); Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression. __init__(self, energy) → CustomHbondForceÂ¶ __init__(self, other) → CustomHbondForce Create a CustomHbondForce. Parameters energy (string) â an algebraic expression giving the interaction energy between a donor and an acceptor as a function of inter-particle distances, angles, and dihedrals, as well as any global, per-donor, and per-acceptor parameters Methods __init__(->Â CustomHbondForce) Create a CustomHbondForce. addAcceptor(self,Â a1,Â a2,Â a3[,Â parameters]) Add an acceptor group to the force addDonor(self,Â d1,Â d2,Â d3[,Â parameters]) Add a donor group to the force addExclusion(self,Â donor,Â acceptor) Add a donor-acceptor pair to the list of interactions that should be excluded. addFunction(self,Â name,Â values,Â min,Â max) Add a tabulated function that may appear in the energy expression. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addPerAcceptorParameter(self,Â name) Add a new per-acceptor parameter that the interaction may depend on. addPerDonorParameter(self,Â name) Add a new per-donor parameter that the interaction may depend on. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in the energy expression. getAcceptorParameters(self,Â index) Get the properties of an acceptor group. getCutoffDistance(self) Get the cutoff distance (in nm) being used. getDonorParameters(self,Â index) Get the properties of a donor group. getEnergyFunction(self) Get the algebraic expression that gives the interaction energy between a donor and an acceptor getExclusionParticles(self,Â index) Get the donor and acceptor in a pair whose interaction should be excluded. getForceGroup(self) Get the force group this Force belongs to. getFunctionParameters(self,Â index) Get the parameters for a tabulated function that may appear in the energy expression. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long range nonbonded interactions. getNumAcceptors(self) Get the number of acceptors for which force field parameters have been defined. getNumDonors(self) Get the number of donors for which force field parameters have been defined. getNumExclusions(self) Get the number of donor-acceptor pairs whose interactions should be excluded. getNumFunctions(self) Get the number of tabulated functions that have been defined. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumPerAcceptorParameters(self) Get the number of per-acceptor parameters that the interaction depends on. getNumPerDonorParameters(self) Get the number of per-donor parameters that the interaction depends on. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerAcceptorParameterName(self,Â index) Get the name of a per-acceptor parameter. getPerDonorParameterName(self,Â index) Get the name of a per-donor parameter. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in the energy expression. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in the energy expression. setAcceptorParameters(self,Â index,Â a1,Â a2,Â a3) Set the properties of an acceptor group. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used. setDonorParameters(self,Â index,Â d1,Â d2,Â d3) Set the properties of a donor group. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the interaction energy between a donor and an acceptor setExclusionParticles(self,Â index,Â donor,Â â¦) Get the donor and acceptor in a pair whose interaction should be excluded. setForceGroup(self,Â group) Set the force group this Force belongs to. setFunctionParameters(self,Â index,Â name,Â â¦) Set the parameters for a tabulated function that may appear in the energy expression. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long range nonbonded interactions. setPerAcceptorParameterName(self,Â index,Â name) Set the name of a per-acceptor parameter. setPerDonorParameterName(self,Â index,Â name) Set the name of a per-donor parameter. updateParametersInContext(self,Â context) Update the per-donor and per-acceptor parameters and tabulated functions in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes CutoffNonPeriodic CutoffPeriodic NoCutoff thisown The membership flag property thisownÂ¶ The membership flag getNumDonors(self) → intÂ¶ Get the number of donors for which force field parameters have been defined. getNumAcceptors(self) → intÂ¶ Get the number of acceptors for which force field parameters have been defined. getNumExclusions(self) → intÂ¶ Get the number of donor-acceptor pairs whose interactions should be excluded. getNumPerDonorParameters(self) → intÂ¶ Get the number of per-donor parameters that the interaction depends on. getNumPerAcceptorParameters(self) → intÂ¶ Get the number of per-acceptor parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getNumFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. Deprecated This method exists only for backward compatibility. Use getNumTabulatedFunctions() instead. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the interaction energy between a donor and an acceptor setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the interaction energy between a donor and an acceptor getNonbondedMethod(self) → OpenMM::CustomHbondForce::NonbondedMethodÂ¶ Get the method used for handling long range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long range nonbonded interactions. getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used. All interactions for which the distance between d1 and a1 is greater than the cutoff will be ignored. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used. All interactions for which the distance between d1 and a1 is greater than the cutoff will be ignored. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm addPerDonorParameter(self, name) → intÂ¶ Add a new per-donor parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerDonorParameterName(self, index) → std::string const &Â¶ Get the name of a per-donor parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerDonorParameterName(self, index, name)Â¶ Set the name of a per-donor parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addPerAcceptorParameter(self, name) → intÂ¶ Add a new per-acceptor parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerAcceptorParameterName(self, index) → std::string const &Â¶ Get the name of a per-acceptor parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerAcceptorParameterName(self, index, name)Â¶ Set the name of a per-acceptor parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addDonor(self, d1, d2, d3, parameters=std::vector< double >()) → intÂ¶ Add a donor group to the force Parameters d1 (int) â the index of the first particle for this donor group d2 (int) â the index of the second particle for this donor group. If the group only includes one particle, this must be -1. d3 (int) â the index of the third particle for this donor group. If the group includes less than three particles, this must be -1. parameters (vector< double >) â the list of per-donor parameter values for the new donor Returns the index of the donor that was added Return type int getDonorParameters(self, index)Â¶ Get the properties of a donor group. Parameters index (int) â the index of the donor group to get Returns d1 (int) â the index of the first particle for this donor group d2 (int) â the index of the second particle for this donor group. If the group only includes one particle, this will be -1. d3 (int) â the index of the third particle for this donor group. If the group includes less than three particles, this will be -1. parameters (vector< double >) â the list of per-donor parameter values for the donor setDonorParameters(self, index, d1, d2, d3, parameters=std::vector< double >())Â¶ Set the properties of a donor group. Parameters index (int) â the index of the donor group to set d1 (int) â the index of the first particle for this donor group d2 (int) â the index of the second particle for this donor group. If the group only includes one particle, this must be -1. d3 (int) â the index of the third particle for this donor group. If the group includes less than three particles, this must be -1. parameters (vector< double >) â the list of per-donor parameter values for the donor addAcceptor(self, a1, a2, a3, parameters=std::vector< double >()) → intÂ¶ Add an acceptor group to the force Parameters a1 (int) â the index of the first particle for this acceptor group a2 (int) â the index of the second particle for this acceptor group. If the group only includes one particle, this must be -1. a3 (int) â the index of the third particle for this acceptor group. If the group includes less than three particles, this must be -1. parameters (vector< double >) â the list of per-acceptor parameter values for the new acceptor Returns the index of the acceptor that was added Return type int getAcceptorParameters(self, index)Â¶ Get the properties of an acceptor group. Parameters index (int) â the index of the acceptor group to get Returns a1 (int) â the index of the first particle for this acceptor group a2 (int) â the index of the second particle for this acceptor group. If the group only includes one particle, this will be -1. a3 (int) â the index of the third particle for this acceptor group. If the group includes less than three particles, this will be -1. parameters (vector< double >) â the list of per-acceptor parameter values for the acceptor setAcceptorParameters(self, index, a1, a2, a3, parameters=std::vector< double >())Â¶ Set the properties of an acceptor group. Parameters index (int) â the index of the acceptor group to set a1 (int) â the index of the first particle for this acceptor group a2 (int) â the index of the second particle for this acceptor group. If the group only includes one particle, this must be -1. a3 (int) â the index of the third particle for this acceptor group. If the group includes less than three particles, this must be -1. parameters (vector< double >) â the list of per-acceptor parameter values for the acceptor addExclusion(self, donor, acceptor) → intÂ¶ Add a donor-acceptor pair to the list of interactions that should be excluded. Parameters donor (int) â the index of the donor to exclude acceptor (int) â the index of the acceptor to exclude Returns the index of the exclusion that was added Return type int getExclusionParticles(self, index)Â¶ Get the donor and acceptor in a pair whose interaction should be excluded. Parameters index (int) â the index of the exclusion for which to get donor and acceptor indices Returns donor (int) â the index of the donor acceptor (int) â the index of the acceptor setExclusionParticles(self, index, donor, acceptor)Â¶ Get the donor and acceptor in a pair whose interaction should be excluded. Parameters index (int) â the index of the exclusion for which to get donor and acceptor indices donor (int) â the index of the donor acceptor (int) â the index of the acceptor addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in the energy expression. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted. Returns the index of the function that was added Return type int getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string addFunction(self, name, values, min, max) → intÂ¶ Add a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Use addTabulatedFunction() instead. getFunctionParameters(self, index)Â¶ Get the parameters for a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Use getTabulatedFunctionParameters() instead. If the specified function is not a Continuous1DFunction, this throws an exception. setFunctionParameters(self, index, name, values, min, max)Â¶ Set the parameters for a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Use setTabulatedFunctionParameters() instead. If the specified function is not a Continuous1DFunction, this throws an exception. updateParametersInContext(self, context)Â¶ Update the per-donor and per-acceptor parameters and tabulated functions in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setDonorParameters() and setAcceptorParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-donor and per-acceptor parameters and tabulated functions. All other aspects of the Force (the energy function, nonbonded method, cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a donor or acceptor cannot be changed, nor can new donors or acceptors be added. While the tabulated values of a function can change, everything else about it (its dimensions, the data range) must not be changed. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomIntegrator.html:
CustomIntegratorÂ¶ class openmm.openmm.CustomIntegrator(*args)Â¶ This is an Integrator that can be used to implemented arbitrary, user defined integration algorithms. It is flexible enough to support a wide range of methods including both deterministic and stochastic integrators, Metropolized integrators, and integrators that must integrate additional quantities along with the particle positions and momenta. To create an integration algorithm, you first define a set of variables the integrator will compute. Variables come in two types: global variables have a single value, while per-DOF variables have a value for every degree of freedom (x, y, or z coordinate of a particle). You can define as many variables as you want of each type. The value of any variable can be computed by the integration algorithm, or set directly by calling a method on the CustomIntegrator. All variables are persistent between integration steps; once a value is set, it keeps that value until it is changed by the user or recomputed in a later integration step. Next, you define the algorithm as a series of computations. To execute a time step, the integrator performs the list of computations in order. Each computation updates the value of one global or per-DOF value. There are several types of computations that can be done: Global: You provide a mathematical expression involving only global variables. It is evaluated and stored into a global variable. Per-DOF: You provide a mathematical expression involving both global and per-DOF variables. It is evaluated once for every degree of freedom, and the values are stored into a per-DOF variable. Sum: You provide a mathematical expression involving both global and per-DOF variables. It is evaluated once for every degree of freedom. All of those values are then added together, and the sum is stored into a global variable. Constrain Positions: The particle positions are updated so that all distance constraints are satisfied. Constrain Velocities: The particle velocities are updated so the net velocity along any constrained distance is 0. Like all integrators, CustomIntegrator ignores any particle whose mass is 0. It is skipped when doing per-DOF computations, and is not included when computing sums over degrees of freedom. In addition to the variables you define by calling addGlobalVariable() and addPerDofVariable(), the integrator provides the following pre-defined variables: dt: (global) This is the step size being used by the integrator. energy: (global, read-only) This is the current potential energy of the system. energy0, energy1, energy2, â¦: (global, read-only) This is similar to energy, but includes only the contribution from forces in one force group. A single computation step may only depend on a single energy variable (energy, energy0, energy1, etc.). x: (per-DOF) This is the current value of the degree of freedom (the x, y, or z coordinate of a particle). v: (per-DOF) This is the current velocity associated with the degree of freedom (the x, y, or z component of a particleâs velocity). f: (per-DOF, read-only) This is the current force acting on the degree of freedom (the x, y, or z component of the force on a particle). f0, f1, f2, â¦: (per-DOF, read-only) This is similar to f, but includes only the contribution from forces in one force group. A single computation step may only depend on a single force variable (f, f0, f1, etc.). m: (per-DOF, read-only) This is the mass of the particle the degree of freedom is associated with. uniform: (either global or per-DOF, read-only) This is a uniformly distributed random number between 0 and 1. Every time an expression is evaluated, a different value will be used. When used in a per-DOF expression, a different value will be used for every degree of freedom. Note, however, that if this variable appears multiple times in a single expression, the same value is used everywhere it appears in that expression. gaussian: (either global or per-DOF, read-only) This is a Gaussian distributed random number with mean 0 and variance 1. Every time an expression is evaluated, a different value will be used. When used in a per-DOF expression, a different value will be used for every degree of freedom. Note, however, that if this variable appears multiple times in a single expression, the same value is used everywhere it appears in that expression. A global variable is created for every adjustable parameter defined in the integratorâs Context. The following example uses a CustomIntegrator to implement a velocity Verlet integrator: CustomIntegrator integrator(0.001); integrator.addComputePerDof("v", "v+0.5*dt*f/m"); integrator.addComputePerDof("x", "x+dt*v"); integrator.addComputePerDof("v", "v+0.5*dt*f/m"); The first step updates the velocities based on the current forces. The second step updates the positions based on the new velocities, and the third step updates the velocities again. Although the first and third steps look identical, the forces used in them are different. You do not need to tell the integrator that; it will recognize that the positions have changed and know to recompute the forces automatically. The above example has two problems. First, it does not respect distance constraints. To make the integrator work with constraints, you need to add extra steps to tell it when and how to apply them. Second, it never gives Forces an opportunity to update the context state. This should be done every time step so that, for example, an AndersenThermostat can randomize velocities or a MonteCarloBarostat can scale particle positions. You need to add a step to tell the integrator when to do this. The following example corrects both these problems, using the RATTLE algorithm to apply constraints: CustomIntegrator integrator(0.001); integrator.addPerDofVariable("x1", 0); integrator.addUpdateContextState(); integrator.addComputePerDof("v", "v+0.5*dt*f/m"); integrator.addComputePerDof("x", "x+dt*v"); integrator.addComputePerDof("x1", "x"); integrator.addConstrainPositions(); integrator.addComputePerDof("v", "v+0.5*dt*f/m+(x-x1)/dt"); integrator.addConstrainVelocities(); CustomIntegrator can be used to implement multiple time step integrators. The following example shows an r-RESPA integrator. It assumes the quickly changing forces are in force group 0 and the slowly changing ones are in force group 1. It evaluates the âfastâ forces four times as often as the âslowâ forces. CustomIntegrator integrator(0.004); integrator.addComputePerDof("v", "v+0.5*dt*f1/m"); for (int i = 0; i &lt; 4; i++) { integrator.addComputePerDof("v", "v+0.5*(dt/4)*f0/m"); integrator.addComputePerDof("x", "x+(dt/4)*v"); integrator.addComputePerDof("v", "v+0.5*(dt/4)*f0/m"); } integrator.addComputePerDof("v", "v+0.5*dt*f1/m"); The sequence of computations in a CustomIntegrator can include flow control in the form of âifâ and âwhileâ blocks. The computations inside an âifâ block are executed either zero or one times, depending on whether a condition is true. The computations inside a âwhileâ block are executed repeatedly for as long as the condition remains true. Be very careful when writing âwhileâ blocks; there is nothing to stop you from creating an infinite loop! For example, suppose you are writing a Monte Carlo algorithm. Assume you have already computed a new set of particle coordinates âxnewâ and a step acceptance probability âacceptanceProbabilityâ. The following lines use an âifâ block to decide whether to accept the step, and if it is accepted, store the new positions into âxâ. integrator.beginIfBlock("uniform < acceptanceProbability"); integrator.addComputePerDof("x", "xnew"); integrator.endBlock(); The condition in an âifâ or âwhileâ block is evaluated globally, so it may only involve global variables, not per-DOF ones. It may use any of the following comparison operators: =, <. >, !=, <=, >=. Blocks may be nested inside each other. âPer-DOFâ computations can also be thought of as per-particle computations that operate on three component vectors. For example, âx+dt*vâ means to take the particleâs velocity (a vector), multiply it by the step size, and add the position (also a vector). The result is a new vector that can be stored into a per-DOF variable with addComputePerDof(), or it can be summed over all components of all particles with addComputeSum(). Because the calculation is done on vectors, you can use functions that operate explicitly on vectors rather than just computing each component independently. For example, the following line uses a cross product to compute the angular momentum of each particle and stores it into a per-DOF variable. integrator.addComputePerDof("angularMomentum", "m*cross(x, v)"); Here are two more examples that may be useful as starting points for writing your own integrators. The first one implements the algorithm used by the standard VerletIntegrator class. This is a leapfrog algorithm, in contrast to the velocity Verlet algorithm shown above, so it only requires applying constraints once in each time step. CustomIntegrator integrator(dt); integrator.addPerDofVariable("x0", 0); integrator.addUpdateContextState(); integrator.addComputePerDof("x0", "x"); integrator.addComputePerDof("v", "v+dt*f/m"); integrator.addComputePerDof("x", "x+dt*v"); integrator.addConstrainPositions(); integrator.addComputePerDof("v", "(x-x0)/dt"); The second one implements the algorithm used by the standard LangevinMiddleIntegrator class. kB is Boltzmannâs constant. CustomIntegrator integrator(dt); integrator.addGlobalVariable("a", exp(-friction*dt)); integrator.addGlobalVariable("b", sqrt(1-exp(-2*friction*dt))); integrator.addGlobalVariable("kT", kB*temperature); integrator.addPerDofVariable("x1", 0); integrator.addUpdateContextState(); integrator.addComputePerDof("v", "v + dt*f/m"); integrator.addConstrainVelocities(); integrator.addComputePerDof("x", "x + 0.5*dt*v"); integrator.addComputePerDof("v", "a*v + b*sqrt(kT/m)*gaussian"); integrator.addComputePerDof("x", "x + 0.5*dt*v"); integrator.addComputePerDof("x1", "x"); integrator.addConstrainPositions(); integrator.addComputePerDof("v", "v + (x-x1)/dt"); Another feature of CustomIntegrator is that it can use derivatives of the potential energy with respect to context parameters. These derivatives are typically computed by custom forces, and are only computed if a Force object has been specifically told to compute them by calling addEnergyParameterDerivative() on it. CustomIntegrator provides a deriv() function for accessing these derivatives in global or per-DOF expressions. For example, âderiv(energy, lambda)â is the derivative of the total potentially energy with respect to the parameter lambda. You can also restrict it to a single force group by specifying a different variable for the first argument, such as âderiv(energy1, lambda)â. An Integrator has one other job in addition to evolving the equations of motion: it defines how to compute the kinetic energy of the system. Depending on the integration method used, simply summing (mv^2)/2 over all degrees of freedom may not give the correct answer. For example, in a leapfrog integrator the velocities are âdelayedâ by half a time step, so the above formula would give the kinetic energy half a time step ago, not at the current time. Call setKineticEnergyExpression() to set an expression for the kinetic energy. It is computed for every degree of freedom (excluding ones whose mass is 0) and the result is summed. The default expression is âm*v*v/2â, which is correct for many integrators. As example, the following line defines the correct way to compute kinetic energy when using a leapfrog algorithm: integrator.setKineticEnergyExpression("m*v1*v1/2; v1=v+0.5*dt*f/m"); The kinetic energy expression may depend on the following pre-defined variables: x, v, f, m, dt. It also may depend on user-defined global and per-DOF variables, and on the values of adjustable parameters defined in the integratorâs Context. It may not depend on any other variable, such as the potential energy, the force from a single force group, or a random number. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. An expression may also involve intermediate quantities that are defined following the main expression, using â;â as a separator. Expressions used in ComputePerDof and ComputeSum steps can also use the following functions that operate on vectors: cross(a, b) is the cross product of two vectors; dot(a, b) is the dot product of two vectors; _x(a), _y(a), and _z(a) extract a single component from a vector; and vector(a, b, c) creates a new vector with the x component of the first argument, the y component of the second argument, and the z component of the third argument. Remember that every quantity appearing in a vector expression is a vector. Functions that appear to return a scalar really return a vector whose components are all the same. For example, _z(a) returns the vector (a.z, a.z, a.z). Likewise, wherever a constant appears in the expression, it really means a vector whose components all have the same value. In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in expressions. __init__(self, stepSize) → CustomIntegratorÂ¶ __init__(self, other) → CustomIntegrator Create a CustomIntegrator. Parameters stepSize (double) â the step size with which to integrate the system (in picoseconds) Methods __init__(->Â CustomIntegrator) Create a CustomIntegrator. addComputeGlobal(self,Â variable,Â expression) Add a step to the integration algorithm that computes a global value. addComputePerDof(self,Â variable,Â expression) Add a step to the integration algorithm that computes a per-DOF value. addComputeSum(self,Â variable,Â expression) Add a step to the integration algorithm that computes a sum over degrees of freedom. addConstrainPositions(self) Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. addConstrainVelocities(self) Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. addGlobalVariable(self,Â name,Â initialValue) Define a new global variable. addPerDofVariable(self,Â name,Â initialValue) Define a new per-DOF variable. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in expressions. addUpdateContextState(self) Add a step to the integration algorithm that allows Forces to update the context state. beginIfBlock(self,Â condition) Add a step which begins a new âifâ block. beginWhileBlock(self,Â condition) Add a step which begins a new âwhileâ block. endBlock(self) Add a step which marks the end of the most recently begun âifâ or âwhileâ block. getComputationStep(self,Â index) Get the details of a computation step that has been added to the integration algorithm. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getGlobalVariable(self,Â index) Get the current value of a global variable. getGlobalVariableByName(self,Â name) Get the current value of a global variable, specified by name. getGlobalVariableName(self,Â index) Get the name of a global variable. getIntegrationForceGroups(self) Get which force groups to use for integration. getKineticEnergyExpression(self) Get the expression to use for computing the kinetic energy. getNumComputations(self) Get the number of computation steps that have been added. getNumGlobalVariables(self) Get the number of global variables that have been defined. getNumPerDofVariables(self) Get the number of per-DOF variables that have been defined. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getPerDofVariable() getPerDofVariableByName(self,Â name) Get the value of a per-DOF variable, specified by name. getPerDofVariableName(self,Â index) Get the name of a per-DOF variable. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in expressions. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in expressions. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setGlobalVariable(self,Â index,Â value) Set the value of a global variable. setGlobalVariableByName(self,Â name,Â value) Set the value of a global variable, specified by name. setIntegrationForceGroups(groups) Set which force groups to use for integration. setKineticEnergyExpression(self,Â expression) Set the expression to use for computing the kinetic energy. setPerDofVariable(self,Â index,Â values) Set the value of a per-DOF variable. setPerDofVariableByName(self,Â name,Â values) Set the value of a per-DOF variable, specified by name. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes BlockEnd ComputeGlobal ComputePerDof ComputeSum ConstrainPositions ConstrainVelocities IfBlockStart UpdateContextState WhileBlockStart thisown The membership flag property thisownÂ¶ The membership flag getNumGlobalVariables(self) → intÂ¶ Get the number of global variables that have been defined. getNumPerDofVariables(self) → intÂ¶ Get the number of per-DOF variables that have been defined. getNumComputations(self) → intÂ¶ Get the number of computation steps that have been added. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. addGlobalVariable(self, name, initialValue) → intÂ¶ Define a new global variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value Returns the index of the variable that was added Return type int getGlobalVariableName(self, index) → std::string const &Â¶ Get the name of a global variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string addPerDofVariable(self, name, initialValue) → intÂ¶ Define a new per-DOF variable. Parameters name (string) â the name of the variable initialValue (double) â the variable will initially be set to this value for all degrees of freedom Returns the index of the variable that was added Return type int getPerDofVariableName(self, index) → std::string const &Â¶ Get the name of a per-DOF variable. Parameters index (int) â the index of the variable to get Returns the name of the variable Return type string getGlobalVariable(self, index) → doubleÂ¶ Get the current value of a global variable. Parameters index (int) â the index of the variable to get Returns the current value of the variable Return type double getGlobalVariableByName(self, name) → doubleÂ¶ Get the current value of a global variable, specified by name. Parameters name (string) â the name of the variable to get Returns the current value of the parameter Return type double setGlobalVariable(self, index, value)Â¶ Set the value of a global variable. Parameters index (int) â the index of the variable to set value (double) â the new value of the variable setGlobalVariableByName(self, name, value)Â¶ Set the value of a global variable, specified by name. Parameters name (string) â the name of the variable to set value (double) â the new value of the variable getPerDofVariableByName(self, name)Â¶ Get the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to get Returns values â the values of the variable for all degrees of freedom are stored into this Return type vector< Vec3 > setPerDofVariable(self, index, values)Â¶ Set the value of a per-DOF variable. Parameters index (int) â the index of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom setPerDofVariableByName(self, name, values)Â¶ Set the value of a per-DOF variable, specified by name. Parameters name (string) â the name of the variable to set values (vector< Vec3 >) â the new values of the variable for all degrees of freedom addComputeGlobal(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a global value. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving only global variables. In each integration step, its value is computed and stored into the specified variable. Returns the index of the step that was added Return type int addComputePerDof(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a per-DOF value. Parameters variable (string) â the per-DOF variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom and stored into the specified variable. Returns the index of the step that was added Return type int addComputeSum(self, variable, expression) → intÂ¶ Add a step to the integration algorithm that computes a sum over degrees of freedom. Parameters variable (string) â the global variable to store the computed value into expression (string) â a mathematical expression involving both global and per-DOF variables. In each integration step, its value is computed for every degree of freedom. Those values are then added together, and the sum is stored in the specified variable. Returns the index of the step that was added Return type int addConstrainPositions(self) → intÂ¶ Add a step to the integration algorithm that updates particle positions so all constraints are satisfied. Returns the index of the step that was added Return type int addConstrainVelocities(self) → intÂ¶ Add a step to the integration algorithm that updates particle velocities so the net velocity along all constraints is 0. Returns the index of the step that was added Return type int addUpdateContextState(self) → intÂ¶ Add a step to the integration algorithm that allows Forces to update the context state. Returns the index of the step that was added Return type int beginIfBlock(self, condition) → intÂ¶ Add a step which begins a new âifâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed only if the condition is true. Returns the index of the step that was added Return type int beginWhileBlock(self, condition) → intÂ¶ Add a step which begins a new âwhileâ block. Parameters condition (string) â a mathematical expression involving a comparison operator and global variables. All steps between this one and the end of the block are executed repeatedly as long as the condition remains true. Returns the index of the step that was added Return type int endBlock(self) → intÂ¶ Add a step which marks the end of the most recently begun âifâ or âwhileâ block. Returns the index of the step that was added Return type int getComputationStep(self, index)Â¶ Get the details of a computation step that has been added to the integration algorithm. Parameters index (int) â the index of the computation step to get Returns type (ComputationType) â the type of computation this step performs variable (string) â the variable into which this step stores its result. If this step does not store a result in a variable, this will be an empty string. expression (string) â the expression this step evaluates. If this step does not evaluate an expression, this will be an empty string. addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in expressions. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The integrator takes over ownership of it, and deletes it when the integrator itself is deleted. Returns the index of the function that was added Return type int getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in expressions. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string getKineticEnergyExpression(self) → std::string const &Â¶ Get the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. setKineticEnergyExpression(self, expression)Â¶ Set the expression to use for computing the kinetic energy. The expression is evaluated for every degree of freedom. Those values are then added together, and the sum is reported as the current kinetic energy. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random numbers will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take getPerDofVariable(self, index)Â¶ getPerDofVariable(self, index) → PyObject * getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomManyParticleForce.html:
CustomManyParticleForceÂ¶ class openmm.openmm.CustomManyParticleForce(*args)Â¶ This class supports a wide variety of nonbonded N-particle interactions, where N is user specified. The interaction energy is determined by an arbitrary, user specified algebraic expression that is evaluated for every possible set of N particles in the system. It may depend on the positions of the individual particles, the distances between pairs of particles, the angles formed by sets of three particles, and the dihedral angles formed by sets of four particles. Be aware that the cost of evaluating an N-particle interaction increases very rapidly with N. Values larger than N=3 are rarely used. We refer to a set of particles for which the energy is being evaluated as p1, p2, p3, etc. The energy expression may depend on the following variables and functions: x1, y1, z1, x2, y2, z2, etc.: The x, y, and z coordinates of the particle positions. For example, x1 is the x coordinate of particle p1, and y3 is the y coordinate of particle p3. distance(p1, p2): the distance between particles p1 and p2 (where âp1â and âp2â may be replaced by the names of whichever particles you want to calculate the distance between). angle(p1, p2, p3): the angle formed by the three specified particles. dihedral(p1, p2, p3, p4): the dihedral angle formed by the four specified particles. arbitrary global and per-particle parameters that you define. To use this class, create a CustomManyParticleForce object, passing an algebraic expression to the constructor that defines the interaction energy of each set of particles. Then call addPerParticleParameter() to define per-particle parameters, and addGlobalParameter() to define global parameters. The values of per-particle parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Next, call addParticle() once for each particle in the System to set the values of its per-particle parameters. The number of particles for which you set parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). Multi-particle interactions can be very expensive to evaluate, so they are usually used with a cutoff distance. The exact interpretation of the cutoff depends on the permutation mode, as discussed below. CustomManyParticleForce also lets you specify âexclusionsâ, particular pairs of particles whose interactions should be omitted from force and energy calculations. This is most often used for particles that are bonded to each other. If you specify a pair of particles as an exclusion, _all_ sets that include those two particles will be omitted. As an example, the following code creates a CustomManyParticleForce that implements an Axilrod-Teller potential. This is an interaction between three particles that depends on all three distances and angles formed by the particles. CustomManyParticleForce* force = new CustomManyParticleForce(3, "C*(1+3*cos(theta1)*cos(theta2)*cos(theta3))/(r12*r13*r23)^3;" "theta1=angle(p1,p2,p3); theta2=angle(p2,p3,p1); theta3=angle(p3,p1,p2);" "r12=distance(p1,p2); r13=distance(p1,p3); r23=distance(p2,p3)"); force->setPermutationMode(CustomManyParticleForce::SinglePermutation); This force depends on one parameter, C. The following code defines it as a global parameter: force->addGlobalParameter("C", 1.0); Notice that the expression is symmetric with respect to the particles. It only depends on the products cos(theta1)*cos(theta2)*cos(theta3) and r12*r13*r23, both of which are unchanged if the labels p1, p2, and p3 are permuted. This is required because we specified SinglePermutation as the permutation mode. (This is the default, so we did not really need to set it, but doing so makes the example clearer.) In this mode, the expression is only evaluated once for each set of particles. No guarantee is made about which particle will be identified as p1, p2, etc. Therefore, the energy _must_ be symmetric with respect to exchange of particles. Otherwise, the results would be undefined because permuting the labels would change the energy. Not all many-particle interactions work this way. Another common pattern is for the expression to describe an interaction between one central particle and other nearby particles. An example of this is the 3-particle piece of the Stillinger-Weber potential: CustomManyParticleForce* force = new CustomManyParticleForce(3, "L*eps*(cos(theta1)+1/3)^2*exp(sigma*gamma/(r12-a*sigma))*exp(sigma*gamma/(r13-a*sigma));" "r12 = distance(p1,p2); r13 = distance(p1,p3); theta1 = angle(p3,p1,p2)"); force->setPermutationMode(CustomManyParticleForce::UniqueCentralParticle); When the permutation mode is set to UniqueCentralParticle, particle p1 is treated as the central particle. For a set of N particles, the expression is evaluated N times, once with each particle as p1. The expression can therefore treat p1 differently from the other particles. Notice that it is still symmetric with respect to p2 and p3, however. There is no guarantee about how those labels will be assigned to particles. Distance cutoffs are applied in different ways depending on the permutation mode. In SinglePermutation mode, every particle in the set must be within the cutoff distance of every other particle. If _any_ two particles are further apart than the cutoff distance, the interaction is skipped. In UniqueCentralParticle mode, each particle must be within the cutoff distance of the central particle, but not necessarily of all the other particles. The cutoff may therefore exclude a subset of the permutations of a set of particles. Another common situation is that some particles are fundamentally different from others, causing the expression to be inherently non-symmetric. An example would be a water model that involves three particles, two of which _must_ be hydrogen and one of which _must_ be oxygen. Cases like this can be implemented using particle types. A particle type is an integer that you specify when you call addParticle(). (If you omit the argument, it defaults to 0.) For the water model, you could specify 0 for all oxygen atoms and 1 for all hydrogen atoms. You can then call setTypeFilter() to specify the list of allowed types for each of the N particles involved in an interaction: set&lt;int&gt; oxygenTypes, hydrogenTypes; oxygenTypes.insert(0); hydrogenTypes.insert(1); force->setTypeFilter(0, oxygenTypes); force->setTypeFilter(1, hydrogenTypes); force->setTypeFilter(2, hydrogenTypes); This specifies that of the three particles in an interaction, p1 must be oxygen while p2 and p3 must be hydrogen. The energy expression will only be evaluated for triplets of particles that satisfy those requirements. It will still only be evaluated once for each triplet, so it must still be symmetric with respect to p2 and p3. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. The names of per-particle parameters have the suffix â1â, â2â, etc. appended to them to indicate the values for the multiple interacting particles. For example, if you define a per-particle parameter called âchargeâ, then the variable âcharge2â is the charge of particle p2. As seen above, the expression may also involve intermediate quantities that are defined following the main expression, using â;â as a separator. This class also supports the functions pointdistance(x1, y1, z1, x2, y2, z2), pointangle(x1, y1, z1, x2, y2, z2, x3, y3, z3), and pointdihedral(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4). These functions are similar to distance(), angle(), and dihedral(), but the arguments are the coordinates of points to perform the calculation based on rather than the names of particles. This enables more flexible geometric calculations. For example, the following computes the distance from particle p1 to the midpoint between particles p2 and p3. CustomManyParticleForce* force = new CustomManyParticleForce(3, "pointdistance(x1, y1, z1, (x2+x3)/2, (y2+y3)/2, (z2+z3)/2)"); In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression. __init__(self, particlesPerSet, energy) → CustomManyParticleForceÂ¶ __init__(self, other) → CustomManyParticleForce Create a CustomManyParticleForce. Parameters particlesPerSet (int) â the number of particles in each set for which the energy is evaluated energy (string) â an algebraic expression giving the interaction energy of each triplet as a function of particle positions, inter-particle distances, angles, and any global and per-particle parameters Methods __init__(->Â CustomManyParticleForce) Create a CustomManyParticleForce. addExclusion(self,Â particle1,Â particle2) Add a particle pair to the list of interactions that should be excluded. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addParticle(self[,Â parameters,Â type]) Add the nonbonded force parameters for a particle. addPerParticleParameter(self,Â name) Add a new per-particle parameter that the interaction may depend on. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in the energy expression. createExclusionsFromBonds(self,Â bonds,Â â¦) Identify exclusions based on the molecular topology. getCutoffDistance(self) Get the cutoff distance (in nm) being used for nonbonded interactions. getEnergyFunction(self) Get the algebraic expression that gives the interaction energy of each bond getExclusionParticles(self,Â index) Get the particles in a pair whose interaction should be excluded. getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long range nonbonded interactions. getNumExclusions(self) Get the number of particle pairs whose interactions should be excluded. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumParticles(self) Get the number of particles for which force field parameters have been defined. getNumParticlesPerSet(self) Get the number of particles in each set for which the energy is evaluated getNumPerParticleParameters(self) Get the number of per-particle parameters that the interaction depends on. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getParticleParameters(self,Â index) Get the nonbonded force parameters for a particle. getPerParticleParameterName(self,Â index) Get the name of a per-particle parameter. getPermutationMode(self) Get the mode that selects which permutations of a set of particles to evaluate the interaction for. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in the energy expression. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in the energy expression. getTypeFilter(self,Â index) Get the allowed particle types for one of the particles involved in the interaction. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for nonbonded interactions. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the interaction energy of each bond setExclusionParticles(self,Â index,Â â¦) Set the particles in a pair whose interaction should be excluded. setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long range nonbonded interactions. setParticleParameters(self,Â index,Â â¦) Set the nonbonded force parameters for a particle. setPerParticleParameterName(self,Â index,Â name) Set the name of a per-particle parameter. setPermutationMode(self,Â mode) Set the mode that selects which permutations of a set of particles to evaluate the interaction for. setTypeFilter(self,Â index,Â types) Set the allowed particle types for one of the particles involved in the interaction. updateParametersInContext(self,Â context) Update the per-particle parameters and tabulated functions in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes CutoffNonPeriodic CutoffPeriodic NoCutoff SinglePermutation UniqueCentralParticle thisown The membership flag property thisownÂ¶ The membership flag getNumParticlesPerSet(self) → intÂ¶ Get the number of particles in each set for which the energy is evaluated getNumParticles(self) → intÂ¶ Get the number of particles for which force field parameters have been defined. getNumExclusions(self) → intÂ¶ Get the number of particle pairs whose interactions should be excluded. getNumPerParticleParameters(self) → intÂ¶ Get the number of per-particle parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the interaction energy of each bond setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the interaction energy of each bond getNonbondedMethod(self) → OpenMM::CustomManyParticleForce::NonbondedMethodÂ¶ Get the method used for handling long range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long range nonbonded interactions. getPermutationMode(self) → OpenMM::CustomManyParticleForce::PermutationModeÂ¶ Get the mode that selects which permutations of a set of particles to evaluate the interaction for. setPermutationMode(self, mode)Â¶ Set the mode that selects which permutations of a set of particles to evaluate the interaction for. getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm addPerParticleParameter(self, name) → intÂ¶ Add a new per-particle parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerParticleParameterName(self, index) → std::string const &Â¶ Get the name of a per-particle parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerParticleParameterName(self, index, name)Â¶ Set the name of a per-particle parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addParticle(self, parameters=std::vector< double >(), type=0) → intÂ¶ Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. Parameters parameters (vector< double >) â the list of parameters for the new particle type (int) â the type of the new particle Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to get parameters Returns parameters (vector< double >) â the list of parameters for the specified particle type (int) â the type of the specified particle setParticleParameters(self, index, parameters, type)Â¶ Set the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to set parameters parameters (vector< double >) â the list of parameters for the specified particle type (int) â the type of the specified particle addExclusion(self, particle1, particle2) → intÂ¶ Add a particle pair to the list of interactions that should be excluded. In many cases, you can use createExclusionsFromBonds() rather than adding each exclusion explicitly. Parameters particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair Returns the index of the exclusion that was added Return type int getExclusionParticles(self, index)Â¶ Get the particles in a pair whose interaction should be excluded. Parameters index (int) â the index of the exclusion for which to get particle indices Returns particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair setExclusionParticles(self, index, particle1, particle2)Â¶ Set the particles in a pair whose interaction should be excluded. Parameters index (int) â the index of the exclusion for which to set particle indices particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair createExclusionsFromBonds(self, bonds, bondCutoff)Â¶ Identify exclusions based on the molecular topology. Particles which are separated by up to a specified number of bonds are added as exclusions. Parameters bonds (vector< std::pair< int, int > >) â the set of bonds based on which to construct exclusions. Each element specifies the indices of two particles that are bonded to each other. bondCutoff (int) â pairs of particles that are separated by this many bonds or fewer are added to the list of exclusions getTypeFilter(self, index)Â¶ Get the allowed particle types for one of the particles involved in the interaction. If this an empty set (the default), no filter is applied and all interactions are evaluated regardless of the type of the specified particle. Parameters index (int) â the index of the particle within the interaction (between 0 and getNumParticlesPerSet()) Returns types â the allowed types for the specified particle Return type set< int > setTypeFilter(self, index, types)Â¶ Set the allowed particle types for one of the particles involved in the interaction. If this an empty set (the default), no filter is applied and all interactions are evaluated regardless of the type of the specified particle. Parameters index (int) â the index of the particle within the interaction (between 0 and getNumParticlesPerSet()) types (set< int >) â the allowed types for the specified particle addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in the energy expression. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted. Returns the index of the function that was added Return type int getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string updateParametersInContext(self, context)Â¶ Update the per-particle parameters and tabulated functions in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-particle parameters and tabulated functions. All other aspects of the Force (the energy function, nonbonded method, cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Also, this method cannot be used to add new particles, only to change the parameters of existing ones. While the tabulated values of a function can change, everything else about it (its dimensions, the data range) must not be changed. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomNonbondedForce.html:
CustomNonbondedForceÂ¶ class openmm.openmm.CustomNonbondedForce(*args)Â¶ This class implements nonbonded interactions between particles. Unlike NonbondedForce, the functional form of the interaction is completely customizable, and may involve arbitrary algebraic expressions and tabulated functions. It may depend on the distance between particles, as well as on arbitrary global and per-particle parameters. It also optionally supports periodic boundary conditions and cutoffs for long range interactions. To use this class, create a CustomNonbondedForce object, passing an algebraic expression to the constructor that defines the interaction energy between each pair of particles. The expression may depend on r, the distance between the particles, as well as on any parameters you choose. Then call addPerParticleParameter() to define per-particle parameters, and addGlobalParameter() to define global parameters. The values of per-particle parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Next, call addParticle() once for each particle in the System to set the values of its per-particle parameters. The number of particles for which you set parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). CustomNonbondedForce also lets you specify âexclusionsâ, particular pairs of particles whose interactions should be omitted from force and energy calculations. This is most often used for particles that are bonded to each other. As an example, the following code creates a CustomNonbondedForce that implements a 12-6 Lennard-Jones potential: CustomNonbondedForce* force = new CustomNonbondedForce("4*epsilon*((sigma/r)^12-(sigma/r)^6); sigma=0.5*(sigma1+sigma2); epsilon=sqrt(epsilon1*epsilon2)"); This force depends on two parameters: sigma and epsilon. The following code defines these as per-particle parameters: force->addPerParticleParameter("sigma"); force->addPerParticleParameter("epsilon"); The expression _must_ be symmetric with respect to the two particles. It typically will only be evaluated once for each pair of particles, and no guarantee is made about which particle will be identified as âparticle 1â. In the above example, the energy only depends on the products sigma1*sigma2 and epsilon1*epsilon2, both of which are unchanged if the labels 1 and 2 are reversed. In contrast, if it depended on the difference sigma1-sigma2, the results would be undefined, because reversing the labels 1 and 2 would change the energy. The energy also may depend on âcomputed valuesâ. These are similar to per-particle parameters, but instead of being specified in advance, their values are computed based on global and per-particle parameters. For example, the following code uses a global parameter (lambda) to interpolate between two different sigma values for each particle (sigmaA and sigmaB). CustomNonbondedForce* force = new CustomNonbondedForce("4*epsilon*((sigma/r)^12-(sigma/r)^6); sigma=0.5*(sigma1+sigma2); epsilon=sqrt(epsilon1*epsilon2)"); force->addComputedValue("sigma", "(1-lambda)*sigmaA + lambda*sigmaB"); force->addGlobalParameter("lambda", 0); force->addPerParticleParameter("sigmaA"); force->addPerParticleParameter("sigmaB"); force->addPerParticleParameter("epsilon"); You could, of course, embed the computation of sigma directly into the energy expression, but then it would need to be repeated for every interaction. By separating it out as a computed value, it only needs to be computed once for each particle instead of once for each interaction, thus saving computation time. CustomNonbondedForce can operate in two modes. By default, it computes the interaction of every particle in the System with every other particle. Alternatively, you can restrict it to only a subset of particle pairs. To do this, specify one or more âinteraction groupsâ. An interaction group consists of two sets of particles that should interact with each other. Every particle in the first set interacts with every particle in the second set. For example, you might use this feature to compute a solute-solvent interaction energy, while omitting all interactions between two solute atoms or two solvent atoms. To create an interaction group, call addInteractionGroup(). You may add as many interaction groups as you want. Be aware of the following: Exclusions are still taken into account, so the interactions between excluded pairs are omitted. Likewise, a particle will never interact with itself, even if it appears in both sets of an interaction group. If a particle pair appears in two different interaction groups, its interaction will be computed twice. This is sometimes useful, but be aware of it so you do not accidentally create unwanted duplicate interactions. If you do not add any interaction groups to a CustomNonbondedForce, it operates in the default mode where every particle interacts with every other particle. When using a cutoff, by default the interaction is sharply truncated at the cutoff distance. Optionally you can instead use a switching function to make the interaction smoothly go to zero over a finite distance range. To enable this, call setUseSwitchingFunction(). You must also call setSwitchingDistance() to specify the distance at which the interaction should begin to decrease. The switching distance must be less than the cutoff distance. Of course, you could also incorporate the switching function directly into your energy expression, but there are several advantages to keeping it separate. It makes your energy expression simpler to write and understand. It allows you to use the same energy expression with or without a cutoff. Also, when using a long range correction (see below), separating out the switching function allows the correction to be calculated more accurately. Another optional feature of this class is to add a contribution to the energy which approximates the effect of all interactions beyond the cutoff in a periodic system. When running a simulation at constant pressure, this can improve the quality of the result. Call setUseLongRangeCorrection() to enable it. Computing the long range correction takes negligible work in each time step, but it does require an expensive precomputation at the start of the simulation. Furthermore, that precomputation must be repeated every time a global parameter changes (or when you modify per-particle parameters by calling updateParametersInContext()). This means that if parameters change frequently, the long range correction can be very slow. For this reason, it is disabled by default. This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. The names of per-particle parameters have the suffix â1â or â2â appended to them to indicate the values for the two interacting particles. As seen in the above example, the expression may also involve intermediate quantities that are defined following the main expression, using â;â as a separator. In addition, you can call addTabulatedFunction() to define a new function based on tabulated values. You specify the function by creating a TabulatedFunction object. That function can then appear in the expression. __init__(self, energy) → CustomNonbondedForceÂ¶ __init__(self, rhs) → CustomNonbondedForce Create a CustomNonbondedForce. Parameters energy (string) â an algebraic expression giving the interaction energy between two particles as a function of r, the distance between them, as well as any global and per-particle parameters Methods __init__(->Â CustomNonbondedForce) Create a CustomNonbondedForce. addComputedValue(self,Â name,Â expression) Add a computed value to calculate for each particle. addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addExclusion(self,Â particle1,Â particle2) Add a particle pair to the list of interactions that should be excluded. addFunction(self,Â name,Â values,Â min,Â max) Add a tabulated function that may appear in the energy expression. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addInteractionGroup(self,Â set1,Â set2) Add an interaction group. addParticle(self[,Â parameters]) Add the nonbonded force parameters for a particle. addPerParticleParameter(self,Â name) Add a new per-particle parameter that the interaction may depend on. addTabulatedFunction(self,Â name,Â function) Add a tabulated function that may appear in the energy expression. createExclusionsFromBonds(self,Â bonds,Â â¦) Identify exclusions based on the molecular topology. getComputedValueParameters(self,Â index) Get the properties of a computed value. getCutoffDistance(self) Get the cutoff distance (in nm) being used for nonbonded interactions. getEnergyFunction(self) Get the algebraic expression that gives the interaction energy between two particles getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getExclusionParticles(self,Â index) Get the particles in a pair whose interaction should be excluded. getForceGroup(self) Get the force group this Force belongs to. getFunctionParameters(self,Â index) Get the parameters for a tabulated function that may appear in the energy expression. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getInteractionGroupParameters(self,Â index) Get the parameters for an interaction group. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long range nonbonded interactions. getNumComputedValues(self) Get the number of per-particle computed values the interaction depends on. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumExclusions(self) Get the number of particle pairs whose interactions should be excluded. getNumFunctions(self) Get the number of tabulated functions that have been defined. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumInteractionGroups(self) Get the number of interaction groups that have been defined. getNumParticles(self) Get the number of particles for which force field parameters have been defined. getNumPerParticleParameters(self) Get the number of per-particle parameters that the interaction depends on. getNumTabulatedFunctions(self) Get the number of tabulated functions that have been defined. getParticleParameters(self,Â index) Get the nonbonded force parameters for a particle. getPerParticleParameterName(self,Â index) Get the name of a per-particle parameter. getSwitchingDistance(self) Get the distance at which the switching function begins to reduce the interaction. getTabulatedFunction(->Â TabulatedFunction) Get a reference to a tabulated function that may appear in the energy expression. getTabulatedFunctionName(self,Â index) Get the name of a tabulated function that may appear in the energy expression. getUseLongRangeCorrection(self) Get whether to add a correction to the energy to compensate for the cutoff and switching function. getUseSwitchingFunction(self) Get whether a switching function is applied to the interaction. setComputedValueParameters(self,Â index,Â â¦) Set the properties of a computed value. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for nonbonded interactions. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the interaction energy between two particles setExclusionParticles(self,Â index,Â â¦) Set the particles in a pair whose interaction should be excluded. setForceGroup(self,Â group) Set the force group this Force belongs to. setFunctionParameters(self,Â index,Â name,Â â¦) Set the parameters for a tabulated function that may appear in the energy expression. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setInteractionGroupParameters(self,Â index,Â â¦) Set the parameters for an interaction group. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long range nonbonded interactions. setParticleParameters(self,Â index,Â parameters) Set the nonbonded force parameters for a particle. setPerParticleParameterName(self,Â index,Â name) Set the name of a per-particle parameter. setSwitchingDistance(self,Â distance) Set the distance at which the switching function begins to reduce the interaction. setUseLongRangeCorrection(self,Â use) Set whether to add a correction to the energy to compensate for the cutoff and switching function. setUseSwitchingFunction(self,Â use) Set whether a switching function is applied to the interaction. updateParametersInContext(self,Â context) Update the per-particle parameters and tabulated functions in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes CutoffNonPeriodic CutoffPeriodic NoCutoff thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles for which force field parameters have been defined. getNumExclusions(self) → intÂ¶ Get the number of particle pairs whose interactions should be excluded. getNumPerParticleParameters(self) → intÂ¶ Get the number of per-particle parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumTabulatedFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. getNumFunctions(self) → intÂ¶ Get the number of tabulated functions that have been defined. Deprecated This method exists only for backward compatibility. Use getNumTabulatedFunctions() instead. getNumComputedValues(self) → intÂ¶ Get the number of per-particle computed values the interaction depends on. getNumInteractionGroups(self) → intÂ¶ Get the number of interaction groups that have been defined. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the interaction energy between two particles setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the interaction energy between two particles getNonbondedMethod(self) → OpenMM::CustomNonbondedForce::NonbondedMethodÂ¶ Get the method used for handling long range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long range nonbonded interactions. getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm getUseSwitchingFunction(self) → boolÂ¶ Get whether a switching function is applied to the interaction. If the nonbonded method is set to NoCutoff, this option is ignored. setUseSwitchingFunction(self, use)Â¶ Set whether a switching function is applied to the interaction. If the nonbonded method is set to NoCutoff, this option is ignored. getSwitchingDistance(self) → doubleÂ¶ Get the distance at which the switching function begins to reduce the interaction. This must be less than the cutoff distance. setSwitchingDistance(self, distance)Â¶ Set the distance at which the switching function begins to reduce the interaction. This must be less than the cutoff distance. getUseLongRangeCorrection(self) → boolÂ¶ Get whether to add a correction to the energy to compensate for the cutoff and switching function. This has no effect if periodic boundary conditions are not used. setUseLongRangeCorrection(self, use)Â¶ Set whether to add a correction to the energy to compensate for the cutoff and switching function. This has no effect if periodic boundary conditions are not used. addPerParticleParameter(self, name) → intÂ¶ Add a new per-particle parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerParticleParameterName(self, index) → std::string const &Â¶ Get the name of a per-particle parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerParticleParameterName(self, index, name)Â¶ Set the name of a per-particle parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string addParticle(self, parameters=std::vector< double >()) → intÂ¶ Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. Parameters parameters (vector< double >) â the list of parameters for the new particle Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to get parameters Returns parameters â the list of parameters for the specified particle Return type vector< double > setParticleParameters(self, index, parameters)Â¶ Set the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to set parameters parameters (vector< double >) â the list of parameters for the specified particle addExclusion(self, particle1, particle2) → intÂ¶ Add a particle pair to the list of interactions that should be excluded. In many cases, you can use createExclusionsFromBonds() rather than adding each exclusion explicitly. Parameters particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair Returns the index of the exclusion that was added Return type int getExclusionParticles(self, index)Â¶ Get the particles in a pair whose interaction should be excluded. Parameters index (int) â the index of the exclusion for which to get particle indices Returns particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair setExclusionParticles(self, index, particle1, particle2)Â¶ Set the particles in a pair whose interaction should be excluded. Parameters index (int) â the index of the exclusion for which to set particle indices particle1 (int) â the index of the first particle in the pair particle2 (int) â the index of the second particle in the pair createExclusionsFromBonds(self, bonds, bondCutoff)Â¶ Identify exclusions based on the molecular topology. Particles which are separated by up to a specified number of bonds are added as exclusions. Parameters bonds (vector< std::pair< int, int > >) â the set of bonds based on which to construct exclusions. Each element specifies the indices of two particles that are bonded to each other. bondCutoff (int) â pairs of particles that are separated by this many bonds or fewer are added to the list of exclusions addTabulatedFunction(self, name, function) → intÂ¶ Add a tabulated function that may appear in the energy expression. Parameters name (string) â the name of the function as it appears in expressions function (TabulatedFunction *) â a TabulatedFunction object defining the function. The TabulatedFunction should have been created on the heap with the ânewâ operator. The Force takes over ownership of it, and deletes it when the Force itself is deleted. Returns the index of the function that was added Return type int getTabulatedFunction(self, index) → TabulatedFunctionÂ¶ getTabulatedFunction(self, index) → TabulatedFunction Get a reference to a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the TabulatedFunction object defining the function Return type TabulatedFunction getTabulatedFunctionName(self, index) → std::string const &Â¶ Get the name of a tabulated function that may appear in the energy expression. Parameters index (int) â the index of the function to get Returns the name of the function as it appears in expressions Return type string addFunction(self, name, values, min, max) → intÂ¶ Add a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Use addTabulatedFunction() instead. getFunctionParameters(self, index)Â¶ Get the parameters for a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Use getTabulatedFunctionParameters() instead. If the specified function is not a Continuous1DFunction, this throws an exception. setFunctionParameters(self, index, name, values, min, max)Â¶ Set the parameters for a tabulated function that may appear in the energy expression. Deprecated This method exists only for backward compatibility. Use setTabulatedFunctionParameters() instead. If the specified function is not a Continuous1DFunction, this throws an exception. addComputedValue(self, name, expression) → intÂ¶ Add a computed value to calculate for each particle. Parameters name (string) â the name of the value expression (string) â an algebraic expression to evaluate when calculating the computed value. It may depend on the values of per-particle and global parameters, but not one other computed values. Returns the index of the computed value that was added Return type int getComputedValueParameters(self, index)Â¶ Get the properties of a computed value. Parameters index (int) â the index of the computed value for which to get parameters Returns name (string) â the name of the value expression (string) â an algebraic expression to evaluate when calculating the computed value. It may depend on the values of per-particle and global parameters, but not one other computed values. setComputedValueParameters(self, index, name, expression)Â¶ Set the properties of a computed value. Parameters index (int) â the index of the computed value for which to set parameters name (string) â the name of the value expression (string) â an algebraic expression to evaluate when calculating the computed value. It may depend on the values of per-particle and global parameters, but not one other computed values. addInteractionGroup(self, set1, set2) → intÂ¶ Add an interaction group. An interaction will be computed between every particle in set1 and every particle in set2. Parameters set1 (set< int >) â the first set of particles forming the interaction group set2 (set< int >) â the second set of particles forming the interaction group Returns the index of the interaction group that was added Return type int getInteractionGroupParameters(self, index)Â¶ Get the parameters for an interaction group. Parameters index (int) â the index of the interaction group for which to get parameters Returns set1 (set< int >) â the first set of particles forming the interaction group set2 (set< int >) â the second set of particles forming the interaction group setInteractionGroupParameters(self, index, set1, set2)Â¶ Set the parameters for an interaction group. Parameters index (int) â the index of the interaction group for which to set parameters set1 (set< int >) â the first set of particles forming the interaction group set2 (set< int >) â the second set of particles forming the interaction group updateParametersInContext(self, context)Â¶ Update the per-particle parameters and tabulated functions in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-particle parameters and tabulated functions. All other aspects of the Force (the energy function, nonbonded method, cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Also, this method cannot be used to add new particles, only to change the parameters of existing ones. While the tabulated values of a function can change, everything else about it (its dimensions, the data range) must not be changed. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.CustomTorsionForce.html:
CustomTorsionForceÂ¶ class openmm.openmm.CustomTorsionForce(*args)Â¶ This class implements interactions between sets of four particles that depend on the torsion angle between them. Unlike PeriodicTorsionForce, the functional form of the interaction is completely customizable, and may involve arbitrary algebraic expressions. In addition to the angle formed by the particles, it may depend on arbitrary global and per-torsion parameters. To use this class, create a CustomTorsionForce object, passing an algebraic expression to the constructor that defines the interaction energy between each set of particles. The expression may depend on theta, the torsion angle formed by the particles, as well as on any parameters you choose. Then call addPerTorsionParameter() to define per-torsion parameters, and addGlobalParameter() to define global parameters. The values of per-torsion parameters are specified as part of the system definition, while values of global parameters may be modified during a simulation by calling Context::setParameter(). Finally, call addTorsion() once for each torsion. After an torsion has been added, you can modify its parameters by calling setTorsionParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). Note that theta is guaranteed to be in the range [-pi,+pi], which may cause issues with force discontinuities if the energy function does not respect this domain. As an example, the following code creates a CustomTorsionForce that implements a periodic potential: CustomTorsionForce* force = new CustomTorsionForce("0.5*k*(1-cos(theta-theta0))"); This force depends on two parameters: the spring constant k and equilibrium angle theta0. The following code defines these parameters: force->addPerTorsionParameter("k"); force->addPerTorsionParameter("theta0"); If a harmonic restraint is desired, it is important to be careful of the domain for theta, using an idiom like this: CustomTorsionForce* force = new CustomTorsionForce("0.5*k*min(dtheta, 2*pi-dtheta)^2; dtheta = abs(theta-theta0); pi = 3.1415926535"); This class also has the ability to compute derivatives of the potential energy with respect to global parameters. Call addEnergyParameterDerivative() to request that the derivative with respect to a particular parameter be computed. You can then query its value in a Context by calling getState() on it. Expressions may involve the operators + (add), - (subtract), * (multiply), / (divide), and ^ (power), and the following functions: sqrt, exp, log, sin, cos, sec, csc, tan, cot, asin, acos, atan, atan2, sinh, cosh, tanh, erf, erfc, min, max, abs, floor, ceil, step, delta, select. All trigonometric functions are defined in radians, and log is the natural logarithm. step(x) = 0 if x is less than 0, 1 otherwise. delta(x) = 1 if x is 0, 0 otherwise. select(x,y,z) = z if x = 0, y otherwise. __init__(self, energy) → CustomTorsionForceÂ¶ __init__(self, other) → CustomTorsionForce Create a CustomTorsionForce. Parameters energy (string) â an algebraic expression giving the interaction energy between three particles as a function of theta, the torsion angle between them Methods __init__(->Â CustomTorsionForce) Create a CustomTorsionForce. addEnergyParameterDerivative(self,Â name) Request that this Force compute the derivative of its energy with respect to a global parameter. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that the interaction may depend on. addPerTorsionParameter(self,Â name) Add a new per-torsion parameter that the interaction may depend on. addTorsion(self,Â particle1,Â particle2,Â â¦) Add a torsion term to the force field. getEnergyFunction(self) Get the algebraic expression that gives the interaction energy for each torsion getEnergyParameterDerivativeName(self,Â index) Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getName(self) Get the name of this Force. getNumEnergyParameterDerivatives(self) Get the number of global parameters with respect to which the derivative of the energy should be computed. getNumGlobalParameters(self) Get the number of global parameters that the interaction depends on. getNumPerTorsionParameters(self) Get the number of per-torsion parameters that the interaction depends on. getNumTorsions(self) Get the number of torsions for which force field parameters have been defined. getPerTorsionParameterName(self,Â index) Get the name of a per-torsion parameter. getTorsionParameters(self,Â index) Get the force field parameters for a torsion term. setEnergyFunction(self,Â energy) Set the algebraic expression that gives the interaction energy for each torsion setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setName(self,Â name) Set the name of this Force. setPerTorsionParameterName(self,Â index,Â name) Set the name of a per-torsion parameter. setTorsionParameters(self,Â index,Â particle1,Â â¦) Set the force field parameters for a torsion term. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-torsion parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumTorsions(self) → intÂ¶ Get the number of torsions for which force field parameters have been defined. getNumPerTorsionParameters(self) → intÂ¶ Get the number of per-torsion parameters that the interaction depends on. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that the interaction depends on. getNumEnergyParameterDerivatives(self) → intÂ¶ Get the number of global parameters with respect to which the derivative of the energy should be computed. getEnergyFunction(self) → std::string const &Â¶ Get the algebraic expression that gives the interaction energy for each torsion setEnergyFunction(self, energy)Â¶ Set the algebraic expression that gives the interaction energy for each torsion addPerTorsionParameter(self, name) → intÂ¶ Add a new per-torsion parameter that the interaction may depend on. Parameters name (string) â the name of the parameter Returns the index of the parameter that was added Return type int getPerTorsionParameterName(self, index) → std::string const &Â¶ Get the name of a per-torsion parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setPerTorsionParameterName(self, index, name)Â¶ Set the name of a per-torsion parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that the interaction may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addEnergyParameterDerivative(self, name)Â¶ Request that this Force compute the derivative of its energy with respect to a global parameter. The parameter must have already been added with addGlobalParameter(). Parameters name (string) â the name of the parameter getEnergyParameterDerivativeName(self, index) → std::string const &Â¶ Get the name of a global parameter with respect to which this Force should compute the derivative of the energy. Parameters index (int) â the index of the parameter derivative, between 0 and getNumEnergyParameterDerivatives() Returns the parameter name Return type string addTorsion(self, particle1, particle2, particle3, particle4, parameters=std::vector< double >()) → intÂ¶ Add a torsion term to the force field. Parameters particle1 (int) â the index of the first particle connected by the torsion particle2 (int) â the index of the second particle connected by the torsion particle3 (int) â the index of the third particle connected by the torsion particle4 (int) â the index of the fourth particle connected by the torsion parameters (vector< double >) â the list of parameters for the new torsion Returns the index of the torsion that was added Return type int getTorsionParameters(self, index)Â¶ Get the force field parameters for a torsion term. Parameters index (int) â the index of the torsion for which to get parameters Returns particle1 (int) â the index of the first particle connected by the torsion particle2 (int) â the index of the second particle connected by the torsion particle3 (int) â the index of the third particle connected by the torsion particle4 (int) â the index of the fourth particle connected by the torsion parameters (vector< double >) â the list of parameters for the torsion setTorsionParameters(self, index, particle1, particle2, particle3, particle4, parameters=std::vector< double >())Â¶ Set the force field parameters for a torsion term. Parameters index (int) â the index of the torsion for which to set parameters particle1 (int) â the index of the first particle connected by the torsion particle2 (int) â the index of the second particle connected by the torsion particle3 (int) â the index of the third particle connected by the torsion particle4 (int) â the index of the fourth particle connected by the torsion parameters (vector< double >) â the list of parameters for the torsion updateParametersInContext(self, context)Â¶ Update the per-torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setTorsionParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the values of per-torsion parameters. All other aspects of the Force (such as the energy function) are unaffected and can only be changed by reinitializing the Context. The set of particles involved in a torsion cannot be changed, nor can new torsions be added. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Discrete1DFunction.html:
Discrete1DFunctionÂ¶ class openmm.openmm.Discrete1DFunction(*args)Â¶ This is a TabulatedFunction that computes a discrete one dimensional function f(x). To evaluate it, x is rounded to the nearest integer and the table element with that index is returned. If the index is outside the range [0, size), the result is undefined. __init__(self, values) → Discrete1DFunctionÂ¶ __init__(self, other) → Discrete1DFunction Create a Discrete1DFunction f(x) based on a set of tabulated values. Parameters values (vector< double >) â the tabulated values of the function f(x) Methods Copy(self) Create a deep copy of the tabulated function __init__(->Â Discrete1DFunction) Create a Discrete1DFunction f(x) based on a set of tabulated values. getFunctionParameters(self) Get the parameters for the tabulated function. getPeriodic(self) Get the periodicity status of the tabulated function. getUpdateCount(self) Get the value of a counter that is updated every time setFunctionParameters() is called. setFunctionParameters(self,Â values) Set the parameters for the tabulated function. Attributes thisown The membership flag property thisownÂ¶ The membership flag getFunctionParameters(self)Â¶ Get the parameters for the tabulated function. Returns values â the tabulated values of the function f(x) Return type vector< double > setFunctionParameters(self, values)Â¶ Set the parameters for the tabulated function. Parameters values (vector< double >) â the tabulated values of the function f(x) Copy(self) → Discrete1DFunctionÂ¶ Create a deep copy of the tabulated function Deprecated This will be removed in a future release. __eq__(self, other) → boolÂ¶ __ne__(self, other) → boolÂ¶ getPeriodic(self) → boolÂ¶ Get the periodicity status of the tabulated function. getUpdateCount(self) → intÂ¶ Get the value of a counter that is updated every time setFunctionParameters() is called. This provides a fast way to detect when a function has changed.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Discrete2DFunction.html:
Discrete2DFunctionÂ¶ class openmm.openmm.Discrete2DFunction(*args)Â¶ This is a TabulatedFunction that computes a discrete two dimensional function f(x,y). To evaluate it, x and y are each rounded to the nearest integer and the table element with those indices is returned. If either index is outside the range [0, size), the result is undefined. __init__(self, xsize, ysize, values) → Discrete2DFunctionÂ¶ __init__(self, other) → Discrete2DFunction Create a Discrete2DFunction f(x,y) based on a set of tabulated values. Parameters xsize (int) â the number of table elements along the x direction ysize (int) â the number of table elements along the y direction values (vector< double >) â the tabulated values of the function f(x,y), ordered so that values[i+xsize*j] = f(i,j). This must be of length xsize*ysize. Methods Copy(self) Create a deep copy of the tabulated function __init__(->Â Discrete2DFunction) Create a Discrete2DFunction f(x,y) based on a set of tabulated values. getFunctionParameters(self) Get the parameters for the tabulated function. getPeriodic(self) Get the periodicity status of the tabulated function. getUpdateCount(self) Get the value of a counter that is updated every time setFunctionParameters() is called. setFunctionParameters(self,Â xsize,Â ysize,Â values) Set the parameters for the tabulated function. Attributes thisown The membership flag property thisownÂ¶ The membership flag getFunctionParameters(self)Â¶ Get the parameters for the tabulated function. Returns xsize (int) â the number of table elements along the x direction ysize (int) â the number of table elements along the y direction values (vector< double >) â the tabulated values of the function f(x,y), ordered so that values[i+xsize*j] = f(i,j). This must be of length xsize*ysize. setFunctionParameters(self, xsize, ysize, values)Â¶ Set the parameters for the tabulated function. Parameters xsize (int) â the number of table elements along the x direction ysize (int) â the number of table elements along the y direction values (vector< double >) â the tabulated values of the function f(x,y), ordered so that values[i+xsize*j] = f(i,j). This must be of length xsize*ysize. Copy(self) → Discrete2DFunctionÂ¶ Create a deep copy of the tabulated function Deprecated This will be removed in a future release. __eq__(self, other) → boolÂ¶ __ne__(self, other) → boolÂ¶ getPeriodic(self) → boolÂ¶ Get the periodicity status of the tabulated function. getUpdateCount(self) → intÂ¶ Get the value of a counter that is updated every time setFunctionParameters() is called. This provides a fast way to detect when a function has changed.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Discrete3DFunction.html:
Discrete3DFunctionÂ¶ class openmm.openmm.Discrete3DFunction(*args)Â¶ This is a TabulatedFunction that computes a discrete three dimensional function f(x,y,z). To evaluate it, x, y, and z are each rounded to the nearest integer and the table element with those indices is returned. If any index is outside the range [0, size), the result is undefined. __init__(self, xsize, ysize, zsize, values) → Discrete3DFunctionÂ¶ __init__(self, other) → Discrete3DFunction Create a Discrete3DFunction f(x,y,z) based on a set of tabulated values. Parameters xsize (int) â the number of table elements along the x direction ysize (int) â the number of table elements along the y direction zsize (int) â the number of table elements along the z direction values (vector< double >) â the tabulated values of the function f(x,y,z), ordered so that values[i+xsize*j+xsize*ysize*k] = f(i,j,k). This must be of length xsize*ysize*zsize. Methods Copy(self) Create a deep copy of the tabulated function __init__(->Â Discrete3DFunction) Create a Discrete3DFunction f(x,y,z) based on a set of tabulated values. getFunctionParameters(self) Get the parameters for the tabulated function. getPeriodic(self) Get the periodicity status of the tabulated function. getUpdateCount(self) Get the value of a counter that is updated every time setFunctionParameters() is called. setFunctionParameters(self,Â xsize,Â ysize,Â â¦) Set the parameters for the tabulated function. Attributes thisown The membership flag property thisownÂ¶ The membership flag getFunctionParameters(self)Â¶ Get the parameters for the tabulated function. Returns xsize (int) â the number of table elements along the x direction ysize (int) â the number of table elements along the y direction zsize (int) â the number of table elements along the z direction values (vector< double >) â the tabulated values of the function f(x,y,z), ordered so that values[i+xsize*j+xsize*ysize*k] = f(i,j,k). This must be of length xsize*ysize*zsize. setFunctionParameters(self, xsize, ysize, zsize, values)Â¶ Set the parameters for the tabulated function. Parameters xsize (int) â the number of table elements along the x direction ysize (int) â the number of table elements along the y direction zsize (int) â the number of table elements along the z direction values (vector< double >) â the tabulated values of the function f(x,y,z), ordered so that values[i+xsize*j+xsize*ysize*k] = f(i,j,k). This must be of length xsize*ysize*zsize. Copy(self) → Discrete3DFunctionÂ¶ Create a deep copy of the tabulated function Deprecated This will be removed in a future release. __eq__(self, other) → boolÂ¶ __ne__(self, other) → boolÂ¶ getPeriodic(self) → boolÂ¶ Get the periodicity status of the tabulated function. getUpdateCount(self) → intÂ¶ Get the value of a counter that is updated every time setFunctionParameters() is called. This provides a fast way to detect when a function has changed.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.DrudeForce.html:
DrudeForceÂ¶ class openmm.openmm.DrudeForce(*args)Â¶ This class implements forces that are specific to Drude oscillators. There are two distinct forces it applies: an anisotropic harmonic force connecting each Drude particle to its parent particle; and a screened Coulomb interaction between specific pairs of dipoles. The latter is typically used between closely bonded particles whose Coulomb interaction would otherwise be fully excluded. To use this class, create a DrudeForce object, then call addParticle() once for each Drude particle in the System to define its parameters. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). Likewise, call addScreenedPair() for each pair of dipoles (each dipole consisting of a Drude particle and its parent) that should be computed. __init__(self) → DrudeForceÂ¶ __init__(self, other) → DrudeForce Create a DrudeForce. Methods __init__(->Â DrudeForce) Create a DrudeForce. addParticle(self,Â particle,Â particle1,Â â¦) Add a Drude particle to which forces should be applied. addScreenedPair(self,Â particle1,Â particle2,Â â¦) Add an interaction to the list of screened pairs. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNumParticles(self) Get the number of particles for which force field parameters have been defined. getNumScreenedPairs(self) Get the number of special interactions that should be calculated differently from other interactions. getParticleParameters(self,Â index) Get the parameters for a Drude particle. getScreenedPairParameters(self,Â index) Get the force field parameters for screened pair. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setParticleParameters(self,Â index,Â particle,Â â¦) Set the parameters for a Drude particle. setScreenedPairParameters(self,Â index,Â â¦) Set the force field parameters for screened pair. updateParametersInContext(self,Â context) Update the particle and screened pair parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles for which force field parameters have been defined. getNumScreenedPairs(self) → intÂ¶ Get the number of special interactions that should be calculated differently from other interactions. addParticle(self, particle, particle1, particle2, particle3, particle4, charge, polarizability, aniso12, aniso34) → intÂ¶ Add a Drude particle to which forces should be applied. Parameters particle (int) â the index within the System of the Drude particle particle1 (int) â the index within the System of the particle to which the Drude particle is attached particle2 (int) â the index within the System of the second particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso12 will be ignored. particle3 (int) â the index within the System of the third particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored. particle4 (int) â the index within the System of the fourth particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored. charge (double) â The charge on the Drude particle polarizability (double) â The isotropic polarizability aniso12 (double) â The scale factor for the polarizability along the direction defined by particle1 and particle2 aniso34 (double) â The scale factor for the polarizability along the direction defined by particle3 and particle4 Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the parameters for a Drude particle. Parameters index (int) â the index of the Drude particle for which to get parameters Returns particle (int) â the index within the System of the Drude particle particle1 (int) â the index within the System of the particle to which the Drude particle is attached particle2 (int) â the index within the System of the second particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso12 will be ignored. particle3 (int) â the index within the System of the third particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored. particle4 (int) â the index within the System of the fourth particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored. charge (double) â The charge on the Drude particle polarizability (double) â The isotropic polarizability aniso12 (double) â The scale factor for the polarizability along the direction defined by particle1 and particle2 aniso34 (double) â The scale factor for the polarizability along the direction defined by particle3 and particle4 setParticleParameters(self, index, particle, particle1, particle2, particle3, particle4, charge, polarizability, aniso12, aniso34)Â¶ Set the parameters for a Drude particle. Parameters index (int) â the index of the Drude particle for which to set parameters particle (int) â the index within the System of the Drude particle particle1 (int) â the index within the System of the particle to which the Drude particle is attached particle2 (int) â the index within the System of the second particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso12 will be ignored. particle3 (int) â the index within the System of the third particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored. particle4 (int) â the index within the System of the fourth particle used for defining anisotropic polarizability. This may be set to -1, in which case aniso34 will be ignored. charge (double) â The charge on the Drude particle polarizability (double) â The isotropic polarizability aniso12 (double) â The scale factor for the polarizability along the direction defined by particle1 and particle2 aniso34 (double) â The scale factor for the polarizability along the direction defined by particle3 and particle4 addScreenedPair(self, particle1, particle2, thole) → intÂ¶ Add an interaction to the list of screened pairs. Parameters particle1 (int) â the index within this Force of the first particle involved in the interaction particle2 (int) â the index within this Force of the second particle involved in the interaction thole (double) â the Thole screening factor Returns the index of the screenedPair that was added Return type int getScreenedPairParameters(self, index)Â¶ Get the force field parameters for screened pair. Parameters index (int) â the index of the pair for which to get parameters Returns particle1 (int) â the index within this Force of the first particle involved in the interaction particle2 (int) â the index within this Force of the second particle involved in the interaction thole (double) â the Thole screening factor setScreenedPairParameters(self, index, particle1, particle2, thole)Â¶ Set the force field parameters for screened pair. Parameters index (int) â the index of the pair for which to get parameters particle1 (int) â the index within this Force of the first particle involved in the interaction particle2 (int) â the index within this Force of the second particle involved in the interaction thole (double) â the Thole screening factor updateParametersInContext(self, context)Â¶ Update the particle and screened pair parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() and setScreenedPairParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. It can be used to modify the numeric parameters associated with a particle or screened pair (polarizability, thole, etc.), but not the identities of the particles they involve. It also cannot be used to add new particles or screenedPairs, only to change the parameters of existing ones. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if nonbondedMethod uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.DrudeIntegrator.html:
DrudeIntegratorÂ¶ class openmm.openmm.DrudeIntegrator(*args)Â¶ A base class to encapsulate features common to Drude integrators. __init__(self, stepSize) → DrudeIntegratorÂ¶ __init__(self, other) → DrudeIntegrator Create a DrudeSCFIntegrator. Parameters stepSize (double) â the step size with which to integrator the system (in picoseconds) Methods __init__(->Â DrudeIntegrator) Create a DrudeSCFIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getDrudeTemperature(self) Get the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). getIntegrationForceGroups(self) Get which force groups to use for integration. getMaxDrudeDistance(self) Get the maximum distance a Drude particle can ever move from its parent particle, measured in nm. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setDrudeTemperature(self,Â temp) Set the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). setIntegrationForceGroups(groups) Set which force groups to use for integration. setMaxDrudeDistance(self,Â distance) Set the maximum distance a Drude particle can ever move from its parent particle, measured in nm. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take getDrudeTemperature(self) → doubleÂ¶ Get the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin Return type double setDrudeTemperature(self, temp)Â¶ Set the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin getMaxDrudeDistance(self) → doubleÂ¶ Get the maximum distance a Drude particle can ever move from its parent particle, measured in nm. This is implemented with a hard wall constraint. The default value is 0.02. If this distance is set to 0, the hard wall constraint is omitted. setMaxDrudeDistance(self, distance)Â¶ Set the maximum distance a Drude particle can ever move from its parent particle, measured in nm. This is implemented with a hard wall constraint. The default value is 0.02. If this distance is set to 0, the hard wall constraint is omitted. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.DrudeLangevinIntegrator.html:
DrudeLangevinIntegratorÂ¶ class openmm.openmm.DrudeLangevinIntegrator(*args)Â¶ This Integrator simulates systems that include Drude particles. It applies two different Langevin thermostats to different parts of the system. The first is applied to ordinary particles (ones that are not part of a Drude particle pair), as well as to the center of mass of each Drude particle pair. A second thermostat, typically with a much lower temperature, is applied to the relative internal displacement of each pair. This integrator can optionally set an upper limit on how far any Drude particle is ever allowed to get from its parent particle. This can sometimes help to improve stability. The limit is enforced with a hard wall constraint. By default the limit is set to 0.02 nm. This Integrator requires the System to include a DrudeForce, which it uses to identify the Drude particles. __init__(self, temperature, frictionCoeff, drudeTemperature, drudeFrictionCoeff, stepSize) → DrudeLangevinIntegratorÂ¶ __init__(self, other) → DrudeLangevinIntegrator Create a DrudeLangevinIntegrator. Parameters temperature (double) â the temperature of the main heat bath (in Kelvin) frictionCoeff (double) â the friction coefficient which couples the system to the main heat bath (in inverse picoseconds) drudeTemperature (double) â the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin) drudeFrictionCoeff (double) â the friction coefficient which couples the system to the heat bath applied to internal coordinates of Drude particles (in inverse picoseconds) stepSize (double) â the step size with which to integrator the system (in picoseconds) Methods __init__(->Â DrudeLangevinIntegrator) Create a DrudeLangevinIntegrator. computeDrudeTemperature(self) Compute the instantaneous temperature of the Drude system, measured in Kelvin. computeSystemTemperature(self) Compute the instantaneous temperature of the System, measured in Kelvin. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getDrudeFriction(self) Get the friction coefficient which determines how strongly the internal coordinates of Drude particles are coupled to the heat bath (in inverse ps). getDrudeTemperature(self) Get the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). getFriction(self) Get the friction coefficient which determines how strongly the system is coupled to the main heat bath (in inverse ps). getIntegrationForceGroups(self) Get which force groups to use for integration. getMaxDrudeDistance(self) Get the maximum distance a Drude particle can ever move from its parent particle, measured in nm. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTemperature(self) Get the temperature of the main heat bath (in Kelvin). setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setDrudeFriction(self,Â coeff) Set the friction coefficient which determines how strongly the internal coordinates of Drude particles are coupled to the heat bath (in inverse ps). setDrudeTemperature(self,Â temp) Set the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). setFriction(self,Â coeff) Set the friction coefficient which determines how strongly the system is coupled to the main heat bath (in inverse ps). setIntegrationForceGroups(groups) Set which force groups to use for integration. setMaxDrudeDistance(self,Â distance) Set the maximum distance a Drude particle can ever move from its parent particle, measured in nm. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. setTemperature(self,Â temp) Set the temperature of the main heat bath (in Kelvin). step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag getTemperature(self) → doubleÂ¶ Get the temperature of the main heat bath (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin Return type double setTemperature(self, temp)Â¶ Set the temperature of the main heat bath (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin getFriction(self) → doubleÂ¶ Get the friction coefficient which determines how strongly the system is coupled to the main heat bath (in inverse ps). Returns the friction coefficient, measured in 1/ps Return type double setFriction(self, coeff)Â¶ Set the friction coefficient which determines how strongly the system is coupled to the main heat bath (in inverse ps). Parameters coeff (double) â the friction coefficient, measured in 1/ps getDrudeFriction(self) → doubleÂ¶ Get the friction coefficient which determines how strongly the internal coordinates of Drude particles are coupled to the heat bath (in inverse ps). Returns the friction coefficient, measured in 1/ps Return type double setDrudeFriction(self, coeff)Â¶ Set the friction coefficient which determines how strongly the internal coordinates of Drude particles are coupled to the heat bath (in inverse ps). Parameters coeff (double) â the friction coefficient, measured in 1/ps step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take computeSystemTemperature(self) → doubleÂ¶ Compute the instantaneous temperature of the System, measured in Kelvin. This is calculated based on the kinetic energy of the ordinary particles (ones not attached to a Drude particle), as well as the center of mass motion of the Drude particle pairs. It does not include the internal motion of the pairs. On average, this should be approximately equal to the value returned by getTemperature(). computeDrudeTemperature(self) → doubleÂ¶ Compute the instantaneous temperature of the Drude system, measured in Kelvin. This is calculated based on the kinetic energy of the internal motion of Drude pairs and should remain close to the prescribed Drude temperature. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getDrudeTemperature(self) → doubleÂ¶ Get the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin Return type double getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getMaxDrudeDistance(self) → doubleÂ¶ Get the maximum distance a Drude particle can ever move from its parent particle, measured in nm. This is implemented with a hard wall constraint. The default value is 0.02. If this distance is set to 0, the hard wall constraint is omitted. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setDrudeTemperature(self, temp)Â¶ Set the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setMaxDrudeDistance(self, distance)Â¶ Set the maximum distance a Drude particle can ever move from its parent particle, measured in nm. This is implemented with a hard wall constraint. The default value is 0.02. If this distance is set to 0, the hard wall constraint is omitted. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.DrudeNoseHooverIntegrator.html:
DrudeNoseHooverIntegratorÂ¶ class openmm.openmm.DrudeNoseHooverIntegrator(*args)Â¶ This Integrator simulates systems that include Drude particles. It applies two different Nose-Hoover chain thermostats to the different parts of the system. The first is applied to ordinary particles (ones that are not part of a Drude particle pair), as well as to the center of mass of each Drude particle pair. A second thermostat, typically with a much lower temperature, is applied to the relative internal displacement of each pair. This integrator can optionally set an upper limit on how far any Drude particle is ever allowed to get from its parent particle. This can sometimes help to improve stability. The limit is enforced with a hard wall constraint. By default the limit is set to 0.02 nm. This Integrator requires the System to include a DrudeForce, which it uses to identify the Drude particles. __init__(self, temperature, collisionFrequency, drudeTemperature, drudeCollisionFrequency, stepSize, chainLength=3, numMTS=3, numYoshidaSuzuki=7) → DrudeNoseHooverIntegratorÂ¶ __init__(self, other) → DrudeNoseHooverIntegrator Create a DrudeNoseHooverIntegrator. Parameters temperature (double) â the target temperature for the system (in Kelvin). collisionFrequency (double) â the frequency of the systemâs interaction with the heat bath (in inverse picoseconds). drudeTemperature (double) â the target temperature for the Drude particles, relative to their parent atom (in Kelvin). drudeCollisionFrequency (double) â the frequency of the drude particlesâ interaction with the heat bath (in inverse picoseconds). stepSize (double) â the step size with which to integrator the system (in picoseconds) chainLength (int) â the number of beads in the Nose-Hoover chain. numMTS (int) â the number of step in the multiple time step chain propagation algorithm. numYoshidaSuzuki (int) â the number of terms in the Yoshida-Suzuki multi time step decomposition used in the chain propagation algorithm (must be 1, 3, or 5). Methods __init__(->Â DrudeNoseHooverIntegrator) Create a DrudeNoseHooverIntegrator. addSubsystemThermostat(self,Â â¦[,Â â¦]) Add a Nose-Hoover Chain thermostat to control the temperature of a collection of atoms and/or pairs of connected atoms within the full system. addThermostat(self,Â temperature,Â â¦) Add a simple Nose-Hoover Chain thermostat to control the temperature of the full system computeDrudeKineticEnergy(self) Compute the kinetic energy of the drude particles at the current time. computeDrudeTemperature(self) Compute the instantaneous temperature of the Drude system, measured in Kelvin. computeHeatBathEnergy(self) Compute the total (potential + kinetic) heat bath energy for all heat baths associated with this integrator, at the current time. computeSystemTemperature(self) Compute the instantaneous temperature of the System, measured in Kelvin. computeTotalKineticEnergy(self) Compute the kinetic energy of all (real and drude) particles at the current time. getCollisionFrequency(self[,Â chainID]) Get the collision frequency for absolute motion of the i-th chain (in 1/picosecond). getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) Get which force groups to use for integration. getMaxDrudeDistance(self) Get the maximum distance a Drude particle can ever move from its parent particle, measured in nm. getMaximumPairDistance(self) Gets the maximum distance (in nm) that a connected pair may stray from each other. getNumThermostats(self) Get the number of Nose-Hoover chains registered with this integrator. getRelativeCollisionFrequency(self[,Â chainID]) Get the collision frequency for pairsâ relative motion of the i-th chain (in 1/picosecond). getRelativeTemperature(self[,Â chainID]) Get the temperature of the i-th chain for controling pairsâ relative particle motion (in Kelvin). getStepSize(self) Get the size of each time step, in picoseconds. getTemperature(self[,Â chainID]) Get the temperature of the i-th chain for controling absolute particle motion (in Kelvin). getThermostat(self[,Â chainID]) Get the NoseHooverChain thermostat hasSubsystemThermostats(self) Return false, if this integrator was set up with the âdefault constructorâ that thermostats the whole system, true otherwise. initialize(self,Â context) This will be called by the Context when it is created. setCollisionFrequency(self,Â frequency[,Â chainID]) Set the collision frequency for absolute motion of the i-th chain. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups) Set which force groups to use for integration. setMaxDrudeDistance(self,Â distance) Set the maximum distance a Drude particle can ever move from its parent particle, measured in nm. setMaximumPairDistance(self,Â distance) Sets the maximum distance (in nm) that a connected pair may stray from each other, implemented using a hard wall. setRelativeCollisionFrequency(self,Â frequency) Set the collision frequency for pairsâ relative motion of the i-th chain. setRelativeTemperature(self,Â temperature[,Â â¦]) set the (relative pair motion) temperature of the i-th chain. setStepSize(self,Â size) Set the size of each time step, in picoseconds. setTemperature(self,Â temperature[,Â chainID]) set the (absolute motion) temperature of the i-th chain. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag initialize(self, context)Â¶ This will be called by the Context when it is created. It informs the Integrator of what context it will be integrating, and gives it a chance to do any necessary initialization. It will also get called again if the application calls reinitialize() on the Context. getMaxDrudeDistance(self) → doubleÂ¶ Get the maximum distance a Drude particle can ever move from its parent particle, measured in nm. This is implemented with a hard wall constraint. If this distance is set to 0 (the default), the hard wall constraint is omitted. setMaxDrudeDistance(self, distance)Â¶ Set the maximum distance a Drude particle can ever move from its parent particle, measured in nm. This is implemented with a hard wall constraint. If this distance is set to 0 (the default), the hard wall constraint is omitted. computeDrudeKineticEnergy(self) → doubleÂ¶ Compute the kinetic energy of the drude particles at the current time. computeTotalKineticEnergy(self) → doubleÂ¶ Compute the kinetic energy of all (real and drude) particles at the current time. computeSystemTemperature(self) → doubleÂ¶ Compute the instantaneous temperature of the System, measured in Kelvin. This is calculated based on the kinetic energy of the ordinary particles (ones not attached to a Drude particle), as well as the center of mass motion of the Drude particle pairs. It does not include the internal motion of the pairs. On average, this should be approximately equal to the value returned by getTemperature(). computeDrudeTemperature(self) → doubleÂ¶ Compute the instantaneous temperature of the Drude system, measured in Kelvin. This is calculated based on the kinetic energy of the internal motion of Drude pairs and should remain close to the prescribed Drude temperature. addSubsystemThermostat(self, thermostatedParticles, thermostatedPairs, temperature, collisionFrequency, relativeTemperature, relativeCollisionFrequency, chainLength=3, numMTS=3, numYoshidaSuzuki=7) → intÂ¶ Add a Nose-Hoover Chain thermostat to control the temperature of a collection of atoms and/or pairs of connected atoms within the full system. A list of atoms defining the atoms to be thermostated is provided and the thermostat will only control members of that list. Additionally a list of pairs of connected atoms may be provided; in this case both the center of mass absolute motion of each pair is controlled as well as their motion relative to each other, which is independently thermostated. If both the list of thermostated particles and thermostated pairs are empty all particles will be thermostated. Parameters thermostatedParticles (vector< int >) â list of particle ids to be thermostated. thermostatedPairs (vector< std::pair< int, int > >) â a list of pairs of connected atoms whose absolute center of mass motion and motion relative to one another will be independently thermostated. temperature (double) â the target temperature for each pairâs absolute of center of mass motion. collisionFrequency (double) â the frequency of the interaction with the heat bath for the pairsâ center of mass motion (in 1/ps). relativeTemperature (double) â the target temperature for each pairâs relative motion. relativeCollisionFrequency (double) â the frequency of the interaction with the heat bath for the pairsâ relative motion (in 1/ps). chainLength (int) â the number of beads in the Nose-Hoover chain. numMTS (int) â the number of step in the multiple time step chain propagation algorithm. numYoshidaSuzuki (int) â the number of terms in the Yoshida-Suzuki multi time step decomposition used in the chain propagation algorithm (must be 1, 3, 5, or 7). addThermostat(self, temperature, collisionFrequency, chainLength, numMTS, numYoshidaSuzuki) → intÂ¶ Add a simple Nose-Hoover Chain thermostat to control the temperature of the full system Parameters temperature (double) â the target temperature for the system. collisionFrequency (double) â the frequency of the interaction with the heat bath (in 1/ps). chainLength (int) â the number of beads in the Nose-Hoover chain numMTS (int) â the number of step in the multiple time step chain propagation algorithm. numYoshidaSuzuki (int) â the number of terms in the Yoshida-Suzuki multi time step decomposition used in the chain propagation algorithm (must be 1, 3, 5, or 7). computeHeatBathEnergy(self) → doubleÂ¶ Compute the total (potential + kinetic) heat bath energy for all heat baths associated with this integrator, at the current time. getCollisionFrequency(self, chainID=0) → doubleÂ¶ Get the collision frequency for absolute motion of the i-th chain (in 1/picosecond). Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). Returns the collision frequency. Return type double getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getMaximumPairDistance(self) → doubleÂ¶ Gets the maximum distance (in nm) that a connected pair may stray from each other. If zero, there are no constraints on the intra-pair separation. getNumThermostats(self) → intÂ¶ Get the number of Nose-Hoover chains registered with this integrator. getRelativeCollisionFrequency(self, chainID=0) → doubleÂ¶ Get the collision frequency for pairsâ relative motion of the i-th chain (in 1/picosecond). Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). Returns the collision frequency. Return type double getRelativeTemperature(self, chainID=0) → doubleÂ¶ Get the temperature of the i-th chain for controling pairsâ relative particle motion (in Kelvin). Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). Returns the temperature. Return type double getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double getTemperature(self, chainID=0) → doubleÂ¶ Get the temperature of the i-th chain for controling absolute particle motion (in Kelvin). Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). Returns the temperature. Return type double getThermostat(self, chainID=0) → NoseHooverChainÂ¶ Get the NoseHooverChain thermostat Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). hasSubsystemThermostats(self) → boolÂ¶ Return false, if this integrator was set up with the âdefault constructorâ that thermostats the whole system, true otherwise. Required for serialization. setCollisionFrequency(self, frequency, chainID=0)Â¶ Set the collision frequency for absolute motion of the i-th chain. Parameters frequency (double) â the collision frequency in picosecond. chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setMaximumPairDistance(self, distance)Â¶ Sets the maximum distance (in nm) that a connected pair may stray from each other, implemented using a hard wall. If set to zero, the hard wall constraint is omited and the pairs are free to be separated by any distance. setRelativeCollisionFrequency(self, frequency, chainID=0)Â¶ Set the collision frequency for pairsâ relative motion of the i-th chain. Parameters frequency (double) â the collision frequency in picosecond. chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). setRelativeTemperature(self, temperature, chainID=0)Â¶ set the (relative pair motion) temperature of the i-th chain. Parameters temperature (double) â the temperature for the Nose-Hoover chain thermostat (in Kelvin). chainID (int) â The id of the Nose-Hoover chain thermostat for which the temperature is set (default=0). setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps setTemperature(self, temperature, chainID=0)Â¶ set the (absolute motion) temperature of the i-th chain. Parameters temperature (double) â the temperature for the Nose-Hoover chain thermostat (in Kelvin). chainID (int) â The id of the Nose-Hoover chain thermostat for which the temperature is set (default=0). step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.DrudeSCFIntegrator.html:
DrudeSCFIntegratorÂ¶ class openmm.openmm.DrudeSCFIntegrator(*args)Â¶ This is a leap-frog Verlet Integrator that simulates systems with Drude particles. It uses the self-consistent field (SCF) method: at every time step, the positions of Drude particles are adjusted to minimize the potential energy. This Integrator requires the System to include a DrudeForce, which it uses to identify the Drude particles. __init__(self, stepSize) → DrudeSCFIntegratorÂ¶ __init__(self, other) → DrudeSCFIntegrator Create a DrudeSCFIntegrator. Parameters stepSize (double) â the step size with which to integrator the system (in picoseconds) Methods __init__(->Â DrudeSCFIntegrator) Create a DrudeSCFIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getDrudeTemperature(self) Get the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). getIntegrationForceGroups(self) Get which force groups to use for integration. getMaxDrudeDistance(self) Get the maximum distance a Drude particle can ever move from its parent particle, measured in nm. getMinimizationErrorTolerance(self) Get the error tolerance to use when minimizing the potential energy. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setDrudeTemperature(self,Â temp) Set the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). setIntegrationForceGroups(groups) Set which force groups to use for integration. setMaxDrudeDistance(self,Â distance) Set the maximum distance a Drude particle can ever move from its parent particle, measured in nm. setMinimizationErrorTolerance(self,Â tol) Set the error tolerance to use when minimizing the potential energy. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getDrudeTemperature(self) → doubleÂ¶ Get the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin Return type double getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getMaxDrudeDistance(self) → doubleÂ¶ Get the maximum distance a Drude particle can ever move from its parent particle, measured in nm. This is implemented with a hard wall constraint. The default value is 0.02. If this distance is set to 0, the hard wall constraint is omitted. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setDrudeTemperature(self, temp)Â¶ Set the temperature of the heat bath applied to internal coordinates of Drude particles (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setMaxDrudeDistance(self, distance)Â¶ Set the maximum distance a Drude particle can ever move from its parent particle, measured in nm. This is implemented with a hard wall constraint. The default value is 0.02. If this distance is set to 0, the hard wall constraint is omitted. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps property thisownÂ¶ The membership flag getMinimizationErrorTolerance(self) → doubleÂ¶ Get the error tolerance to use when minimizing the potential energy. This roughly corresponds to the maximum allowed force magnitude on the Drude particles after minimization. Returns the error tolerance to use, measured in kJ/mol/nm Return type double setMinimizationErrorTolerance(self, tol)Â¶ Set the error tolerance to use when minimizing the potential energy. This roughly corresponds to the maximum allowed force magnitude on the Drude particles after minimization. Parameters tol (double) â the error tolerance to use, measured in kJ/mol/nm step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Force.html:
ForceÂ¶ class openmm.openmm.Force(*args, **kwargs)Â¶ Force objects apply forces to the particles in a System, or alter their behavior in other ways. This is an abstract class. Subclasses define particular forces. More specifically, a Force object can do any or all of the following: Add a contribution to the force on each particle Add a contribution to the potential energy of the System Modify the positions and velocities of particles at the start of each time step Define parameters which are stored in the Context and can be modified by the user Change the values of parameters defined by other Force objects at the start of each time step Forces may be organized into âforce groupsâ. This is used for multiple time step integration, and allows subsets of the Forces in a System to be evaluated at different times. By default, all Forces are in group 0. Call setForceGroup() to change this. Some Force subclasses may provide additional methods to further split their computations into multiple groups. Be aware that particular Platforms may place restrictions on the use of force groups, such as requiring all nonbonded forces to be in the same group. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. This method should be overridden for all Force subclasses, or a OpenMM::OpenMMException will be thrown Returns true if Force uses periodic boundaries or false if it does not Return type bool

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.GayBerneForce.html:
GayBerneForceÂ¶ class openmm.openmm.GayBerneForce(*args)Â¶ This class implements the Gay-Berne anisotropic potential. This is similar to a Lennard-Jones potential, but it represents the particles as ellipsoids rather than point particles. In addition to the standard sigma and epsilon parameters, each particle has three widths sx, sy, and sz that give the diameter of the ellipsoid along each axis. It also has three scale factors ex, ey, and ez that scale the strength of the interaction along each axis. You can think of this force as a Lennard-Jones interaction computed based on the distance between the nearest points on two ellipsoids. The scale factors act as multipliers for epsilon along each axis, so the strength of the interaction along the ellipsoidâs x axis is multiplied by ex, and likewise for the other axes. If two particles each have all their widths set to sigma and all their scale factors set to 1, the interaction simplifies to a standard Lennard-Jones force between point particles. The orientation of a particleâs ellipsoid is determined based on the positions of two other particles. The vector to the first particle sets the direction of the x axis. The vector to the second particle (after subtracting out any x component) sets the direction of the y axis. If the ellipsoid is axially symmetric (sy=sz and ey=ez), you can omit the second particle and define only an x axis direction. If the ellipsoid is a sphere (all three widths and all three scale factors are equal), both particles can be omitted. To determine the values of sigma and epsilon for an interaction, this class uses Lorentz-Berthelot combining rules: it takes the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles. You also can specify âexceptionsâ, particular pairs of particles for which different values should be used. To use this class, create a GayBerneForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). When using a cutoff, by default interactions are sharply truncated at the cutoff distance. Optionally you can instead use a switching function to make the interaction smoothly go to zero over a finite distance range. To enable this, call setUseSwitchingFunction(). You must also call setSwitchingDistance() to specify the distance at which the interaction should begin to decrease. The switching distance must be less than the cutoff distance. __init__(self) → GayBerneForceÂ¶ __init__(self, other) → GayBerneForce Create a GayBerneForce. Methods __init__(->Â GayBerneForce) Create a GayBerneForce. addException(self,Â particle1,Â particle2,Â â¦) Add an interaction to the list of exceptions that should be calculated differently from other interactions. addParticle(self,Â sigma,Â epsilon,Â xparticle,Â â¦) Add the parameters for a particle. getCutoffDistance(self) Get the cutoff distance (in nm) being used for interactions. getExceptionParameters(self,Â index) Get the force field parameters for an interaction that should be calculated differently from others. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long range interactions. getNumExceptions(self) Get the number of special interactions that should be calculated differently from other interactions. getNumParticles(self) Get the number of particles for which force field parameters have been defined. getParticleParameters(self,Â index) Get the parameters for a particle. getSwitchingDistance(self) Get the distance at which the switching function begins to reduce the interaction. getUseSwitchingFunction(self) Get whether a switching function is applied to the interaction. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for interactions. setExceptionParameters(self,Â index,Â â¦) Set the force field parameters for an interaction that should be calculated differently from others. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long range interactions. setParticleParameters(self,Â index,Â sigma,Â â¦) Set the parameters for a particle. setSwitchingDistance(self,Â distance) Set the distance at which the switching function begins to reduce the interaction. setUseSwitchingFunction(self,Â use) Set whether a switching function is applied to the interaction. updateParametersInContext(self,Â context) Update the particle and exception parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes CutoffNonPeriodic CutoffPeriodic NoCutoff thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles for which force field parameters have been defined. getNumExceptions(self) → intÂ¶ Get the number of special interactions that should be calculated differently from other interactions. getNonbondedMethod(self) → OpenMM::GayBerneForce::NonbondedMethodÂ¶ Get the method used for handling long range interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long range interactions. getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm getUseSwitchingFunction(self) → boolÂ¶ Get whether a switching function is applied to the interaction. If the nonbonded method is set to NoCutoff, this option is ignored. setUseSwitchingFunction(self, use)Â¶ Set whether a switching function is applied to the interaction. If the nonbonded method is set to NoCutoff, this option is ignored. getSwitchingDistance(self) → doubleÂ¶ Get the distance at which the switching function begins to reduce the interaction. This must be less than the cutoff distance. setSwitchingDistance(self, distance)Â¶ Set the distance at which the switching function begins to reduce the interaction. This must be less than the cutoff distance. addParticle(self, sigma, epsilon, xparticle, yparticle, sx, sy, sz, ex, ey, ez) → intÂ¶ Add the parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. Parameters sigma (double) â the sigma parameter (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol xparticle (int) â the index of the particle whose position defines the ellipsoidâs x axis, or -1 if the ellipsoid is a sphere yparticle (int) â the index of the particle whose position defines the ellipsoidâs y axis, or -1 if the ellipsoid is axially symmetric sx (double) â the diameter of the ellipsoid along its x axis sy (double) â the diameter of the ellipsoid along its y axis sz (double) â the diameter of the ellipsoid along its z axis ex (double) â the factor by which epsilon is scaled along the ellipsoidâs x axis ey (double) â the factor by which epsilon is scaled along the ellipsoidâs y axis ez (double) â the factor by which epsilon is scaled along the ellipsoidâs z axis Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the parameters for a particle. Parameters index (int) â the index of the particle for which to get parameters Returns sigma (double) â the sigma parameter (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol xparticle (int) â the index of the particle whose position defines the ellipsoidâs x axis, or -1 if the ellipsoid is a sphere yparticle (int) â the index of the particle whose position defines the ellipsoidâs y axis, or -1 if the ellipsoid is axially symmetric sx (double) â the diameter of the ellipsoid along its x axis sy (double) â the diameter of the ellipsoid along its y axis sz (double) â the diameter of the ellipsoid along its z axis ex (double) â the factor by which epsilon is scaled along the ellipsoidâs x axis ey (double) â the factor by which epsilon is scaled along the ellipsoidâs y axis ez (double) â the factor by which epsilon is scaled along the ellipsoidâs z axis setParticleParameters(self, index, sigma, epsilon, xparticle, yparticle, sx, sy, sz, ex, ey, ez)Â¶ Set the parameters for a particle. Parameters index (int) â the index of the particle for which to set parameters sigma (double) â the sigma parameter (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol xparticle (int) â the index of the particle whose position defines the ellipsoidâs x axis, or -1 if the ellipsoid is a sphere yparticle (int) â the index of the particle whose position defines the ellipsoidâs y axis, or -1 if the ellipsoid is axially symmetric sx (double) â the diameter of the ellipsoid along its x axis sy (double) â the diameter of the ellipsoid along its y axis sz (double) â the diameter of the ellipsoid along its z axis ex (double) â the factor by which epsilon is scaled along the ellipsoidâs x axis ey (double) â the factor by which epsilon is scaled along the ellipsoidâs y axis ez (double) â the factor by which epsilon is scaled along the ellipsoidâs z axis addException(self, particle1, particle2, sigma, epsilon, replace=False) → intÂ¶ Add an interaction to the list of exceptions that should be calculated differently from other interactions. If epsilon is equal to 0, this will cause the interaction to be completely omitted from force and energy calculations. Parameters particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction sigma (double) â the sigma parameter (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol replace (bool) â determines the behavior if there is already an exception for the same two particles. If true, the existing one is replaced. If false, an exception is thrown. Returns the index of the exception that was added Return type int getExceptionParameters(self, index)Â¶ Get the force field parameters for an interaction that should be calculated differently from others. Parameters index (int) â the index of the interaction for which to get parameters Returns particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction sigma (double) â the sigma parameter (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol setExceptionParameters(self, index, particle1, particle2, sigma, epsilon)Â¶ Set the force field parameters for an interaction that should be calculated differently from others. If epsilon is equal to 0, this will cause the interaction to be completely omitted from force and energy calculations. Parameters index (int) â the index of the interaction for which to get parameters particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction sigma (double) â the sigma parameter (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol updateParametersInContext(self, context)Â¶ Update the particle and exception parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() and setExceptionParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the parameters of particles and exceptions. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, only the sigma and epsilon values of an exception can be changed; the pair of particles involved in the exception cannot change. Likewise, the xparticle and yparticle defining the orientation of an ellipse cannot be changed. Finally, this method cannot be used to add new particles or exceptions, only to change the parameters of existing ones. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.GBSAOBCForce.html:
GBSAOBCForceÂ¶ class openmm.openmm.GBSAOBCForce(*args)Â¶ This class implements an implicit solvation force using the GBSA-OBC model. To use this class, create a GBSAOBCForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define GBSA parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). When using this Force, the System should also include a NonbondedForce, and both objects must specify identical charges for all particles. Otherwise, the results will not be correct. Furthermore, if the nonbonded method is set to CutoffNonPeriodic or CutoffPeriodic, you should call setReactionFieldDielectric(1.0) on the NonbondedForce to turn off the reaction field approximation, which does not produce correct results when combined with GBSA. __init__(self) → GBSAOBCForceÂ¶ __init__(self, other) → GBSAOBCForce Create a GBSAOBCForce. Methods __init__(->Â GBSAOBCForce) Create a GBSAOBCForce. addParticle(self,Â charge,Â radius,Â scalingFactor) Add the GBSA parameters for a particle. getCutoffDistance(self) Get the cutoff distance (in nm) being used for nonbonded interactions. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long range nonbonded interactions. getNumParticles(self) Get the number of particles in the system. getParticleParameters(self,Â index) Get the force field parameters for a particle. getSoluteDielectric(self) Get the dielectric constant for the solute. getSolventDielectric(self) Get the dielectric constant for the solvent. getSurfaceAreaEnergy(self) Get the energy scale for the surface energy term, measured in kJ/mol/nm^2. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for nonbonded interactions. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long range nonbonded interactions. setParticleParameters(self,Â index,Â charge,Â â¦) Set the force field parameters for a particle. setSoluteDielectric(self,Â dielectric) Set the dielectric constant for the solute. setSolventDielectric(self,Â dielectric) Set the dielectric constant for the solvent. setSurfaceAreaEnergy(self,Â energy) Set the energy scale for the surface energy term, measured in kJ/mol/nm^2. updateParametersInContext(self,Â context) Update the particle parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes CutoffNonPeriodic CutoffPeriodic NoCutoff thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles in the system. addParticle(self, charge, radius, scalingFactor) → intÂ¶ Add the GBSA parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. Parameters charge (double) â the charge of the particle, measured in units of the proton charge radius (double) â the GBSA radius of the particle, measured in nm scalingFactor (double) â the OBC scaling factor for the particle Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the force field parameters for a particle. Parameters index (int) â the index of the particle for which to get parameters Returns charge (double) â the charge of the particle, measured in units of the proton charge radius (double) â the GBSA radius of the particle, measured in nm scalingFactor (double) â the OBC scaling factor for the particle setParticleParameters(self, index, charge, radius, scalingFactor)Â¶ Set the force field parameters for a particle. Parameters index (int) â the index of the particle for which to set parameters charge (double) â the charge of the particle, measured in units of the proton charge radius (double) â the GBSA radius of the particle, measured in nm scalingFactor (double) â the OBC scaling factor for the particle getSolventDielectric(self) → doubleÂ¶ Get the dielectric constant for the solvent. setSolventDielectric(self, dielectric)Â¶ Set the dielectric constant for the solvent. getSoluteDielectric(self) → doubleÂ¶ Get the dielectric constant for the solute. setSoluteDielectric(self, dielectric)Â¶ Set the dielectric constant for the solute. getSurfaceAreaEnergy(self) → doubleÂ¶ Get the energy scale for the surface energy term, measured in kJ/mol/nm^2. setSurfaceAreaEnergy(self, energy)Â¶ Set the energy scale for the surface energy term, measured in kJ/mol/nm^2. getNonbondedMethod(self) → OpenMM::GBSAOBCForce::NonbondedMethodÂ¶ Get the method used for handling long range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long range nonbonded interactions. getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm updateParametersInContext(self, context)Â¶ Update the particle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-particle parameters. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, this method cannot be used to add new particles, only to change the parameters of existing ones. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.HarmonicAngleForce.html:
HarmonicAngleForceÂ¶ class openmm.openmm.HarmonicAngleForce(*args)Â¶ This class implements an interaction between groups of three particles that varies harmonically with the angle between them. To use it, create a HarmonicAngleForce object then call addAngle() once for each angle. After an angle has been added, you can modify its force field parameters by calling setAngleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). __init__(self) → HarmonicAngleForceÂ¶ __init__(self, other) → HarmonicAngleForce Create a HarmonicAngleForce. Methods __init__(->Â HarmonicAngleForce) Create a HarmonicAngleForce. addAngle(self,Â particle1,Â particle2,Â â¦) Add an angle term to the force field. getAngleParameters(self,Â index) Get the force field parameters for an angle term. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNumAngles(self) Get the number of harmonic bond angle terms in the potential function setAngleParameters(self,Â index,Â particle1,Â â¦) Set the force field parameters for an angle term. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-angle parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumAngles(self) → intÂ¶ Get the number of harmonic bond angle terms in the potential function addAngle(self, particle1, particle2, particle3, angle, k) → intÂ¶ Add an angle term to the force field. Parameters particle1 (int) â the index of the first particle forming the angle particle2 (int) â the index of the second particle forming the angle particle3 (int) â the index of the third particle forming the angle angle (double) â the equilibrium angle, measured in radians k (double) â the harmonic force constant for the angle, measured in kJ/mol/radian^2 Returns the index of the angle that was added Return type int getAngleParameters(self, index)Â¶ Get the force field parameters for an angle term. Parameters index (int) â the index of the angle for which to get parameters Returns particle1 (int) â the index of the first particle forming the angle particle2 (int) â the index of the second particle forming the angle particle3 (int) â the index of the third particle forming the angle angle (double) â the equilibrium angle, measured in radians k (double) â the harmonic force constant for the angle, measured in kJ/mol/radian^2 setAngleParameters(self, index, particle1, particle2, particle3, angle, k)Â¶ Set the force field parameters for an angle term. Parameters index (int) â the index of the angle for which to set parameters particle1 (int) â the index of the first particle forming the angle particle2 (int) â the index of the second particle forming the angle particle3 (int) â the index of the third particle forming the angle angle (double) â the equilibrium angle, measured in radians k (double) â the harmonic force constant for the angle, measured in kJ/mol/radian^2 updateParametersInContext(self, context)Â¶ Update the per-angle parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setAngleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-angle parameters. The set of particles involved in a angle cannot be changed, nor can new angles be added. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.HarmonicBondForce.html:
HarmonicBondForceÂ¶ class openmm.openmm.HarmonicBondForce(*args)Â¶ This class implements an interaction between pairs of particles that varies harmonically with the distance between them. To use it, create a HarmonicBondForce object then call addBond() once for each bond. After a bond has been added, you can modify its force field parameters by calling setBondParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). __init__(self) → HarmonicBondForceÂ¶ __init__(self, other) → HarmonicBondForce Create a HarmonicBondForce. Methods __init__(->Â HarmonicBondForce) Create a HarmonicBondForce. addBond(self,Â particle1,Â particle2,Â length,Â k) Add a bond term to the force field. getBondParameters(self,Â index) Get the force field parameters for a bond term. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNumBonds(self) Get the number of harmonic bond stretch terms in the potential function setBondParameters(self,Â index,Â particle1,Â â¦) Set the force field parameters for a bond term. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-bond parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumBonds(self) → intÂ¶ Get the number of harmonic bond stretch terms in the potential function addBond(self, particle1, particle2, length, k) → intÂ¶ Add a bond term to the force field. Parameters particle1 (int) â the index of the first particle connected by the bond particle2 (int) â the index of the second particle connected by the bond length (double) â the equilibrium length of the bond, measured in nm k (double) â the harmonic force constant for the bond, measured in kJ/mol/nm^2 Returns the index of the bond that was added Return type int getBondParameters(self, index)Â¶ Get the force field parameters for a bond term. Parameters index (int) â the index of the bond for which to get parameters Returns particle1 (int) â the index of the first particle connected by the bond particle2 (int) â the index of the second particle connected by the bond length (double) â the equilibrium length of the bond, measured in nm k (double) â the harmonic force constant for the bond, measured in kJ/mol/nm^2 setBondParameters(self, index, particle1, particle2, length, k)Â¶ Set the force field parameters for a bond term. Parameters index (int) â the index of the bond for which to set parameters particle1 (int) â the index of the first particle connected by the bond particle2 (int) â the index of the second particle connected by the bond length (double) â the equilibrium length of the bond, measured in nm k (double) â the harmonic force constant for the bond, measured in kJ/mol/nm^2 updateParametersInContext(self, context)Â¶ Update the per-bond parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setBondParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-bond parameters. The set of particles involved in a bond cannot be changed, nor can new bonds be added. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.HippoNonbondedForce.html:
HippoNonbondedForceÂ¶ class openmm.openmm.HippoNonbondedForce(*args)Â¶ This class implements all nonbonded interactions in the HIPPO force field: electrostatics, induction, charge transfer, dispersion, and repulsion. Although some of these are conceptually distinct, they share parameters in common and are most efficiently computed together. For example, the same multipole definitions are used for both electrostatics and Pauli repulsion. Therefore, all of them are computed by a single Force object. To use it, create a HippoNonbondedForce object, then call addParticle() once for each particle. After an entry has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). You also can specify âexceptionsâ, particular pairs of particles whose interactions should be reduced or completely omitted. Call addException() to define exceptions. __init__(self) → HippoNonbondedForceÂ¶ __init__(self, other) → HippoNonbondedForce Create a HippoNonbondedForce. Methods __init__(->Â HippoNonbondedForce) Create a HippoNonbondedForce. addException(self,Â particle1,Â particle2,Â â¦) Add an interaction to the list of exceptions that should be calculated differently from other interactions. addParticle(self,Â charge,Â dipole,Â â¦) Add the nonbonded force parameters for a particle. getCutoffDistance(self) Get the cutoff distance (in nm) being used for nonbonded interactions. getDPMEParameters(self) Get the parameters to use for dispersion PME calculations. getDPMEParametersInContext(self,Â context) Get the parameters being used for dispersion PME in a particular Context. getEwaldErrorTolerance(self) Get the error tolerance for Ewald summation. getExceptionParameters(self,Â index) Get the scale factors for an interaction that should be calculated differently from others. getExtrapolationCoefficients(self) Get the coefficients for the mu_0, mu_1, mu_2, â¦, mu_n terms in the extrapolation algorithm for induced dipoles. getForceGroup(self) Get the force group this Force belongs to. getInducedDipoles(self,Â context) Get the induced dipole moments of all particles. getLabFramePermanentDipoles(self,Â context) Get the fixed dipole moments of all particles in the global reference frame. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long-range nonbonded interactions. getNumExceptions(self) Get the number of exceptions. getNumParticles(self) Get the number of particles in the potential function. getPMEParameters(self) Get the parameters to use for PME calculations. getPMEParametersInContext(self,Â context) Get the parameters being used for PME in a particular Context. getParticleParameters(self,Â index) Get the nonbonded force parameters for a particle. getSwitchingDistance(self) Get the distance at which the switching function begins to reduce the repulsion and charge transfer interactions. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for nonbonded interactions. setDPMEParameters(self,Â alpha,Â nx,Â ny,Â nz) Set the parameters to use for dispersion PME calculations. setEwaldErrorTolerance(self,Â tol) Get the error tolerance for Ewald summation. setExceptionParameters(self,Â index,Â â¦) Set the scale factors for an interaction that should be calculated differently from others. setExtrapolationCoefficients(self,Â coefficients) Set the coefficients for the mu_0, mu_1, mu_2, â¦, mu_n terms in the extrapolation algorithm for induced dipoles. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long-range nonbonded interactions. setPMEParameters(self,Â alpha,Â nx,Â ny,Â nz) Set the parameters to use for PME calculations. setParticleParameters(self,Â index,Â charge,Â â¦) Set the nonbonded force parameters for a particle. setSwitchingDistance(self,Â distance) Set the distance at which the switching function begins to reduce the repulsion and charge transfer interactions. updateParametersInContext(self,Â context) Update the particle and exception parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes Bisector NoAxisType NoCutoff PME ThreeFold ZBisect ZOnly ZThenX thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles in the potential function. getNumExceptions(self) → intÂ¶ Get the number of exceptions. getNonbondedMethod(self) → OpenMM::HippoNonbondedForce::NonbondedMethodÂ¶ Get the method used for handling long-range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long-range nonbonded interactions. getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm getSwitchingDistance(self) → doubleÂ¶ Get the distance at which the switching function begins to reduce the repulsion and charge transfer interactions. This must be less than the cutoff distance. setSwitchingDistance(self, distance)Â¶ Set the distance at which the switching function begins to reduce the repulsion and charge transfer interactions. This must be less than the cutoff distance. getExtrapolationCoefficients(self) → vectordÂ¶ Get the coefficients for the mu_0, mu_1, mu_2, â¦, mu_n terms in the extrapolation algorithm for induced dipoles. setExtrapolationCoefficients(self, coefficients)Â¶ Set the coefficients for the mu_0, mu_1, mu_2, â¦, mu_n terms in the extrapolation algorithm for induced dipoles. Parameters coefficients (vector< double >) â a vector whose mth entry specifies the coefficient for mu_m. The length of this vector determines how many iterations are performed. getPMEParameters(self)Â¶ Get the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Returns alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis getDPMEParameters(self)Â¶ Get the parameters to use for dispersion PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Returns alpha (double) â the separation parameter nx (int) â the number of dispersion grid points along the X axis ny (int) â the number of dispersion grid points along the Y axis nz (int) â the number of dispersion grid points along the Z axis setPMEParameters(self, alpha, nx, ny, nz)Â¶ Set the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis setDPMEParameters(self, alpha, nx, ny, nz)Â¶ Set the parameters to use for dispersion PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis getPMEParametersInContext(self, context)Â¶ Get the parameters being used for PME in a particular Context. Because some platforms have restrictions on the allowed grid sizes, the values that are actually used may be slightly different from those specified with setPmeGridDimensions(), or the standard values calculated based on the Ewald error tolerance. See the manual for details. Parameters context (Context) â the Context for which to get the parameters Returns alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis getDPMEParametersInContext(self, context)Â¶ Get the parameters being used for dispersion PME in a particular Context. Because some platforms have restrictions on the allowed grid sizes, the values that are actually used may be slightly different from those specified with setPMEParameters(), or the standard values calculated based on the Ewald error tolerance. See the manual for details. Parameters context (Context) â the Context for which to get the parameters Returns alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis addParticle(self, charge, dipole, quadrupole, coreCharge, alpha, epsilon, damping, c6, pauliK, pauliQ, pauliAlpha, polarizability, axisType, multipoleAtomZ, multipoleAtomX, multipoleAtomY) → intÂ¶ Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. Parameters charge (double) â the particleâs charge dipole (vector< double >) â the particleâs molecular dipole (vector of size 3) quadrupole (vector< double >) â the particleâs molecular quadrupole (vector of size 9) coreCharge (double) â the charge of the atomic core alpha (double) â controls the width of the particleâs electron density epsilon (double) â sets the magnitude of charge transfer damping (double) â sets the length scale for charge transfer c6 (double) â the coefficient of the dispersion interaction pauliK (double) â the coefficient of the Pauli repulsion interaction pauliQ (double) â the charge used in computing the Pauli repulsion interaction pauliAlpha (double) â the width of the particleâs electron density for computing the Pauli repulsion interaction polarizability (double) â atomic polarizability axisType (int) â the particleâs axis type multipoleAtomZ (int) â index of first atom used in defining the local coordinate system for multipoles multipoleAtomX (int) â index of second atom used in defining the local coordinate system for multipoles multipoleAtomY (int) â index of third atom used in defining the local coordinate system for multipoles Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to get parameters charge (double) â the particleâs charge dipole (vector< double >) â the particleâs molecular dipole (vector of size 3) quadrupole (vector< double >) â the particleâs molecular quadrupole (vector of size 9) coreCharge (double) â the charge of the atomic core alpha (double) â controls the width of the particleâs electron density epsilon (double) â sets the magnitude of charge transfer damping (double) â sets the length scale for charge transfer c6 (double) â the coefficient of the dispersion interaction pauliK (double) â the coefficient of the Pauli repulsion interaction pauliQ (double) â the charge used in computing the Pauli repulsion interaction pauliAlpha (double) â the width of the particleâs electron density for computing the Pauli repulsion interaction polarizability (double) â atomic polarizability axisType (int) â the particleâs axis type multipoleAtomZ (int) â index of first atom used in defining the local coordinate system for multipoles multipoleAtomX (int) â index of second atom used in defining the local coordinate system for multipoles multipoleAtomY (int) â index of third atom used in defining the local coordinate system for multipoles setParticleParameters(self, index, charge, dipole, quadrupole, coreCharge, alpha, epsilon, damping, c6, pauliK, pauliQ, pauliAlpha, polarizability, axisType, multipoleAtomZ, multipoleAtomX, multipoleAtomY)Â¶ Set the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to set parameters charge (double) â the particleâs charge dipole (vector< double >) â the particleâs molecular dipole (vector of size 3) quadrupole (vector< double >) â the particleâs molecular quadrupole (vector of size 9) coreCharge (double) â the charge of the atomic core alpha (double) â controls the width of the particleâs electron density epsilon (double) â sets the magnitude of charge transfer damping (double) â sets the length scale for charge transfer c6 (double) â the coefficient of the dispersion interaction pauliK (double) â the coefficient of the Pauli repulsion interaction pauliQ (double) â the charge used in computing the Pauli repulsion interaction pauliAlpha (double) â the width of the particleâs electron density for computing the Pauli repulsion interaction polarizability (double) â atomic polarizability axisType (int) â the particleâs axis type multipoleAtomZ (int) â index of first atom used in defining the local coordinate system for multipoles multipoleAtomX (int) â index of second atom used in defining the local coordinate system for multipoles multipoleAtomY (int) â index of third atom used in defining the local coordinate system for multipoles addException(self, particle1, particle2, multipoleMultipoleScale, dipoleMultipoleScale, dipoleDipoleScale, dispersionScale, repulsionScale, chargeTransferScale, replace=False) → intÂ¶ Add an interaction to the list of exceptions that should be calculated differently from other interactions. If all scale factors are set to 0, this will cause the interaction to be completely omitted from force and energy calculations. Parameters particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction multipoleMultipoleScale (double) â the factor by which to scale the Coulomb interaction between fixed multipoles dipoleMultipoleScale (double) â the factor by which to scale the Coulomb interaction between an induced dipole and a fixed multipole dipoleDipoleScale (double) â the factor by which to scale the Coulomb interaction between induced dipoles dispersionScale (double) â the factor by which to scale the dispersion interaction repulsionScale (double) â the factor by which to scale the Pauli repulsion chargeTransferScale (double) â the factor by which to scale the charge transfer interaction replace (bool) â determines the behavior if there is already an exception for the same two particles. If true, the existing one is replaced. If false, an exception is thrown. Returns the index of the exception that was added Return type int getExceptionParameters(self, index)Â¶ Get the scale factors for an interaction that should be calculated differently from others. Parameters index (int) â the index of the interaction for which to get parameters particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction multipoleMultipoleScale (double) â the factor by which to scale the Coulomb interaction between fixed multipoles dipoleMultipoleScale (double) â the factor by which to scale the Coulomb interaction between an induced dipole and a fixed multipole dipoleDipoleScale (double) â the factor by which to scale the Coulomb interaction between induced dipoles dispersionScale (double) â the factor by which to scale the dispersion interaction repulsionScale (double) â the factor by which to scale the Pauli repulsion chargeTransferScale (double) â the factor by which to scale the charge transfer interaction setExceptionParameters(self, index, particle1, particle2, multipoleMultipoleScale, dipoleMultipoleScale, dipoleDipoleScale, dispersionScale, repulsionScale, chargeTransferScale)Â¶ Set the scale factors for an interaction that should be calculated differently from others. If all scale factors are set to 0, this will cause the interaction to be completely omitted from force and energy calculations. Parameters index (int) â the index of the interaction for which to set parameters particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction multipoleMultipoleScale (double) â the factor by which to scale the Coulomb interaction between fixed multipoles dipoleMultipoleScale (double) â the factor by which to scale the Coulomb interaction between an induced dipole and a fixed multipole dipoleDipoleScale (double) â the factor by which to scale the Coulomb interaction between induced dipoles dispersionScale (double) â the factor by which to scale the dispersion interaction repulsionScale (double) â the factor by which to scale the Pauli repulsion chargeTransferScale (double) â the factor by which to scale the charge transfer interaction getEwaldErrorTolerance(self) → doubleÂ¶ Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the grid dimensions and separation (alpha) parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however. This can be overridden by explicitly setting an alpha parameter and grid dimensions to use. setEwaldErrorTolerance(self, tol)Â¶ Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the grid dimensions and separation (alpha) parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however. This can be overridden by explicitly setting an alpha parameter and grid dimensions to use. getLabFramePermanentDipoles(self, context)Â¶ Get the fixed dipole moments of all particles in the global reference frame. Parameters context (Context) â the Context for which to get the fixed dipoles Returns dipoles â the fixed dipole moment of particle i is stored into the iâth element Return type vector< Vec3 > getInducedDipoles(self, context)Â¶ Get the induced dipole moments of all particles. Parameters context (Context) â the Context for which to get the induced dipoles Returns dipoles â the induced dipole moment of particle i is stored into the iâth element Return type vector< Vec3 > updateParametersInContext(self, context)Â¶ Update the particle and exception parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the parameters of particles and exceptions. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, only the scale factors for an exception can be changed; the pair of particles involved in the exception cannot change. Finally, this method cannot be used to add new particles or exceptions, only to change the parameters of existing ones. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if nonbondedMethod uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Integrator.html:
IntegratorÂ¶ class openmm.openmm.Integrator(*args, **kwargs)Â¶ An Integrator defines a method for simulating a System by integrating the equations of motion. This is an abstract class. Subclasses define particular integration methods. Each Integrator object is bound to a particular Context which it integrates. This connection is specified by passing the Integrator as an argument to the constructor of the Context. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) Get which force groups to use for integration. getStepSize(self) Get the size of each time step, in picoseconds. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups) Set which force groups to use for integration. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.LangevinIntegrator.html:
LangevinIntegratorÂ¶ class openmm.openmm.LangevinIntegrator(*args)Â¶ This is an Integrator which simulates a System using Langevin dynamics. __init__(self, temperature, frictionCoeff, stepSize) → LangevinIntegratorÂ¶ __init__(self, other) → LangevinIntegrator Create a LangevinIntegrator. Parameters temperature (double) â the temperature of the heat bath (in Kelvin) frictionCoeff (double) â the friction coefficient which couples the system to the heat bath (in inverse picoseconds) stepSize (double) â the step size with which to integrate the system (in picoseconds) Methods __init__(->Â LangevinIntegrator) Create a LangevinIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getFriction(self) Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). getIntegrationForceGroups(self) Get which force groups to use for integration. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTemperature(self) Get the temperature of the heat bath (in Kelvin). setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setFriction(self,Â coeff) Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). setIntegrationForceGroups(groups) Set which force groups to use for integration. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. setTemperature(self,Â temp) Set the temperature of the heat bath (in Kelvin). step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag getTemperature(self) → doubleÂ¶ Get the temperature of the heat bath (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin Return type double setTemperature(self, temp)Â¶ Set the temperature of the heat bath (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin getFriction(self) → doubleÂ¶ Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Returns the friction coefficient, measured in 1/ps Return type double setFriction(self, coeff)Â¶ Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Parameters coeff (double) â the friction coefficient, measured in 1/ps getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.LangevinMiddleIntegrator.html:
LangevinMiddleIntegratorÂ¶ class openmm.openmm.LangevinMiddleIntegrator(*args)Â¶ This is an Integrator which simulates a System using Langevin dynamics, with the LFMiddle discretization (J. Phys. Chem. A 2019, 123, 28, 6056-6079). This method tend to produce more accurate configurational sampling than other discretizations, such as the one used in LangevinIntegrator. The algorithm is closely related to the BAOAB discretization (Proc. R. Soc. A. 472: 20160138). Both methods produce identical trajectories, but LFMiddle returns half step (leapfrog) velocities, while BAOAB returns on-step velocities. The former provide a much more accurate sampling of the thermal ensemble. __init__(self, temperature, frictionCoeff, stepSize) → LangevinMiddleIntegratorÂ¶ __init__(self, other) → LangevinMiddleIntegrator Create a LangevinMiddleIntegrator. Parameters temperature (double) â the temperature of the heat bath (in Kelvin) frictionCoeff (double) â the friction coefficient which couples the system to the heat bath (in inverse picoseconds) stepSize (double) â the step size with which to integrate the system (in picoseconds) Methods __init__(->Â LangevinMiddleIntegrator) Create a LangevinMiddleIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getFriction(self) Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). getIntegrationForceGroups(self) Get which force groups to use for integration. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTemperature(self) Get the temperature of the heat bath (in Kelvin). setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setFriction(self,Â coeff) Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). setIntegrationForceGroups(groups) Set which force groups to use for integration. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. setTemperature(self,Â temp) Set the temperature of the heat bath (in Kelvin). step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag getTemperature(self) → doubleÂ¶ Get the temperature of the heat bath (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin Return type double setTemperature(self, temp)Â¶ Set the temperature of the heat bath (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin getFriction(self) → doubleÂ¶ Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Returns the friction coefficient, measured in 1/ps Return type double setFriction(self, coeff)Â¶ Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Parameters coeff (double) â the friction coefficient, measured in 1/ps getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Integrator. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.LocalCoordinatesSite.html:
LocalCoordinatesSiteÂ¶ class openmm.openmm.LocalCoordinatesSite(*args)Â¶ This is a VirtualSite that uses the locations of several other particles to compute a local coordinate system, then places the virtual site at a fixed location in that coordinate system. The origin of the coordinate system and the directions of its x and y axes are each specified as a weighted sum of the locations of the other particles: origin = w<sub>1</sub>r<sub>1</sub> + w<sub>2</sub>r<sub>2</sub> + w<sub>3</sub>r<sub>3</sub> + â¦ xdir = w<sub>1</sub>r<sub>1</sub> + w<sub>2</sub>r<sub>2</sub> + w<sub>3</sub>r<sub>3</sub> + â¦ ydir = w<sub>1</sub>r<sub>1</sub> + w<sub>2</sub>r<sub>2</sub> + w<sub>3</sub>r<sub>3</sub> + â¦ For the origin, the weights must add to one. For example if (w<sub>1</sub>, w<sub>2</sub>, w<sub>3</sub>) = (1.0, 0.0, 0.0), the origin of the local coordinate system is at the location of particle 1. For xdir and ydir, the weights must add to zero. For example, if (w<sub>1</sub>, w<sub>2</sub>, w<sub>3</sub>) = (-1.0, 0.5, 0.5), the x axis points from particle 1 toward the midpoint between particles 2 and 3. The z direction is computed as zdir = xdir x ydir. To ensure the axes are all orthogonal, ydir is then recomputed as ydir = zdir x xdir. All three axis vectors are then normalized, and the virtual site location is set to origin + x*xdir + y*ydir + z*zdir __init__(self, particles, originWeights, xWeights, yWeights, localPosition) → LocalCoordinatesSiteÂ¶ __init__(self, particle1, particle2, particle3, originWeights, xWeights, yWeights, localPosition) → LocalCoordinatesSite __init__(self, other) → LocalCoordinatesSite Create a new LocalCoordinatesSite virtual site. This constructor assumes the site depends on exactly three other particles. Parameters particle1 (int) â the index of the first particle particle2 (int) â the index of the second particle particle3 (int) â the index of the third particle originWeights (Vec3) â the weight factors for the three particles when computing the origin location xWeights (Vec3) â the weight factors for the three particles when computing xdir yWeights (Vec3) â the weight factors for the three particles when computing ydir localPosition (Vec3) â the position of the virtual site in the local coordinate system Methods __init__(â¦) Create a new LocalCoordinatesSite virtual site. getLocalPosition(self) Get the position of the virtual site in the local coordinate system. getNumParticles(self) Get the number of particles this virtual site depends on. getOriginWeights(self) Get the weight factors for the particles when computing the origin location. getParticle(self,Â particle) Get the index of a particle this virtual site depends on. getXWeights(self) Get the weight factors for the particles when computing xdir. getYWeights(self) Get the weight factors for the particles when computing ydir. Attributes thisown The membership flag property thisownÂ¶ The membership flag getOriginWeights(self)Â¶ Get the weight factors for the particles when computing the origin location. getXWeights(self)Â¶ Get the weight factors for the particles when computing xdir. getYWeights(self)Â¶ Get the weight factors for the particles when computing ydir. getLocalPosition(self) → Vec3 const &Â¶ Get the position of the virtual site in the local coordinate system. getNumParticles(self) → intÂ¶ Get the number of particles this virtual site depends on. getParticle(self, particle) → intÂ¶ Get the index of a particle this virtual site depends on. Parameters particle (int) â the particle to get (between 0 and getNumParticles()) Returns the index of the particle in the System Return type int

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.LocalEnergyMinimizer.html:
LocalEnergyMinimizerÂ¶ class openmm.openmm.LocalEnergyMinimizer(*args, **kwargs)Â¶ Given a Context, this class searches for a new set of particle positions that represent a local minimum of the potential energy. The search is performed with the L-BFGS algorithm. Distance constraints are enforced during minimization by adding a harmonic restraining force to the potential function. The strength of the restraining force is steadily increased until the minimum energy configuration satisfies all constraints to within the tolerance specified by the Contextâs Integrator. Energy minimization is done using the force groups defined by the Integrator. If you have called setIntegrationForceGroups() on it to restrict the set of forces used for integration, only the energy of the included forces will be minimized. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. minimize(context[,Â tolerance,Â â¦]) Search for a new set of particle positions that represent a local potential energy minimum. Attributes thisown The membership flag property thisownÂ¶ The membership flag static minimize(context, tolerance=10, maxIterations=0, reporter=None)Â¶ Search for a new set of particle positions that represent a local potential energy minimum. On exit, the Context will have been updated with the new positions. Parameters context (Context) â a Context specifying the System to minimize and the initial particle positions tolerance (double) â this specifies how precisely the energy minimum must be located. Minimization will be halted once the root-mean-square value of all force components reaches this tolerance (in kJ/mol/nm). The default value is 10. maxIterations (int) â the maximum number of iterations to perform. If this is 0, minimation is continued until the results converge without regard to how many iterations it takes. The default value is 0. reporter (MinimizationReporter *) â an optional MinimizationReporter to invoke after each iteration. This can be used to monitor the progress of minimization or to stop minimization early.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.MinimizationReporter.html:
MinimizationReporterÂ¶ class openmm.openmm.MinimizationReporter(*args)Â¶ A MinimizationReporter can be passed to LocalEnergyMinimizer::minimize() to provide periodic information on the progress of minimization, and to give you the chance to stop minimization early. Define a subclass that overrides report() and implement it to take whatever action you want. To correctly interpret the information passed to the reporter, you need to know a bit about how the minimizer works. The L-BFGS algorithm used by the minimizer does not support constraints. The minimizer therefore replaces all constraints with harmonic restraints, then performs unconstrained minimization of a combined objective function that is the sum of the systemâs potential energy and the restraint energy. Once minimization completes, it checks whether all constraints are satisfied to an acceptable tolerance. It not, it increases the strength of the harmonic restraints and performs additional minimization. If the error in constrained distances is especially large, it may choose to throw out all work that has been done so far and start over with stronger restraints. This has several important consequences. The objective function being minimized not actually the same as the potential energy. The objective function and the potential energy can both increase between iterations. The total number of iterations performed could be larger than the number specified by the maxIterations argument, if that many iterations leaves unacceptable constraint errors. All work is provisional. It is possible for the minimizer to throw it out and start over. __init__(self) → MinimizationReporterÂ¶ __init__(self, other) → MinimizationReporter A MinimizationReporter can be passed to LocalEnergyMinimizer::minimize() to provide periodic information on the progress of minimization, and to give you the chance to stop minimization early. Define a subclass that overrides report() and implement it to take whatever action you want. To correctly interpret the information passed to the reporter, you need to know a bit about how the minimizer works. The L-BFGS algorithm used by the minimizer does not support constraints. The minimizer therefore replaces all constraints with harmonic restraints, then performs unconstrained minimization of a combined objective function that is the sum of the systemâs potential energy and the restraint energy. Once minimization completes, it checks whether all constraints are satisfied to an acceptable tolerance. It not, it increases the strength of the harmonic restraints and performs additional minimization. If the error in constrained distances is especially large, it may choose to throw out all work that has been done so far and start over with stronger restraints. This has several important consequences. The objective function being minimized not actually the same as the potential energy. The objective function and the potential energy can both increase between iterations. The total number of iterations performed could be larger than the number specified by the maxIterations argument, if that many iterations leaves unacceptable constraint errors. All work is provisional. It is possible for the minimizer to throw it out and start over. Methods __init__(->Â MinimizationReporter) A MinimizationReporter can be passed to LocalEnergyMinimizer::minimize() to provide periodic information on the progress of minimization, and to give you the chance to stop minimization early. report(self,Â iteration,Â x,Â grad) This is called after each iteration to provide information about the current status of minimization. Attributes thisown The membership flag property thisownÂ¶ The membership flag report(self, iteration, x, grad) → boolÂ¶ This is called after each iteration to provide information about the current status of minimization. It receives the current particle coordinates, the gradient of the objective function with respect to them, and a set of useful statistics. In particular, args contains these values: âsystem energyâ: the current potential energy of the system ârestraint energyâ: the energy of the harmonic restraints ârestraint strengthâ: the force constant of the restraints (in kJ/mol/nm^2) âmax constraint errorâ: the maximum relative error in the length of any constraint If this function returns true, it will cause the L-BFGS optimizer to immediately exit. If all constrained distances are sufficiently close to their target values, minimize() will return. If any constraint error is unacceptably large, it will instead cause the minimizer to immediately increase the strength of the harmonic restraints and perform additional optimization. Parameters iteration (int) â the index of the current iteration. This refers to the current call to the L-BFGS optimizer. Each time the minimizer increases the restraint strength, the iteration index is reset to 0. x (vector< double >) â the current particle positions in flattened order: the three coordinates of the first particle, then the three coordinates of the second particle, etc. grad (vector< double >) â the current gradient of the objective function (potential energy plus restraint energy) with respect to the particle coordinates, in flattened order args (map< std::string, double >) â additional statistics described above about the current state of minimization Returns whether to immediately stop minimization Return type bool

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.MonteCarloAnisotropicBarostat.html:
MonteCarloAnisotropicBarostatÂ¶ class openmm.openmm.MonteCarloAnisotropicBarostat(*args)Â¶ This class uses a Monte Carlo algorithm to adjust the size of the periodic box, simulating the effect of constant pressure. This class is similar to MonteCarloBarostat, but each Monte Carlo move is applied to only one axis of the periodic box (unlike MonteCarloBarostat, which scales the entire box isotropically). This means that the box may change shape as well as size over the course of the simulation. It also allows you to specify a different pressure for each axis of the box, or to keep the box size fixed along certain axes while still allowing it to change along others. This class assumes the simulation is also being run at constant temperature, and requires you to specify the system temperature (since it affects the acceptance probability for Monte Carlo moves). It does not actually perform temperature regulation, however. You must use another mechanism along with it to maintain the temperature, such as LangevinIntegrator or AndersenThermostat. __init__(self, defaultPressure, defaultTemperature, scaleX=True, scaleY=True, scaleZ=True, frequency=25) → MonteCarloAnisotropicBarostatÂ¶ __init__(self, other) → MonteCarloAnisotropicBarostat Create a MonteCarloAnisotropicBarostat. Parameters defaultPressure (Vec3) â The default pressure acting on each axis (in bar) defaultTemperature (double) â the default temperature at which the system is being maintained (in Kelvin) scaleX (bool) â whether to allow the X dimension of the periodic box to change size scaleY (bool) â whether to allow the Y dimension of the periodic box to change size scaleZ (bool) â whether to allow the Z dimension of the periodic box to change size frequency (int) â the frequency at which Monte Carlo pressure changes should be attempted (in time steps) Methods PressureX() This is the name of the parameter which stores the current pressure acting on the X-axis (in bar). PressureY() This is the name of the parameter which stores the current pressure acting on the Y-axis (in bar). PressureZ() This is the name of the parameter which stores the current pressure acting on the Z-axis (in bar). Temperature() This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin) __init__(->Â MonteCarloAnisotropicBarostat) Create a MonteCarloAnisotropicBarostat. getDefaultPressure(self) Get the default pressure (in bar). getDefaultTemperature(self) Get the default temperature at which the system is being maintained, measured in Kelvin. getForceGroup(self) Get the force group this Force belongs to. getFrequency(self) Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. getName(self) Get the name of this Force. getRandomNumberSeed(self) Get the random number seed. getScaleX(self) Get whether to allow the X dimension of the periodic box to change size. getScaleY(self) Get whether to allow the Y dimension of the periodic box to change size. getScaleZ(self) Get whether to allow the Z dimension of the periodic box to change size. setDefaultPressure(self,Â pressure) Set the default pressure acting on the system. setDefaultTemperature(self,Â temp) Set the default temperature at which the system is being maintained. setForceGroup(self,Â group) Set the force group this Force belongs to. setFrequency(self,Â freq) Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. setName(self,Â name) Set the name of this Force. setRandomNumberSeed(self,Â seed) Set the random number seed. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag static PressureX() → std::string const &Â¶ This is the name of the parameter which stores the current pressure acting on the X-axis (in bar). static PressureY() → std::string const &Â¶ This is the name of the parameter which stores the current pressure acting on the Y-axis (in bar). static PressureZ() → std::string const &Â¶ This is the name of the parameter which stores the current pressure acting on the Z-axis (in bar). static Temperature() → std::string const &Â¶ This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin) getDefaultPressure(self) → Vec3 const &Â¶ Get the default pressure (in bar). Returns the default pressure acting along each axis, measured in bar. Return type Vec3 setDefaultPressure(self, pressure)Â¶ Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist. Parameters pressure (Vec3) â the default pressure acting on the system, measured in bar. getScaleX(self) → boolÂ¶ Get whether to allow the X dimension of the periodic box to change size. getScaleY(self) → boolÂ¶ Get whether to allow the Y dimension of the periodic box to change size. getScaleZ(self) → boolÂ¶ Get whether to allow the Z dimension of the periodic box to change size. getFrequency(self) → intÂ¶ Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. setFrequency(self, freq)Â¶ Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. getDefaultTemperature(self) → doubleÂ¶ Get the default temperature at which the system is being maintained, measured in Kelvin. setDefaultTemperature(self, temp)Â¶ Set the default temperature at which the system is being maintained. This will affect any new Contexts you create, but not ones that already exist. Parameters temp (double) â the system temperature, measured in Kelvin. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.MonteCarloBarostat.html:
MonteCarloBarostatÂ¶ class openmm.openmm.MonteCarloBarostat(*args)Â¶ This class uses a Monte Carlo algorithm to adjust the size of the periodic box, simulating the effect of constant pressure. This class assumes the simulation is also being run at constant temperature, and requires you to specify the system temperature (since it affects the acceptance probability for Monte Carlo moves). It does not actually perform temperature regulation, however. You must use another mechanism along with it to maintain the temperature, such as LangevinIntegrator or AndersenThermostat. __init__(self, defaultPressure, defaultTemperature, frequency=25) → MonteCarloBarostatÂ¶ __init__(self, other) → MonteCarloBarostat Create a MonteCarloBarostat. Parameters defaultPressure (double) â the default pressure acting on the system (in bar) defaultTemperature (double) â the default temperature at which the system is being maintained (in Kelvin) frequency (int) â the frequency at which Monte Carlo pressure changes should be attempted (in time steps) Methods Pressure() This is the name of the parameter which stores the current pressure acting on the system (in bar). Temperature() This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin) __init__(->Â MonteCarloBarostat) Create a MonteCarloBarostat. getDefaultPressure(self) Get the default pressure acting on the system (in bar). getDefaultTemperature(self) Get the default temperature at which the system is being maintained, measured in Kelvin. getForceGroup(self) Get the force group this Force belongs to. getFrequency(self) Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. getName(self) Get the name of this Force. getRandomNumberSeed(self) Get the random number seed. setDefaultPressure(self,Â pressure) Set the default pressure acting on the system. setDefaultTemperature(self,Â temp) Set the default temperature at which the system is being maintained. setForceGroup(self,Â group) Set the force group this Force belongs to. setFrequency(self,Â freq) Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. setName(self,Â name) Set the name of this Force. setRandomNumberSeed(self,Â seed) Set the random number seed. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag static Pressure() → std::string const &Â¶ This is the name of the parameter which stores the current pressure acting on the system (in bar). static Temperature() → std::string const &Â¶ This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin) getDefaultPressure(self) → doubleÂ¶ Get the default pressure acting on the system (in bar). Returns the default pressure acting on the system, measured in bar. Return type double setDefaultPressure(self, pressure)Â¶ Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist. Parameters pressure (double) â the default pressure acting on the system, measured in bar. getFrequency(self) → intÂ¶ Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. setFrequency(self, freq)Â¶ Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. getDefaultTemperature(self) → doubleÂ¶ Get the default temperature at which the system is being maintained, measured in Kelvin. setDefaultTemperature(self, temp)Â¶ Set the default temperature at which the system is being maintained. This will affect any new Contexts you create, but not ones that already exist. Parameters temp (double) â the system temperature, measured in Kelvin. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.MonteCarloFlexibleBarostat.html:
MonteCarloFlexibleBarostatÂ¶ class openmm.openmm.MonteCarloFlexibleBarostat(*args)Â¶ This class uses a Monte Carlo algorithm to adjust the size and shape of the periodic box, simulating the effect of constant pressure. This class is similar to MonteCarloBarostat, but it simulates a fully flexible periodic box in which all three lengths and all three angles are free to change independently. It is primarily useful for simulations of bulk materials where the shape of a crystalâs unit cell may not be known in advance, or could even change with time as it transitions between phases. Like MonteCarloBarostat, the default behavior of this class is to scale the centroid position of each molecule while holding it rigid. In simulations of materials where all atoms are covalently bonded to each other, this behavior will not work well since the entire system then consists of a single molecule. You can use setScaleMoleculesAsRigid() to disable this behavior and instead have it scale the position of every atom independently. This class assumes the simulation is also being run at constant temperature, and requires you to specify the system temperature (since it affects the acceptance probability for Monte Carlo moves). It does not actually perform temperature regulation, however. You must use another mechanism along with it to maintain the temperature, such as LangevinIntegrator or AndersenThermostat. __init__(self, defaultPressure, defaultTemperature, frequency=25, scaleMoleculesAsRigid=True) → MonteCarloFlexibleBarostatÂ¶ __init__(self, other) → MonteCarloFlexibleBarostat Create a MonteCarloFlexibleBarostat. Parameters defaultPressure (double) â the default pressure acting on the system (in bar) defaultTemperature (double) â the default temperature at which the system is being maintained (in Kelvin) frequency (int) â the frequency at which Monte Carlo pressure changes should be attempted (in time steps) scaleMoleculesAsRigid (bool) â if true, coordinate scaling keeps molecules rigid, scaling only the center of mass of each one. If false, every atom is scaled independently. Methods Pressure() This is the name of the parameter which stores the current pressure acting on the system (in bar). Temperature() This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin) __init__(->Â MonteCarloFlexibleBarostat) Create a MonteCarloFlexibleBarostat. getDefaultPressure(self) Get the default pressure acting on the system (in bar). getDefaultTemperature(self) Get the default temperature at which the system is being maintained, measured in Kelvin. getForceGroup(self) Get the force group this Force belongs to. getFrequency(self) Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. getName(self) Get the name of this Force. getRandomNumberSeed(self) Get the random number seed. getScaleMoleculesAsRigid(self) Get whether scaling is applied to the centroid of each molecule while keeping the molecules rigid, or to each atom independently. setDefaultPressure(self,Â pressure) Set the default pressure acting on the system. setDefaultTemperature(self,Â temp) Set the default temperature at which the system is being maintained. setForceGroup(self,Â group) Set the force group this Force belongs to. setFrequency(self,Â freq) Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. setName(self,Â name) Set the name of this Force. setRandomNumberSeed(self,Â seed) Set the random number seed. setScaleMoleculesAsRigid(self,Â rigid) Set whether scaling is applied to the centroid of each molecule while keeping the molecules rigid, or to each atom independently. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag static Pressure() → std::string const &Â¶ This is the name of the parameter which stores the current pressure acting on the system (in bar). static Temperature() → std::string const &Â¶ This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin) getDefaultPressure(self) → doubleÂ¶ Get the default pressure acting on the system (in bar). Returns the default pressure acting on the system, measured in bar. Return type double setDefaultPressure(self, pressure)Â¶ Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist. Parameters pressure (double) â the default pressure acting on the system, measured in bar. getFrequency(self) → intÂ¶ Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. setFrequency(self, freq)Â¶ Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. getDefaultTemperature(self) → doubleÂ¶ Get the default temperature at which the system is being maintained, measured in Kelvin. setDefaultTemperature(self, temp)Â¶ Set the default temperature at which the system is being maintained. This will affect any new Contexts you create, but not ones that already exist. Parameters temp (double) â the system temperature, measured in Kelvin. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getScaleMoleculesAsRigid(self) → boolÂ¶ Get whether scaling is applied to the centroid of each molecule while keeping the molecules rigid, or to each atom independently. Returns true if scaling is applied to molecule centroids, false if it is applied to each atom independently. Return type bool setScaleMoleculesAsRigid(self, rigid)Â¶ Set whether scaling is applied to the centroid of each molecule while keeping the molecules rigid, or to each atom independently. getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.MonteCarloMembraneBarostat.html:
MonteCarloMembraneBarostatÂ¶ class openmm.openmm.MonteCarloMembraneBarostat(*args)Â¶ This is a Monte Carlo barostat designed specifically for membrane simulations. It assumes the membrane lies in the XY plane. The Monte Carlo acceptance criterion includes a term to model isotropic pressure, which depends on the volume of the periodic box, and a second term to model surface tension, which depends on the cross sectional area of the box in the XY plane. Note that pressure and surface tension are defined with opposite senses: a larger pressure tends to make the box smaller, but a larger surface tension tends to make the box larger. There are options for configuring exactly how the various box dimensions are allowed to change: The X and Y axes may be treated isotropically, in which case they always scale by the same amount and remain in proportion to each other; or they may be treated anisotropically, in which case they can vary independently of each other. The Z axis can be allowed to vary independently of the other axes; or held fixed; or constrained to vary in inverse proportion to the other two axes, so that the total box volume remains fixed. This class assumes the simulation is also being run at constant temperature, and requires you to specify the system temperature (since it affects the acceptance probability for Monte Carlo moves). It does not actually perform temperature regulation, however. You must use another mechanism along with it to maintain the temperature, such as LangevinIntegrator or AndersenThermostat. __init__(self, defaultPressure, defaultSurfaceTension, defaultTemperature, xymode, zmode, frequency=25) → MonteCarloMembraneBarostatÂ¶ __init__(self, other) → MonteCarloMembraneBarostat Create a MonteCarloMembraneBarostat. Parameters defaultPressure (double) â the default pressure acting on the system (in bar) defaultSurfaceTension (double) â the default surface tension acting on the system (in bar*nm) defaultTemperature (double) â the default temperature at which the system is being maintained (in Kelvin) xymode (XYMode) â the mode specifying the behavior of the X and Y axes zmode (ZMode) â the mode specifying the behavior of the Z axis frequency (int) â the frequency at which Monte Carlo volume changes should be attempted (in time steps) Methods Pressure() This is the name of the parameter which stores the current pressure acting on the system (in bar). SurfaceTension() This is the name of the parameter which stores the current surface tension acting on the system (in bar*nm). Temperature() This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin) __init__(->Â MonteCarloMembraneBarostat) Create a MonteCarloMembraneBarostat. getDefaultPressure(self) Get the default pressure acting on the system (in bar). getDefaultSurfaceTension(self) Get the default surface tension acting on the system (in bar*nm). getDefaultTemperature(self) Get the default temperature at which the system is being maintained, measured in Kelvin. getForceGroup(self) Get the force group this Force belongs to. getFrequency(self) Get the frequency (in time steps) at which Monte Carlo volume changes should be attempted. getName(self) Get the name of this Force. getRandomNumberSeed(self) Get the random number seed. getXYMode(self) Get the mode specifying the behavior of the X and Y axes. getZMode(self) Get the mode specifying the behavior of the Z axis. setDefaultPressure(self,Â pressure) Set the default pressure acting on the system. setDefaultSurfaceTension(self,Â surfaceTension) Set the default surface tension acting on the system. setDefaultTemperature(self,Â temp) Set the default temperature at which the system is being maintained. setForceGroup(self,Â group) Set the force group this Force belongs to. setFrequency(self,Â freq) Set the frequency (in time steps) at which Monte Carlo volume changes should be attempted. setName(self,Â name) Set the name of this Force. setRandomNumberSeed(self,Â seed) Set the random number seed. setXYMode(self,Â mode) Set the mode specifying the behavior of the X and Y axes. setZMode(self,Â mode) Set the mode specifying the behavior of the Z axis. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes ConstantVolume XYAnisotropic XYIsotropic ZFixed ZFree thisown The membership flag property thisownÂ¶ The membership flag static Pressure() → std::string const &Â¶ This is the name of the parameter which stores the current pressure acting on the system (in bar). static SurfaceTension() → std::string const &Â¶ This is the name of the parameter which stores the current surface tension acting on the system (in bar*nm). static Temperature() → std::string const &Â¶ This is the name of the parameter which stores the current temperature at which the system is being maintained (in Kelvin) getDefaultPressure(self) → doubleÂ¶ Get the default pressure acting on the system (in bar). Returns the default pressure acting on the system, measured in bar. Return type double setDefaultPressure(self, pressure)Â¶ Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist. Parameters pressure (double) â the default pressure acting on the system, measured in bar. getDefaultSurfaceTension(self) → doubleÂ¶ Get the default surface tension acting on the system (in bar*nm). Returns the default surface tension acting on the system, measured in bar*nm. Return type double setDefaultSurfaceTension(self, surfaceTension)Â¶ Set the default surface tension acting on the system. This will affect any new Contexts you create, but not ones that already exist. Parameters surfaceTension (double) â the default surface tension acting on the system, measured in bar. getFrequency(self) → intÂ¶ Get the frequency (in time steps) at which Monte Carlo volume changes should be attempted. If this is set to 0, the barostat is disabled. setFrequency(self, freq)Â¶ Set the frequency (in time steps) at which Monte Carlo volume changes should be attempted. If this is set to 0, the barostat is disabled. getDefaultTemperature(self) → doubleÂ¶ Get the default temperature at which the system is being maintained, measured in Kelvin. setDefaultTemperature(self, temp)Â¶ Set the default temperature at which the system is being maintained. This will affect any new Contexts you create, but not ones that already exist. Parameters temp (double) â the system temperature, measured in Kelvin. getXYMode(self) → OpenMM::MonteCarloMembraneBarostat::XYModeÂ¶ Get the mode specifying the behavior of the X and Y axes. setXYMode(self, mode)Â¶ Set the mode specifying the behavior of the X and Y axes. getZMode(self) → OpenMM::MonteCarloMembraneBarostat::ZModeÂ¶ Get the mode specifying the behavior of the Z axis. setZMode(self, mode)Â¶ Set the mode specifying the behavior of the Z axis. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.NonbondedForce.html:
NonbondedForceÂ¶ class openmm.openmm.NonbondedForce(*args)Â¶ This class implements nonbonded interactions between particles, including a Coulomb force to represent electrostatics and a Lennard-Jones force to represent van der Waals interactions. It optionally supports periodic boundary conditions and cutoffs for long range interactions. Lennard-Jones interactions are calculated with the Lorentz-Berthelot combining rule: it uses the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles. To use this class, create a NonbondedForce object, then call addParticle() once for each particle in the System to define its parameters. The number of particles for which you define nonbonded parameters must be exactly equal to the number of particles in the System, or else an exception will be thrown when you try to create a Context. After a particle has been added, you can modify its force field parameters by calling setParticleParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). NonbondedForce also lets you specify âexceptionsâ, particular pairs of particles whose interactions should be computed based on different parameters than those defined for the individual particles. This can be used to completely exclude certain interactions from the force calculation, or to alter how they interact with each other. Many molecular force fields omit Coulomb and Lennard-Jones interactions between particles separated by one or two bonds, while using modified parameters for those separated by three bonds (known as â1-4 interactionsâ). This class provides a convenience method for this case called createExceptionsFromBonds(). You pass to it a list of bonds and the scale factors to use for 1-4 interactions. It identifies all pairs of particles which are separated by 1, 2, or 3 bonds, then automatically creates exceptions for them. When using a cutoff, by default Lennard-Jones interactions are sharply truncated at the cutoff distance. Optionally you can instead use a switching function to make the interaction smoothly go to zero over a finite distance range. To enable this, call setUseSwitchingFunction(). You must also call setSwitchingDistance() to specify the distance at which the interaction should begin to decrease. The switching distance must be less than the cutoff distance. Another optional feature of this class (enabled by default) is to add a contribution to the energy which approximates the effect of all Lennard-Jones interactions beyond the cutoff in a periodic system. When running a simulation at constant pressure, this can improve the quality of the result. Call setUseDispersionCorrection() to set whether this should be used. In some applications, it is useful to be able to inexpensively change the parameters of small groups of particles. Usually this is done to interpolate between two sets of parameters. For example, a titratable group might have two states it can exist in, each described by a different set of parameters for the atoms that make up the group. You might then want to smoothly interpolate between the two states. This is done by first calling addGlobalParameter() to define a Context parameter, then addParticleParameterOffset() to create a âparameter offsetâ that depends on the Context parameter. Each offset defines the following: A Context parameter used to interpolate between the states. A single particle whose parameters are influenced by the Context parameter. Three scale factors (chargeScale, sigmaScale, and epsilonScale) that specify how the Context parameter affects the particle. The âeffectiveâ parameters for a particle (those used to compute forces) are given by charge = baseCharge + param*chargeScale sigma = baseSigma + param*sigmaScale epsilon = baseEpsilon + param*epsilonScale where the âbaseâ values are the ones specified by addParticle() and âoaramâ is the current value of the Context parameter. A single Context parameter can apply offsets to multiple particles, and multiple parameters can be used to apply offsets to the same particle. Parameters can also be used to modify exceptions in exactly the same way by calling addExceptionParameterOffset(). __init__(self) → NonbondedForceÂ¶ __init__(self, other) → NonbondedForce Create a NonbondedForce. Methods __init__(->Â NonbondedForce) Create a NonbondedForce. addException(self,Â particle1,Â particle2,Â â¦) Add an interaction to the list of exceptions that should be calculated differently from other interactions. addExceptionParameterOffset(self,Â parameter,Â â¦) Add an offset to the parameters of a particular exception, based on a global parameter. addException_usingRMin(particle1,Â particle2,Â â¦) Add interaction exception using the product of the two atomsâ elementary charges, rMin and epsilon, which is standard for AMBER force fields. addGlobalParameter(self,Â name,Â defaultValue) Add a new global parameter that parameter offsets may depend on. addParticle(self,Â charge,Â sigma,Â epsilon) Add the nonbonded force parameters for a particle. addParticleParameterOffset(self,Â parameter,Â â¦) Add an offset to the per-particle parameters of a particular particle, based on a global parameter. addParticle_usingRVdw(charge,Â rVDW,Â epsilon) Add particle using elemetrary charge. createExceptionsFromBonds(self,Â bonds,Â â¦) Identify exceptions based on the molecular topology. getCutoffDistance(self) Get the cutoff distance (in nm) being used for nonbonded interactions. getEwaldErrorTolerance(self) Get the error tolerance for Ewald summation. getExceptionParameterOffset(self,Â index) Get the offset added to the parameters of a particular exception, based on a global parameter. getExceptionParameters(self,Â index) Get the force field parameters for an interaction that should be calculated differently from others. getExceptionsUsePeriodicBoundaryConditions(self) Get whether periodic boundary conditions should be applied to exceptions. getForceGroup(self) Get the force group this Force belongs to. getGlobalParameterDefaultValue(self,Â index) Get the default value of a global parameter. getGlobalParameterName(self,Â index) Get the name of a global parameter. getIncludeDirectSpace(self) Get whether to include direct space interactions when calculating forces and energies. getLJPMEParameters(self) Get the parameters to use for dispersion term in LJ-PME calculations. getLJPMEParametersInContext(self,Â context) Get the PME parameters being used for the dispersion term for LJPME in a particular Context. getName(self) Get the name of this Force. getNonbondedMethod(self) Get the method used for handling long range nonbonded interactions. getNumExceptionParameterOffsets(self) Get the number of exception parameter offsets that have been added. getNumExceptions(self) Get the number of special interactions that should be calculated differently from other interactions. getNumGlobalParameters(self) Get the number of global parameters that have been added. getNumParticleParameterOffsets(self) Get the number of particles parameter offsets that have been added. getNumParticles(self) Get the number of particles for which force field parameters have been defined. getPMEParameters(self) Get the parameters to use for PME calculations. getPMEParametersInContext(self,Â context) Get the parameters being used for PME in a particular Context. getParticleParameterOffset(self,Â index) Get the offset added to the per-particle parameters of a particular particle, based on a global parameter. getParticleParameters(self,Â index) Get the nonbonded force parameters for a particle. getReactionFieldDielectric(self) Get the dielectric constant to use for the solvent in the reaction field approximation. getReciprocalSpaceForceGroup(self) Get the force group that reciprocal space interactions for Ewald or PME are included in. getSwitchingDistance(self) Get the distance at which the switching function begins to reduce the Lennard-Jones interaction. getUseDispersionCorrection(self) Get whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. getUseSwitchingFunction(self) Get whether a switching function is applied to the Lennard-Jones interaction. setCutoffDistance(self,Â distance) Set the cutoff distance (in nm) being used for nonbonded interactions. setEwaldErrorTolerance(self,Â tol) Set the error tolerance for Ewald summation. setExceptionParameterOffset(self,Â index,Â â¦) Set the offset added to the parameters of a particular exception, based on a global parameter. setExceptionParameters(self,Â index,Â â¦) Set the force field parameters for an interaction that should be calculated differently from others. setExceptionsUsePeriodicBoundaryConditions(â¦) Set whether periodic boundary conditions should be applied to exceptions. setForceGroup(self,Â group) Set the force group this Force belongs to. setGlobalParameterDefaultValue(self,Â index,Â â¦) Set the default value of a global parameter. setGlobalParameterName(self,Â index,Â name) Set the name of a global parameter. setIncludeDirectSpace(self,Â include) Set whether to include direct space interactions when calculating forces and energies. setLJPMEParameters(self,Â alpha,Â nx,Â ny,Â nz) Set the parameters to use for the dispersion term in LJPME calculations. setName(self,Â name) Set the name of this Force. setNonbondedMethod(self,Â method) Set the method used for handling long range nonbonded interactions. setPMEParameters(self,Â alpha,Â nx,Â ny,Â nz) Set the parameters to use for PME calculations. setParticleParameterOffset(self,Â index,Â â¦) Set the offset added to the per-particle parameters of a particular particle, based on a global parameter. setParticleParameters(self,Â index,Â charge,Â â¦) Set the nonbonded force parameters for a particle. setReactionFieldDielectric(self,Â dielectric) Set the dielectric constant to use for the solvent in the reaction field approximation. setReciprocalSpaceForceGroup(self,Â group) Set the force group that reciprocal space interactions for Ewald or PME are included in. setSwitchingDistance(self,Â distance) Set the distance at which the switching function begins to reduce the Lennard-Jones interaction. setUseDispersionCorrection(self,Â useCorrection) Set whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. setUseSwitchingFunction(self,Â use) Set whether a switching function is applied to the Lennard-Jones interaction. updateParametersInContext(self,Â context) Update the particle and exception parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes CutoffNonPeriodic CutoffPeriodic Ewald LJPME NoCutoff PME thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles for which force field parameters have been defined. getNumExceptions(self) → intÂ¶ Get the number of special interactions that should be calculated differently from other interactions. getNumGlobalParameters(self) → intÂ¶ Get the number of global parameters that have been added. getNumParticleParameterOffsets(self) → intÂ¶ Get the number of particles parameter offsets that have been added. getNumExceptionParameterOffsets(self) → intÂ¶ Get the number of exception parameter offsets that have been added. getNonbondedMethod(self) → OpenMM::NonbondedForce::NonbondedMethodÂ¶ Get the method used for handling long range nonbonded interactions. setNonbondedMethod(self, method)Â¶ Set the method used for handling long range nonbonded interactions. getCutoffDistance(self) → doubleÂ¶ Get the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Returns the cutoff distance, measured in nm Return type double setCutoffDistance(self, distance)Â¶ Set the cutoff distance (in nm) being used for nonbonded interactions. If the NonbondedMethod in use is NoCutoff, this value will have no effect. Parameters distance (double) â the cutoff distance, measured in nm getUseSwitchingFunction(self) → boolÂ¶ Get whether a switching function is applied to the Lennard-Jones interaction. If the nonbonded method is set to NoCutoff, this option is ignored. setUseSwitchingFunction(self, use)Â¶ Set whether a switching function is applied to the Lennard-Jones interaction. If the nonbonded method is set to NoCutoff, this option is ignored. getSwitchingDistance(self) → doubleÂ¶ Get the distance at which the switching function begins to reduce the Lennard-Jones interaction. This must be less than the cutoff distance. setSwitchingDistance(self, distance)Â¶ Set the distance at which the switching function begins to reduce the Lennard-Jones interaction. This must be less than the cutoff distance. getReactionFieldDielectric(self) → doubleÂ¶ Get the dielectric constant to use for the solvent in the reaction field approximation. setReactionFieldDielectric(self, dielectric)Â¶ Set the dielectric constant to use for the solvent in the reaction field approximation. getEwaldErrorTolerance(self) → doubleÂ¶ Get the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however. For PME calculations, if setPMEParameters() is used to set alpha to something other than 0, this value is ignored. setEwaldErrorTolerance(self, tol)Â¶ Set the error tolerance for Ewald summation. This corresponds to the fractional error in the forces which is acceptable. This value is used to select the reciprocal space cutoff and separation parameter so that the average error level will be less than the tolerance. There is not a rigorous guarantee that all forces on all atoms will be less than the tolerance, however. For PME calculations, if setPMEParameters() is used to set alpha to something other than 0, this value is ignored. getPMEParameters(self)Â¶ Get the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Returns alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis getLJPMEParameters(self)Â¶ Get the parameters to use for dispersion term in LJ-PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Returns alpha (double) â the separation parameter nx (int) â the number of dispersion grid points along the X axis ny (int) â the number of dispersion grid points along the Y axis nz (int) â the number of dispersion grid points along the Z axis setPMEParameters(self, alpha, nx, ny, nz)Â¶ Set the parameters to use for PME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis setLJPMEParameters(self, alpha, nx, ny, nz)Â¶ Set the parameters to use for the dispersion term in LJPME calculations. If alpha is 0 (the default), these parameters are ignored and instead their values are chosen based on the Ewald error tolerance. Parameters alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis getPMEParametersInContext(self, context)Â¶ Get the parameters being used for PME in a particular Context. Because some platforms have restrictions on the allowed grid sizes, the values that are actually used may be slightly different from those specified with setPMEParameters(), or the standard values calculated based on the Ewald error tolerance. See the manual for details. Parameters context (Context) â the Context for which to get the parameters Returns alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis getLJPMEParametersInContext(self, context)Â¶ Get the PME parameters being used for the dispersion term for LJPME in a particular Context. Because some platforms have restrictions on the allowed grid sizes, the values that are actually used may be slightly different from those specified with setPMEParameters(), or the standard values calculated based on the Ewald error tolerance. See the manual for details. Parameters context (Context) â the Context for which to get the parameters Returns alpha (double) â the separation parameter nx (int) â the number of grid points along the X axis ny (int) â the number of grid points along the Y axis nz (int) â the number of grid points along the Z axis addParticle(self, charge, sigma, epsilon) → intÂ¶ Add the nonbonded force parameters for a particle. This should be called once for each particle in the System. When it is called for the iâth time, it specifies the parameters for the iâth particle. For calculating the Lennard-Jones interaction between two particles, the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles is used (the Lorentz-Berthelot combining rule). Parameters charge (double) â the charge of the particle, measured in units of the proton charge sigma (double) â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol Returns the index of the particle that was added Return type int getParticleParameters(self, index)Â¶ Get the nonbonded force parameters for a particle. Parameters index (int) â the index of the particle for which to get parameters Returns charge (double) â the charge of the particle, measured in units of the proton charge sigma (double) â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol setParticleParameters(self, index, charge, sigma, epsilon)Â¶ Set the nonbonded force parameters for a particle. When calculating the Lennard-Jones interaction between two particles, it uses the arithmetic mean of the sigmas and the geometric mean of the epsilons for the two interacting particles (the Lorentz-Berthelot combining rule). Parameters index (int) â the index of the particle for which to set parameters charge (double) â the charge of the particle, measured in units of the proton charge sigma (double) â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol addException(self, particle1, particle2, chargeProd, sigma, epsilon, replace=False) → intÂ¶ Add an interaction to the list of exceptions that should be calculated differently from other interactions. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations. Regardless of the NonbondedMethod used by this Force, cutoffs are never applied to exceptions. That is because they are primarily used for 1-4 interactions, which are really a type of bonded interaction and are parametrized together with the other bonded interactions. In many cases, you can use createExceptionsFromBonds() rather than adding each exception explicitly. Parameters particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction chargeProd (double) â the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared sigma (double) â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol replace (bool) â determines the behavior if there is already an exception for the same two particles. If true, the existing one is replaced. If false, an exception is thrown. Returns the index of the exception that was added Return type int getExceptionParameters(self, index)Â¶ Get the force field parameters for an interaction that should be calculated differently from others. Parameters index (int) â the index of the interaction for which to get parameters Returns particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction chargeProd (double) â the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared sigma (double) â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol setExceptionParameters(self, index, particle1, particle2, chargeProd, sigma, epsilon)Â¶ Set the force field parameters for an interaction that should be calculated differently from others. If chargeProd and epsilon are both equal to 0, this will cause the interaction to be completely omitted from force and energy calculations. Regardless of the NonbondedMethod used by this Force, cutoffs are never applied to exceptions. That is because they are primarily used for 1-4 interactions, which are really a type of bonded interaction and are parametrized together with the other bonded interactions. Parameters index (int) â the index of the interaction for which to get parameters particle1 (int) â the index of the first particle involved in the interaction particle2 (int) â the index of the second particle involved in the interaction chargeProd (double) â the scaled product of the atomic charges (i.e. the strength of the Coulomb interaction), measured in units of the proton charge squared sigma (double) â the sigma parameter of the Lennard-Jones potential (corresponding to the van der Waals radius of the particle), measured in nm epsilon (double) â the epsilon parameter of the Lennard-Jones potential (corresponding to the well depth of the van der Waals interaction), measured in kJ/mol createExceptionsFromBonds(self, bonds, coulomb14Scale, lj14Scale)Â¶ Identify exceptions based on the molecular topology. Particles which are separated by one or two bonds are set to not interact at all, while pairs of particles separated by three bonds (known as â1-4 interactionsâ) have their Coulomb and Lennard-Jones interactions reduced by a fixed factor. Parameters bonds (vector< std::pair< int, int > >) â the set of bonds based on which to construct exceptions. Each element specifies the indices of two particles that are bonded to each other. coulomb14Scale (double) â pairs of particles separated by three bonds will have the strength of their Coulomb interaction multiplied by this factor lj14Scale (double) â pairs of particles separated by three bonds will have the strength of their Lennard-Jones interaction multiplied by this factor addGlobalParameter(self, name, defaultValue) → intÂ¶ Add a new global parameter that parameter offsets may depend on. The default value provided to this method is the initial value of the parameter in newly created Contexts. You can change the value at any time by calling setParameter() on the Context. Parameters name (string) â the name of the parameter defaultValue (double) â the default value of the parameter Returns the index of the parameter that was added Return type int getGlobalParameterName(self, index) → std::string const &Â¶ Get the name of a global parameter. Parameters index (int) â the index of the parameter for which to get the name Returns the parameter name Return type string setGlobalParameterName(self, index, name)Â¶ Set the name of a global parameter. Parameters index (int) â the index of the parameter for which to set the name name (string) â the name of the parameter getGlobalParameterDefaultValue(self, index) → doubleÂ¶ Get the default value of a global parameter. Parameters index (int) â the index of the parameter for which to get the default value Returns the parameter default value Return type double setGlobalParameterDefaultValue(self, index, defaultValue)Â¶ Set the default value of a global parameter. Parameters index (int) â the index of the parameter for which to set the default value defaultValue (double) â the default value of the parameter addParticleParameterOffset(self, parameter, particleIndex, chargeScale, sigmaScale, epsilonScale) → intÂ¶ Add an offset to the per-particle parameters of a particular particle, based on a global parameter. Parameters parameter (string) â the name of the global parameter. It must have already been added with addGlobalParameter(). Its value can be modified at any time by calling Context::setParameter(). particleIndex (int) â the index of the particle whose parameters are affected chargeScale (double) â this value multiplied by the parameter value is added to the particleâs charge sigmaScale (double) â this value multiplied by the parameter value is added to the particleâs sigma epsilonScale (double) â this value multiplied by the parameter value is added to the particleâs epsilon Returns the index of the offset that was added Return type int getParticleParameterOffset(self, index)Â¶ Get the offset added to the per-particle parameters of a particular particle, based on a global parameter. Parameters index (int) â the index of the offset to query, as returned by addParticleParameterOffset() parameter (string) â the name of the global parameter particleIndex (int) â the index of the particle whose parameters are affected chargeScale (double) â this value multiplied by the parameter value is added to the particleâs charge sigmaScale (double) â this value multiplied by the parameter value is added to the particleâs sigma epsilonScale (double) â this value multiplied by the parameter value is added to the particleâs epsilon setParticleParameterOffset(self, index, parameter, particleIndex, chargeScale, sigmaScale, epsilonScale)Â¶ Set the offset added to the per-particle parameters of a particular particle, based on a global parameter. Parameters index (int) â the index of the offset to modify, as returned by addParticleParameterOffset() parameter (string) â the name of the global parameter. It must have already been added with addGlobalParameter(). Its value can be modified at any time by calling Context::setParameter(). particleIndex (int) â the index of the particle whose parameters are affected chargeScale (double) â this value multiplied by the parameter value is added to the particleâs charge sigmaScale (double) â this value multiplied by the parameter value is added to the particleâs sigma epsilonScale (double) â this value multiplied by the parameter value is added to the particleâs epsilon addExceptionParameterOffset(self, parameter, exceptionIndex, chargeProdScale, sigmaScale, epsilonScale) → intÂ¶ Add an offset to the parameters of a particular exception, based on a global parameter. Parameters parameter (string) â the name of the global parameter. It must have already been added with addGlobalParameter(). Its value can be modified at any time by calling Context::setParameter(). exceptionIndex (int) â the index of the exception whose parameters are affected chargeProdScale (double) â this value multiplied by the parameter value is added to the exceptionâs charge product sigmaScale (double) â this value multiplied by the parameter value is added to the exceptionâs sigma epsilonScale (double) â this value multiplied by the parameter value is added to the exceptionâs epsilon Returns the index of the offset that was added Return type int getExceptionParameterOffset(self, index)Â¶ Get the offset added to the parameters of a particular exception, based on a global parameter. Parameters index (int) â the index of the offset to query, as returned by addExceptionParameterOffset() parameter (string) â the name of the global parameter exceptionIndex (int) â the index of the exception whose parameters are affected chargeProdScale (double) â this value multiplied by the parameter value is added to the exceptionâs charge product sigmaScale (double) â this value multiplied by the parameter value is added to the exceptionâs sigma epsilonScale (double) â this value multiplied by the parameter value is added to the exceptionâs epsilon setExceptionParameterOffset(self, index, parameter, exceptionIndex, chargeProdScale, sigmaScale, epsilonScale)Â¶ Set the offset added to the parameters of a particular exception, based on a global parameter. Parameters index (int) â the index of the offset to modify, as returned by addExceptionParameterOffset() parameter (string) â the name of the global parameter. It must have already been added with addGlobalParameter(). Its value can be modified at any time by calling Context::setParameter(). exceptionIndex (int) â the index of the exception whose parameters are affected chargeProdScale (double) â this value multiplied by the parameter value is added to the exceptionâs charge product sigmaScale (double) â this value multiplied by the parameter value is added to the exceptionâs sigma epsilonScale (double) â this value multiplied by the parameter value is added to the exceptionâs epsilon getUseDispersionCorrection(self) → boolÂ¶ Get whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results. setUseDispersionCorrection(self, useCorrection)Â¶ Set whether to add a contribution to the energy that approximately represents the effect of Lennard-Jones interactions beyond the cutoff distance. The energy depends on the volume of the periodic box, and is only applicable when periodic boundary conditions are used. When running simulations at constant pressure, adding this contribution can improve the quality of results. getReciprocalSpaceForceGroup(self) → intÂ¶ Get the force group that reciprocal space interactions for Ewald or PME are included in. This allows multiple time step integrators to evaluate direct and reciprocal space interactions at different intervals: getForceGroup() specifies the group for direct space, and getReciprocalSpaceForceGroup() specifies the group for reciprocal space. If this is -1 (the default value), the same force group is used for reciprocal space as for direct space. setReciprocalSpaceForceGroup(self, group)Â¶ Set the force group that reciprocal space interactions for Ewald or PME are included in. This allows multiple time step integrators to evaluate direct and reciprocal space interactions at different intervals: setForceGroup() specifies the group for direct space, and setReciprocalSpaceForceGroup() specifies the group for reciprocal space. If this is -1 (the default value), the same force group is used for reciprocal space as for direct space. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive), or -1 to use the same force group that is specified for direct space. getIncludeDirectSpace(self) → boolÂ¶ Get whether to include direct space interactions when calculating forces and energies. This is useful if you want to completely replace the direct space calculation, typically with a CustomNonbondedForce that computes it in a nonstandard way, while still using this object for the reciprocal space calculation. setIncludeDirectSpace(self, include)Â¶ Set whether to include direct space interactions when calculating forces and energies. This is useful if you want to completely replace the direct space calculation, typically with a CustomNonbondedForce that computes it in a nonstandard way, while still using this object for the reciprocal space calculation. updateParametersInContext(self, context)Â¶ Update the particle and exception parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setParticleParameters() and setExceptionParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. This method has several limitations. The only information it updates is the parameters of particles and exceptions. All other aspects of the Force (the nonbonded method, the cutoff distance, etc.) are unaffected and can only be changed by reinitializing the Context. Furthermore, only the chargeProd, sigma, and epsilon values of an exception can be changed; the pair of particles involved in the exception cannot change. Finally, this method cannot be used to add new particles or exceptions, only to change the parameters of existing ones. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getExceptionsUsePeriodicBoundaryConditions(self) → boolÂ¶ Get whether periodic boundary conditions should be applied to exceptions. Usually this is not appropriate, because exceptions are normally used to represent bonded interactions (1-2, 1-3, and 1-4 pairs), but there are situations when it does make sense. For example, you may want to simulate an infinite chain where one end of a molecule is bonded to the opposite end of the next periodic copy. Regardless of this value, periodic boundary conditions are only applied to exceptions if they also are applied to other interactions. If the nonbonded method is NoCutoff or CutoffNonPeriodic, this value is ignored. Also note that cutoffs are never applied to exceptions, again because they are normally used to represent bonded interactions. setExceptionsUsePeriodicBoundaryConditions(self, periodic)Â¶ Set whether periodic boundary conditions should be applied to exceptions. Usually this is not appropriate, because exceptions are normally used to represent bonded interactions (1-2, 1-3, and 1-4 pairs), but there are situations when it does make sense. For example, you may want to simulate an infinite chain where one end of a molecule is bonded to the opposite end of the next periodic copy. Regardless of this value, periodic boundary conditions are only applied to exceptions if they also get applied to other interactions. If the nonbonded method is NoCutoff or CutoffNonPeriodic, this value is ignored. Also note that cutoffs are never applied to exceptions, again because they are normally used to represent bonded interactions. addParticle_usingRVdw(charge, rVDW, epsilon)Â¶ Add particle using elemetrary charge. Rvdw and epsilon, which is consistent with AMBER parameter file usage. Note that the sum of the radii of the two interacting atoms is the minimum energy point in the Lennard Jones potential and is often called rMin. The conversion from sigma follows: rVDW = 2^1/6 * sigma/2 addException_usingRMin(particle1, particle2, chargeProd, rMin, epsilon)Â¶ Add interaction exception using the product of the two atomsâ elementary charges, rMin and epsilon, which is standard for AMBER force fields. Note that rMin is the minimum energy point in the Lennard Jones potential. The conversion from sigma is: rMin = 2^1/6 * sigma. getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.NoseHooverChain.html:
NoseHooverChainÂ¶ class openmm.openmm.NoseHooverChain(*args)Â¶ This class defines a chain of Nose-Hoover particles to be used as a heat bath to scale the velocities of a collection of particles subject to thermostating. The heat bath is propagated using the multi time step approach detailed in Martyna, M. E. Tuckerman, D. J. Tobias and M. L. Klein, Mol. Phys. 87, 1117 (1996). where the total number of timesteps used to propagate the chain in each step is the number of MTS steps multiplied by the number of terms in the Yoshida-Suzuki decomposition. Two types of NHC may be created. The first is a simple thermostat that couples with a given subset of the atoms within a system, controling their absolute motion. The second is more elaborate and can thermostat tethered pairs of atoms and in this case two thermostats are created: one that controls the absolute center of mass velocity of each pair and another that controls their motion relative to one another. __init__(self, temperature, relativeTemperature, collisionFrequency, relativeCollisionFrequency, numDOFs, chainLength, numMTS, numYoshidaSuzuki, chainID, thermostatedAtoms, thermostatedPairs) → NoseHooverChainÂ¶ __init__(self, other) → NoseHooverChain Create a NoseHooverChain. Parameters temperature (double) â the temperature of the heat bath for absolute motion (in Kelvin) collisionFrequency (double) â the collision frequency for absolute motion (in 1/ps) relativeTemperature (double) â the temperature of the heat bath for relative motion(in Kelvin). This is only used if the list of thermostated pairs is not empty. relativeCollisionFrequency (double) â the collision frequency for relative motion(in 1/ps). This is only used if the list of thermostated pairs is not empty. numDOFs (int) â the number of degrees of freedom in the particles that interact with this chain chainLength (int) â the length of (number of particles in) this heat bath numMTS (int) â the number of multi time steps used to propagate this chain numYoshidaSuzuki (int) â the number of Yoshida Suzuki steps used to propagate this chain (1, 3, 5, or 7). chainID (int) â the chain id used to distinguish this Nose-Hoover chain from others that may be used to control a different set of particles, e.g. for Drude oscillators thermostatedAtoms (vector< int >) â the list of atoms to be handled by this thermostat thermostatedPairs (vector< std::pair< int, int > >) â the list of connected pairs to be thermostated; their absolute center of mass motion will be thermostated independently from their motion relative to one another. Methods __init__(->Â NoseHooverChain) Create a NoseHooverChain. getChainID(self) Get the chain id used to identify this chain getChainLength(self) Get the chain length of this heat bath. getCollisionFrequency(self) Get the collision frequency for treating absolute particle motion (in 1/ps). getNumDegreesOfFreedom(self) Get the number of degrees of freedom in the particles controled by this heat bath. getNumMultiTimeSteps(self) Get the number of steps used in the multi time step propagation. getNumYoshidaSuzukiTimeSteps(self) Get the number of steps used in the Yoshida-Suzuki decomposition for multi time step propagation. getRelativeCollisionFrequency(self) Get the collision frequency for treating relative particle motion (in 1/ps). getRelativeTemperature(self) Get the temperature of the heat bath for treating relative particle motion (in Kelvin). getTemperature(self) Get the temperature of the heat bath for treating absolute particle motion (in Kelvin). getThermostatedAtoms(self) Get the atom ids of all atoms that are thermostated getThermostatedPairs(self) Get the list of any connected pairs to be handled by this thermostat. getYoshidaSuzukiWeights(self) Get the weights used in the Yoshida Suzuki multi time step decomposition (dimensionless) setCollisionFrequency(self,Â frequency) Set the collision frequency for treating absolute particle motion. setNumDegreesOfFreedom(self,Â numDOF) Set the number of degrees of freedom in the particles controled by this heat bath. setRelativeCollisionFrequency(self,Â frequency) Set the collision frequency for treating relative particle motion if this thermostat has been set up to handle connected pairs of atoms. setRelativeTemperature(self,Â temperature) Set the temperature of the heat bath for treating relative motion if this thermostat has been set up to treat connected pairs of atoms. setTemperature(self,Â temperature) Set the temperature of the heat bath for treating absolute particle motion. setThermostatedAtoms(self,Â atomIDs) Set list of atoms that are handled by this thermostat setThermostatedPairs(self,Â pairIDs) In case this thermostat handles the kinetic energy of Drude particles set the atom IDs of all parent atoms. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getTemperature(self) → doubleÂ¶ Get the temperature of the heat bath for treating absolute particle motion (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin. Return type double setTemperature(self, temperature)Â¶ Set the temperature of the heat bath for treating absolute particle motion. This will affect any new Contexts you create, but not ones that already exist. Parameters temperature (double) â the temperature of the heat bath (in Kelvin) getRelativeTemperature(self) → doubleÂ¶ Get the temperature of the heat bath for treating relative particle motion (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin. Return type double setRelativeTemperature(self, temperature)Â¶ Set the temperature of the heat bath for treating relative motion if this thermostat has been set up to treat connected pairs of atoms. This will affect any new Contexts you create, but not ones that already exist. Parameters temperature (double) â the temperature of the heat bath for relative motion (in Kelvin) getCollisionFrequency(self) → doubleÂ¶ Get the collision frequency for treating absolute particle motion (in 1/ps). Returns the collision frequency, measured in 1/ps. Return type double setCollisionFrequency(self, frequency)Â¶ Set the collision frequency for treating absolute particle motion. This will affect any new Contexts you create, but not those that already exist. Parameters frequency (double) â the collision frequency (in 1/ps) getRelativeCollisionFrequency(self) → doubleÂ¶ Get the collision frequency for treating relative particle motion (in 1/ps). Returns the collision frequency, measured in 1/ps. Return type double setRelativeCollisionFrequency(self, frequency)Â¶ Set the collision frequency for treating relative particle motion if this thermostat has been set up to handle connected pairs of atoms. This will affect any new Contexts you create, but not those that already exist. Parameters frequency (double) â the collision frequency (in 1/ps) getNumDegreesOfFreedom(self) → intÂ¶ Get the number of degrees of freedom in the particles controled by this heat bath. Returns the number of degrees of freedom. Return type int setNumDegreesOfFreedom(self, numDOF)Â¶ Set the number of degrees of freedom in the particles controled by this heat bath. This will affect any new Contexts you create, but not those that already exist. Parameters numDOF (int) â the number of degrees of freedom. getChainLength(self) → intÂ¶ Get the chain length of this heat bath. Returns the chain length. Return type int getNumMultiTimeSteps(self) → intÂ¶ Get the number of steps used in the multi time step propagation. Returns the number of multi time steps. Return type int getNumYoshidaSuzukiTimeSteps(self) → intÂ¶ Get the number of steps used in the Yoshida-Suzuki decomposition for multi time step propagation. Returns the number of multi time steps in the Yoshida-Suzuki decomposition. Return type int getChainID(self) → intÂ¶ Get the chain id used to identify this chain Returns the chain id Return type int getThermostatedAtoms(self) → vectoriÂ¶ Get the atom ids of all atoms that are thermostated Returns ids of all atoms that are being handled by this thermostat Return type vector< int > setThermostatedAtoms(self, atomIDs)Â¶ Set list of atoms that are handled by this thermostat Parameters atomIDs (vector< int >) â getThermostatedPairs(self) → vectorpairiiÂ¶ Get the list of any connected pairs to be handled by this thermostat. If this is a regular thermostat, returns an empty vector. Returns list of connected pairs. Return type vector< std::pair< int, int > > setThermostatedPairs(self, pairIDs)Â¶ In case this thermostat handles the kinetic energy of Drude particles set the atom IDs of all parent atoms. Parameters pairIDs (vector< std::pair< int, int > >) â the list of connected pairs to thermostat. getYoshidaSuzukiWeights(self) → vectordÂ¶ Get the weights used in the Yoshida Suzuki multi time step decomposition (dimensionless) Returns the weights for the Yoshida-Suzuki integration Return type vector< double > usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.NoseHooverIntegrator.html:
NoseHooverIntegratorÂ¶ class openmm.openmm.NoseHooverIntegrator(*args)Â¶ This is an Integrator which simulates a System using one or more Nose Hoover chain thermostats, using the âmiddleâ leapfrog propagation algorithm described in J. Phys. Chem. A 2019, 123, 6056-6079. __init__(self, stepSize) → NoseHooverIntegratorÂ¶ __init__(self, temperature, collisionFrequency, stepSize, chainLength=3, numMTS=3, numYoshidaSuzuki=7) → NoseHooverIntegrator __init__(self, other) → NoseHooverIntegrator Create a NoseHooverIntegrator. Parameters temperature (double) â the target temperature for the system (in Kelvin). collisionFrequency (double) â the frequency of the interaction with the heat bath (in inverse picoseconds). stepSize (double) â the step size with which to integrate the system (in picoseconds) chainLength (int) â the number of beads in the Nose-Hoover chain. numMTS (int) â the number of step in the multiple time step chain propagation algorithm. numYoshidaSuzuki (int) â the number of terms in the Yoshida-Suzuki multi time step decomposition used in the chain propagation algorithm (must be 1, 3, 5, or 7). Methods __init__(â¦) Create a NoseHooverIntegrator. addSubsystemThermostat(self,Â â¦[,Â â¦]) Add a Nose-Hoover Chain thermostat to control the temperature of a collection of atoms and/or pairs of connected atoms within the full system. addThermostat(self,Â temperature,Â â¦) Add a simple Nose-Hoover Chain thermostat to control the temperature of the full system computeHeatBathEnergy(self) Compute the total (potential + kinetic) heat bath energy for all heat baths associated with this integrator, at the current time. getCollisionFrequency(self[,Â chainID]) Get the collision frequency for absolute motion of the i-th chain (in 1/picosecond). getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) Get which force groups to use for integration. getMaximumPairDistance(self) Gets the maximum distance (in nm) that a connected pair may stray from each other. getNumThermostats(self) Get the number of Nose-Hoover chains registered with this integrator. getRelativeCollisionFrequency(self[,Â chainID]) Get the collision frequency for pairsâ relative motion of the i-th chain (in 1/picosecond). getRelativeTemperature(self[,Â chainID]) Get the temperature of the i-th chain for controling pairsâ relative particle motion (in Kelvin). getStepSize(self) Get the size of each time step, in picoseconds. getTemperature(self[,Â chainID]) Get the temperature of the i-th chain for controling absolute particle motion (in Kelvin). getThermostat(self[,Â chainID]) Get the NoseHooverChain thermostat hasSubsystemThermostats(self) Return false, if this integrator was set up with the âdefault constructorâ that thermostats the whole system, true otherwise. setCollisionFrequency(self,Â frequency[,Â chainID]) Set the collision frequency for absolute motion of the i-th chain. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups) Set which force groups to use for integration. setMaximumPairDistance(self,Â distance) Sets the maximum distance (in nm) that a connected pair may stray from each other, implemented using a hard wall. setRelativeCollisionFrequency(self,Â frequency) Set the collision frequency for pairsâ relative motion of the i-th chain. setRelativeTemperature(self,Â temperature[,Â â¦]) set the (relative pair motion) temperature of the i-th chain. setStepSize(self,Â size) Set the size of each time step, in picoseconds. setTemperature(self,Â temperature[,Â chainID]) set the (absolute motion) temperature of the i-th chain. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take addThermostat(self, temperature, collisionFrequency, chainLength, numMTS, numYoshidaSuzuki) → intÂ¶ Add a simple Nose-Hoover Chain thermostat to control the temperature of the full system Parameters temperature (double) â the target temperature for the system. collisionFrequency (double) â the frequency of the interaction with the heat bath (in 1/ps). chainLength (int) â the number of beads in the Nose-Hoover chain numMTS (int) â the number of step in the multiple time step chain propagation algorithm. numYoshidaSuzuki (int) â the number of terms in the Yoshida-Suzuki multi time step decomposition used in the chain propagation algorithm (must be 1, 3, 5, or 7). addSubsystemThermostat(self, thermostatedParticles, thermostatedPairs, temperature, collisionFrequency, relativeTemperature, relativeCollisionFrequency, chainLength=3, numMTS=3, numYoshidaSuzuki=7) → intÂ¶ Add a Nose-Hoover Chain thermostat to control the temperature of a collection of atoms and/or pairs of connected atoms within the full system. A list of atoms defining the atoms to be thermostated is provided and the thermostat will only control members of that list. Additionally a list of pairs of connected atoms may be provided; in this case both the center of mass absolute motion of each pair is controlled as well as their motion relative to each other, which is independently thermostated. If both the list of thermostated particles and thermostated pairs are empty all particles will be thermostated. Parameters thermostatedParticles (vector< int >) â list of particle ids to be thermostated. thermostatedPairs (vector< std::pair< int, int > >) â a list of pairs of connected atoms whose absolute center of mass motion and motion relative to one another will be independently thermostated. temperature (double) â the target temperature for each pairâs absolute of center of mass motion. collisionFrequency (double) â the frequency of the interaction with the heat bath for the pairsâ center of mass motion (in 1/ps). relativeTemperature (double) â the target temperature for each pairâs relative motion. relativeCollisionFrequency (double) â the frequency of the interaction with the heat bath for the pairsâ relative motion (in 1/ps). chainLength (int) â the number of beads in the Nose-Hoover chain. numMTS (int) â the number of step in the multiple time step chain propagation algorithm. numYoshidaSuzuki (int) â the number of terms in the Yoshida-Suzuki multi time step decomposition used in the chain propagation algorithm (must be 1, 3, 5, or 7). getTemperature(self, chainID=0) → doubleÂ¶ Get the temperature of the i-th chain for controling absolute particle motion (in Kelvin). Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). Returns the temperature. Return type double setTemperature(self, temperature, chainID=0)Â¶ set the (absolute motion) temperature of the i-th chain. Parameters temperature (double) â the temperature for the Nose-Hoover chain thermostat (in Kelvin). chainID (int) â The id of the Nose-Hoover chain thermostat for which the temperature is set (default=0). getRelativeTemperature(self, chainID=0) → doubleÂ¶ Get the temperature of the i-th chain for controling pairsâ relative particle motion (in Kelvin). Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). Returns the temperature. Return type double setRelativeTemperature(self, temperature, chainID=0)Â¶ set the (relative pair motion) temperature of the i-th chain. Parameters temperature (double) â the temperature for the Nose-Hoover chain thermostat (in Kelvin). chainID (int) â The id of the Nose-Hoover chain thermostat for which the temperature is set (default=0). getCollisionFrequency(self, chainID=0) → doubleÂ¶ Get the collision frequency for absolute motion of the i-th chain (in 1/picosecond). Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). Returns the collision frequency. Return type double setCollisionFrequency(self, frequency, chainID=0)Â¶ Set the collision frequency for absolute motion of the i-th chain. Parameters frequency (double) â the collision frequency in picosecond. chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). getRelativeCollisionFrequency(self, chainID=0) → doubleÂ¶ Get the collision frequency for pairsâ relative motion of the i-th chain (in 1/picosecond). Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). Returns the collision frequency. Return type double setRelativeCollisionFrequency(self, frequency, chainID=0)Â¶ Set the collision frequency for pairsâ relative motion of the i-th chain. Parameters frequency (double) â the collision frequency in picosecond. chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). computeHeatBathEnergy(self) → doubleÂ¶ Compute the total (potential + kinetic) heat bath energy for all heat baths associated with this integrator, at the current time. getNumThermostats(self) → intÂ¶ Get the number of Nose-Hoover chains registered with this integrator. getThermostat(self, chainID=0) → NoseHooverChainÂ¶ Get the NoseHooverChain thermostat Parameters chainID (int) â the index of the Nose-Hoover chain thermostat (default=0). hasSubsystemThermostats(self) → boolÂ¶ Return false, if this integrator was set up with the âdefault constructorâ that thermostats the whole system, true otherwise. Required for serialization. getMaximumPairDistance(self) → doubleÂ¶ Gets the maximum distance (in nm) that a connected pair may stray from each other. If zero, there are no constraints on the intra-pair separation. setMaximumPairDistance(self, distance)Â¶ Sets the maximum distance (in nm) that a connected pair may stray from each other, implemented using a hard wall. If set to zero, the hard wall constraint is omited and the pairs are free to be separated by any distance. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.OutOfPlaneSite.html:
OutOfPlaneSiteÂ¶ class openmm.openmm.OutOfPlaneSite(*args)Â¶ This is a VirtualSite that computes the particle location based on three other particlesâ locations. If r<sub>1</sub> is the location of particle 1, r<sub>12</sub> is the vector from particle 1 to particle 2, and r<sub>13</sub> is the vector from particle 1 to particle 3, then the virtual site location is given by r<sub>1</sub> + w<sub>12</sub>r<sub>12</sub> + w<sub>13</sub>r<sub>13</sub> + w<sub>cross</sub>(r<sub>12</sub> x r<sub>13</sub>) The three weight factors are user-specified. This allows the virtual site location to be out of the plane of the three particles. Note that while w<sub>12</sub> and w<sub>13</sub> are unitless, w<sub>cross</sub> has units of inverse distance. __init__(self, particle1, particle2, particle3, weight12, weight13, weightCross) → OutOfPlaneSiteÂ¶ __init__(self, other) → OutOfPlaneSite Create a new OutOfPlaneSite virtual site. Parameters particle1 (int) â the index of the first particle particle2 (int) â the index of the second particle particle3 (int) â the index of the third particle weight12 (double) â the weight factor for the vector from particle1 to particle2 weight13 (double) â the weight factor for the vector from particle1 to particle3 weightCross (double) â the weight factor for the cross product Methods __init__(->Â OutOfPlaneSite) Create a new OutOfPlaneSite virtual site. getNumParticles(self) Get the number of particles this virtual site depends on. getParticle(self,Â particle) Get the index of a particle this virtual site depends on. getWeight12(self) Get the weight factor for the vector from particle1 to particle2. getWeight13(self) Get the weight factor for the vector from particle1 to particle3. getWeightCross(self) Get the weight factor for the cross product. Attributes thisown The membership flag property thisownÂ¶ The membership flag getWeight12(self) → doubleÂ¶ Get the weight factor for the vector from particle1 to particle2. getWeight13(self) → doubleÂ¶ Get the weight factor for the vector from particle1 to particle3. getWeightCross(self) → doubleÂ¶ Get the weight factor for the cross product. getNumParticles(self) → intÂ¶ Get the number of particles this virtual site depends on. getParticle(self, particle) → intÂ¶ Get the index of a particle this virtual site depends on. Parameters particle (int) â the particle to get (between 0 and getNumParticles()) Returns the index of the particle in the System Return type int

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.PeriodicTorsionForce.html:
PeriodicTorsionForceÂ¶ class openmm.openmm.PeriodicTorsionForce(*args)Â¶ This class implements an interaction between groups of four particles that varies periodically with the torsion angle between them. To use it, create a PeriodicTorsionForce object then call addTorsion() once for each torsion. After a torsion has been added, you can modify its force field parameters by calling setTorsionParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). __init__(self) → PeriodicTorsionForceÂ¶ __init__(self, other) → PeriodicTorsionForce Create a PeriodicTorsionForce. Methods __init__(->Â PeriodicTorsionForce) Create a PeriodicTorsionForce. addTorsion(self,Â particle1,Â particle2,Â â¦) Add a periodic torsion term to the force field. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNumTorsions(self) Get the number of periodic torsion terms in the potential function getTorsionParameters(self,Â index) Get the force field parameters for a periodic torsion term. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setTorsionParameters(self,Â index,Â particle1,Â â¦) Set the force field parameters for a periodic torsion term. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-torsion parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumTorsions(self) → intÂ¶ Get the number of periodic torsion terms in the potential function addTorsion(self, particle1, particle2, particle3, particle4, periodicity, phase, k) → intÂ¶ Add a periodic torsion term to the force field. Parameters particle1 (int) â the index of the first particle forming the torsion particle2 (int) â the index of the second particle forming the torsion particle3 (int) â the index of the third particle forming the torsion particle4 (int) â the index of the fourth particle forming the torsion periodicity (int) â the periodicity of the torsion phase (double) â the phase offset of the torsion, measured in radians k (double) â the force constant for the torsion Returns the index of the torsion that was added Return type int getTorsionParameters(self, index)Â¶ Get the force field parameters for a periodic torsion term. Parameters index (int) â the index of the torsion for which to get parameters Returns particle1 (int) â the index of the first particle forming the torsion particle2 (int) â the index of the second particle forming the torsion particle3 (int) â the index of the third particle forming the torsion particle4 (int) â the index of the fourth particle forming the torsion periodicity (int) â the periodicity of the torsion phase (double) â the phase offset of the torsion, measured in radians k (double) â the force constant for the torsion setTorsionParameters(self, index, particle1, particle2, particle3, particle4, periodicity, phase, k)Â¶ Set the force field parameters for a periodic torsion term. Parameters index (int) â the index of the torsion for which to set parameters particle1 (int) â the index of the first particle forming the torsion particle2 (int) â the index of the second particle forming the torsion particle3 (int) â the index of the third particle forming the torsion particle4 (int) â the index of the fourth particle forming the torsion periodicity (int) â the periodicity of the torsion phase (double) â the phase offset of the torsion, measured in radians k (double) â the force constant for the torsion updateParametersInContext(self, context)Â¶ Update the per-torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setTorsionParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-torsion parameters. The set of particles involved in a torsion cannot be changed, nor can new torsions be added. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.Platform.html:
PlatformÂ¶ class openmm.openmm.Platform(*args, **kwargs)Â¶ A Platform defines an implementation of all the kernels needed to perform some calculation. More precisely, a Platform object acts as a registry for a set of KernelFactory objects which together implement the kernels. The Platform class, in turn, provides a static registry of all available Platform objects. To get a Platform object, call Platform& platform = Platform::findPlatform(kernelNames); passing in the names of all kernels that will be required for the calculation you plan to perform. It will return the fastest available Platform which provides implementations of all the specified kernels. You can then call createKernel() to construct particular kernels as needed. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. findPlatform(kernelNames) Find a Platform which can be used to perform a calculation. getDefaultPluginsDirectory() Get the default directory from which to load plugins. getName(self) Get the name of this platform. getNumPlatforms() Get the number of Platforms that have been registered. getOpenMMVersion() Get a string containing the version number of the OpenMM library. getPlatform(index) Get a registered Platform by index. getPlatformByName(name) Get the registered Platform with a particular name. getPluginLoadFailures() Get any failures caused during the last call to loadPluginsFromDirectory getPropertyDefaultValue(self,Â property) Get the default value of a Platform-specific property. getPropertyNames(self) Get the names of all Platform-specific properties this Platform supports. getPropertyValue(self,Â context,Â property) Get the value of a Platform-specific property for a Context. getSpeed(self) Get an estimate of how fast this Platform class is. linkedContextCreated(self,Â context,Â â¦) This is called whenever a new Context is created using ContextImpl::createLinkedContext(). loadPluginLibrary(file) Load a dynamic library (DLL) which contains an OpenMM plugin. loadPluginsFromDirectory(directory) Load multiple dynamic libraries (DLLs) which contain OpenMM plugins from one or more directories. registerPlatform(platform) Register a new Platform. setPropertyDefaultValue(self,Â property,Â value) Set the default value of a Platform-specific property. setPropertyValue(self,Â context,Â property,Â value) Set the value of a Platform-specific property for a Context. supportsDoublePrecision(self) Get whether this Platform supports double precision arithmetic. supportsKernels(self,Â kernelNames) Determine whether this Platforms provides implementations of a set of kernels. Attributes thisown The membership flag property thisownÂ¶ The membership flag static registerPlatform(platform)Â¶ Register a new Platform. static getNumPlatforms() → intÂ¶ Get the number of Platforms that have been registered. static getPlatform(index) → PlatformÂ¶ Get a registered Platform by index. static getPluginLoadFailures() → vectorstringÂ¶ Get any failures caused during the last call to loadPluginsFromDirectory static getPlatformByName(name) → PlatformÂ¶ Get the registered Platform with a particular name. If no Platform with that name has been registered, this throws an exception. static findPlatform(kernelNames) → PlatformÂ¶ Find a Platform which can be used to perform a calculation. Parameters kernelNames (vector< std::string >) â the names of all kernels which will be needed for the calculation Returns the fastest registered Platform which supports all of the requested kernels. If no Platform exists which supports all of them, this will throw an exception. Return type Platform static loadPluginLibrary(file)Â¶ Load a dynamic library (DLL) which contains an OpenMM plugin. Typically, each Platform is distributed as a separate dynamic library. This method can then be called at runtime to load each available library. Each library should contain an initializer function to register any Platforms and KernelFactories that it contains. If the file does not exist or cannot be loaded, an exception is thrown. Parameters file (string) â the path to the dynamic library file. This is interpreted using the operating systemâs rules for loading libraries. Typically it may be either an absolute path or relative to a set of standard locations. static loadPluginsFromDirectory(directory) → vectorstringÂ¶ Load multiple dynamic libraries (DLLs) which contain OpenMM plugins from one or more directories. Multiple fully-qualified paths can be joined together with â:â on unix-like systems (or â;â on windows-like systems); each will be searched for plugins, in-order. For example, â/foo/plugins:/bar/pluginsâ will search both .. code-block:: c++ /foo/plugins and .. code-block:: c++ /bar/plugins. If an identically-named plugin is encountered twice it will be loaded at both points; be careful!!! This method loops over every file contained in the specified directories and calls loadPluginLibrary() for each one. If an error occurs while trying to load a particular file, that file is simply ignored. You can retrieve a list of all such errors by calling getPluginLoadFailures(). Parameters directory (string) â a â:â (unix) or â;â (windows) deliminated list of paths containing libraries to load Returns the names of all files which were successfully loaded as libraries Return type vector< std::string > static getDefaultPluginsDirectory() → std::string const &Â¶ Get the default directory from which to load plugins. If the environment variable OPENMM_PLUGIN_DIR is set, this returns its value. Otherwise, it returns a platform specific default location. Returns the path to the default plugin directory Return type string static getOpenMMVersion() → std::string const &Â¶ Get a string containing the version number of the OpenMM library. getName(self) → std::string const &Â¶ Get the name of this platform. This should be a unique identifier which can be used to recognized it. getSpeed(self) → doubleÂ¶ Get an estimate of how fast this Platform class is. This need not be precise. It only is expected to return an order or magnitude estimate of the relative performance of different Platform classes. An unoptimized reference implementation should return 1.0, and all other Platforms should return a larger value that is an estimate of how many times faster they are than the reference implementation. supportsDoublePrecision(self) → boolÂ¶ Get whether this Platform supports double precision arithmetic. If this returns false, the platform is permitted to represent double precision values internally as single precision. Deprecated This method is not well defined, and is too simplistic to describe the actual behavior of some Platforms, such as ones that offer multiple precision modes. It will be removed in a future release. getPropertyNames(self) → vectorstringÂ¶ Get the names of all Platform-specific properties this Platform supports. getPropertyValue(self, context, property) → std::string const &Â¶ Get the value of a Platform-specific property for a Context. Parameters context (Context) â the Context for which to get the property property (string) â the name of the property to get Returns the value of the property Return type string setPropertyValue(self, context, property, value)Â¶ Set the value of a Platform-specific property for a Context. Parameters context (Context) â the Context for which to set the property property (string) â the name of the property to set value (string) â the value to set for the property getPropertyDefaultValue(self, property) → std::string const &Â¶ Get the default value of a Platform-specific property. This is the value that will be used for newly created Contexts. Parameters property (string) â the name of the property to get Returns the default value of the property Return type string setPropertyDefaultValue(self, property, value)Â¶ Set the default value of a Platform-specific property. This is the value that will be used for newly created Contexts. Parameters property (string) â the name of the property to set value (string) â the value to set for the property linkedContextCreated(self, context, originalContext)Â¶ This is called whenever a new Context is created using ContextImpl::createLinkedContext(). It gives the Platform a chance to initialize the context and store platform-specific data in it. Parameters context (ContextImpl) â the newly created context originalContext (ContextImpl) â the original context it is linked to supportsKernels(self, kernelNames) → boolÂ¶ Determine whether this Platforms provides implementations of a set of kernels. Parameters kernelNames (vector< std::string >) â the names of the kernels of interests Returns true if this Platform provides implementations of all the kernels in the list, false if there are any which it does not support Return type bool

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.RBTorsionForce.html:
RBTorsionForceÂ¶ class openmm.openmm.RBTorsionForce(*args)Â¶ This class implements an interaction between groups of four particles that varies with the torsion angle between them according to the Ryckaert-Bellemans potential. To use it, create an RBTorsionForce object then call addTorsion() once for each torsion. After a torsion has been added, you can modify its force field parameters by calling setTorsionParameters(). This will have no effect on Contexts that already exist unless you call updateParametersInContext(). __init__(self) → RBTorsionForceÂ¶ __init__(self, other) → RBTorsionForce Create a RBTorsionForce. Methods __init__(->Â RBTorsionForce) Create a RBTorsionForce. addTorsion(self,Â particle1,Â particle2,Â â¦) Add a Ryckaert-Bellemans torsion term to the force field. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getNumTorsions(self) Get the number of Ryckaert-Bellemans torsion terms in the potential function getTorsionParameters(self,Â index) Get the force field parameters for a Ryckaert-Bellemans torsion term. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setTorsionParameters(self,Â index,Â particle1,Â â¦) Set the force field parameters for a Ryckaert-Bellemans torsion term. setUsesPeriodicBoundaryConditions(self,Â periodic) Set whether this force should apply periodic boundary conditions when calculating displacements. updateParametersInContext(self,Â context) Update the per-torsion parameters in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumTorsions(self) → intÂ¶ Get the number of Ryckaert-Bellemans torsion terms in the potential function addTorsion(self, particle1, particle2, particle3, particle4, c0, c1, c2, c3, c4, c5) → intÂ¶ Add a Ryckaert-Bellemans torsion term to the force field. Parameters particle1 (int) â the index of the first particle forming the torsion particle2 (int) â the index of the second particle forming the torsion particle3 (int) â the index of the third particle forming the torsion particle4 (int) â the index of the fourth particle forming the torsion c0 (double) â the coefficient of the constant term, measured in kJ/mol c1 (double) â the coefficient of the 1st order term, measured in kJ/mol c2 (double) â the coefficient of the 2nd order term, measured in kJ/mol c3 (double) â the coefficient of the 3rd order term, measured in kJ/mol c4 (double) â the coefficient of the 4th order term, measured in kJ/mol c5 (double) â the coefficient of the 5th order term, measured in kJ/mol Returns the index of the torsion that was added Return type int getTorsionParameters(self, index)Â¶ Get the force field parameters for a Ryckaert-Bellemans torsion term. Parameters index (int) â the index of the torsion for which to get parameters Returns particle1 (int) â the index of the first particle forming the torsion particle2 (int) â the index of the second particle forming the torsion particle3 (int) â the index of the third particle forming the torsion particle4 (int) â the index of the fourth particle forming the torsion c0 (double) â the coefficient of the constant term, measured in kJ/mol c1 (double) â the coefficient of the 1st order term, measured in kJ/mol c2 (double) â the coefficient of the 2nd order term, measured in kJ/mol c3 (double) â the coefficient of the 3rd order term, measured in kJ/mol c4 (double) â the coefficient of the 4th order term, measured in kJ/mol c5 (double) â the coefficient of the 5th order term, measured in kJ/mol setTorsionParameters(self, index, particle1, particle2, particle3, particle4, c0, c1, c2, c3, c4, c5)Â¶ Set the force field parameters for a Ryckaert-Bellemans torsion term. Parameters index (int) â the index of the torsion for which to set parameters particle1 (int) â the index of the first particle forming the torsion particle2 (int) â the index of the second particle forming the torsion particle3 (int) â the index of the third particle forming the torsion particle4 (int) â the index of the fourth particle forming the torsion c0 (double) â the coefficient of the constant term, measured in kJ/mol c1 (double) â the coefficient of the 1st order term, measured in kJ/mol c2 (double) â the coefficient of the 2nd order term, measured in kJ/mol c3 (double) â the coefficient of the 3rd order term, measured in kJ/mol c4 (double) â the coefficient of the 4th order term, measured in kJ/mol c5 (double) â the coefficient of the 5th order term, measured in kJ/mol updateParametersInContext(self, context)Â¶ Update the per-torsion parameters in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setTorsionParameters() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. The only information this method updates is the values of per-torsion parameters. The set of particles involved in a torsion cannot be changed, nor can new torsions be added. setUsesPeriodicBoundaryConditions(self, periodic)Â¶ Set whether this force should apply periodic boundary conditions when calculating displacements. Usually this is not appropriate for bonded forces, but there are situations when it can be useful. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.RMSDForce.html:
RMSDForceÂ¶ class openmm.openmm.RMSDForce(*args)Â¶ This is a force whose energy equals the root mean squared deviation (RMSD) between the current coordinates and a reference structure. It is intended for use with CustomCVForce. You will not normally want a force that exactly equals the RMSD, but there are many situations where it is useful to have a restraining or biasing force that depends on the RMSD in some way. The force is computed by first aligning the particle positions to the reference structure, then computing the RMSD between the aligned positions and the reference. The computation can optionally be done based on only a subset of the particles in the system. __init__(self, referencePositions, particles=std::vector< int >()) → RMSDForceÂ¶ __init__(self, other) → RMSDForce Create an RMSDForce. Parameters referencePositions (vector< Vec3 >) â the reference positions to compute the deviation from. The length of this vector must equal the number of particles in the system, even if not all particles are used in computing the RMSD. particles (vector< int >) â the indices of the particles to use when computing the RMSD. If this is empty (the default), all particles in the system will be used. Methods __init__()Â ->Â RMSDForce) Create an RMSDForce. getForceGroup(self) Get the force group this Force belongs to. getName(self) Get the name of this Force. getParticles(self) Get the indices of the particles to use when computing the RMSD. getReferencePositions(self) Get the reference positions to compute the deviation from. setForceGroup(self,Â group) Set the force group this Force belongs to. setName(self,Â name) Set the name of this Force. setParticles(self,Â particles) Set the indices of the particles to use when computing the RMSD. setReferencePositions(self,Â positions) Set the reference positions to compute the deviation from. updateParametersInContext(self,Â context) Update the reference positions and particle indices in a Context to match those stored in this Force object. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag getReferencePositions(self) → std::vector< Vec3,std::allocator< Vec3 > > const &Â¶ Get the reference positions to compute the deviation from. setReferencePositions(self, positions)Â¶ Set the reference positions to compute the deviation from. getParticles(self) → vectoriÂ¶ Get the indices of the particles to use when computing the RMSD. If this is empty, all particles in the system will be used. setParticles(self, particles)Â¶ Set the indices of the particles to use when computing the RMSD. If this is empty, all particles in the system will be used. updateParametersInContext(self, context)Â¶ Update the reference positions and particle indices in a Context to match those stored in this Force object. This method provides an efficient method to update certain parameters in an existing Context without needing to reinitialize it. Simply call setReferencePositions() and setParticles() to modify this objectâs parameters, then call updateParametersInContext() to copy them over to the Context. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.RPMDIntegrator.html:
RPMDIntegratorÂ¶ class openmm.openmm.RPMDIntegrator(*args)Â¶ This is an Integrator which simulates a System using ring polymer molecular dynamics (RPMD). It simulates many copies of the System, with successive copies connected by harmonic springs to form a ring. This allows certain quantum mechanical effects to be efficiently simulated. By default this Integrator applies a PILE thermostat to the system to simulate constant temperature dynamics. You can disable the thermostat by calling setApplyThermostat(false). Because this Integrator simulates many copies of the System at once, it must be used differently from other Integrators. Instead of setting positions and velocities by calling methods of the Context, you should use the corresponding methods of the Integrator to set them for specific copies of the System. Similarly, you should retrieve state information for particular copies by calling getState() on the Integrator. Do not query the Context for state information. You can optionally specify a set of âring polymer contractionsâ, by which different force groups are evaluated on different numbers of copies, instead of computing every force on every copy. This can be much more efficient, since different forces may vary widely in how many times they must be evaluated to produce sufficient accuracy. For example, you might simulate a 32 copy ring polymer and evaluate bonded forces on every copy, but contract it down to only 6 copies for computing nonbonded interactions, and down to only a single copy (the centroid) for computing the reciprocal space part of PME. __init__(self, numCopies, temperature, frictionCoeff, stepSize) → RPMDIntegratorÂ¶ __init__(self, numCopies, temperature, frictionCoeff, stepSize, contractions) → RPMDIntegrator __init__(self, other) → RPMDIntegrator Create a RPMDIntegrator. Parameters numCopies (int) â the number of copies of the system that should be simulated temperature (double) â the temperature of the heat bath (in Kelvin) frictionCoeff (double) â the friction coefficient which couples the system to the heat bath (in inverse picoseconds) stepSize (double) â the step size with which to integrator the system (in picoseconds) contractions (map< int, int >) â the ring polymer contractions to use for evaluating different force groups. Each key in the map is the index of a force group, and the corresponding value is the number of copies to evaluate that force group on. If no entry is provided for a force group (the default), it is evaluated independently on every copy. Methods __init__(->Â RPMDIntegrator Â ->Â RPMDIntegrator) Create a RPMDIntegrator. getApplyThermostat(self) Get whether a thermostat is applied to the system. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getContractions(self) Get the ring polymer contractions to use for evaluating different force groups. getFriction(self) Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). getIntegrationForceGroups(self) Get which force groups to use for integration. getNumCopies(self) Get the number of copies of the system being simulated. getRandomNumberSeed(self) Get the random number seed. getState(copy[,Â getPositions,Â â¦]) Get a State object recording the current state information about one copy of the system. getStepSize(self) Get the size of each time step, in picoseconds. getTemperature(self) Get the temperature of the heat bath (in Kelvin). getTotalEnergy(self) Get the total energy of the ring polymer. setApplyThermostat(self,Â apply) Set whether a thermostat is applied to the system. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setFriction(self,Â coeff) Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). setIntegrationForceGroups(groups) Set which force groups to use for integration. setPositions(self,Â copy,Â positions) Set the positions of all particles in one copy of the system. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. setTemperature(self,Â temp) Set the temperature of the heat bath (in Kelvin). setVelocities(self,Â copy,Â velocities) Get the velocities of all particles in one copy of the system. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumCopies(self) → intÂ¶ Get the number of copies of the system being simulated. getTemperature(self) → doubleÂ¶ Get the temperature of the heat bath (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin Return type double setTemperature(self, temp)Â¶ Set the temperature of the heat bath (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin getFriction(self) → doubleÂ¶ Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Returns the friction coefficient, measured in 1/ps Return type double setFriction(self, coeff)Â¶ Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Parameters coeff (double) â the friction coefficient, measured in 1/ps getApplyThermostat(self) → boolÂ¶ Get whether a thermostat is applied to the system. setApplyThermostat(self, apply)Â¶ Set whether a thermostat is applied to the system. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. getContractions(self) → mapiiÂ¶ Get the ring polymer contractions to use for evaluating different force groups. Each key in the map is the index of a force group, and the corresponding value is the number of copies to evaluate that force group on. If no entry is provided for a force group, it is evaluated independently on every copy. setPositions(self, copy, positions)Â¶ Set the positions of all particles in one copy of the system. Parameters copy (int) â the index of the copy for which to set positions positions (vector< Vec3 >) â the positions of all particles in the system setVelocities(self, copy, velocities)Â¶ Get the velocities of all particles in one copy of the system. Parameters copy (int) â the index of the copy for which to set velocities velocities (vector< Vec3 >) â the velocities of all particles in the system getTotalEnergy(self) → doubleÂ¶ Get the total energy of the ring polymer. This includes the potential and kinetic energies of all copies, plus the potential energy of the harmonic springs that link copies together. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take getState(copy, getPositions=False, getVelocities=False, getForces=False, getEnergy=False, getParameters=False, getParameterDerivatives=False, enforcePeriodicBox=False, groups=- 1)Â¶ Get a State object recording the current state information about one copy of the system. Parameters copy (int) â the index of the copy for which to retrieve state information getPositions (bool=False) â whether to store particle positions in the State getVelocities (bool=False) â whether to store particle velocities in the State getForces (bool=False) â whether to store the forces acting on particles in the State getEnergy (bool=False) â whether to store potential and kinetic energy in the State getParameters (bool=False) â whether to store context parameters in the State getParameterDerivatives (bool=False) â whether to store parameter derivatives in the State enforcePeriodicBox (bool=False) â if false, the position of each particle will be whatever position is stored in the Context, regardless of periodic boundary conditions. If true, particle positions will be translated so the center of every molecule lies in the same periodic box. groups (set={0,1,2,...,31}) â a set of indices for which force groups to include when computing forces and energies. The default value includes all groups. groups can also be passed as an unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.RPMDMonteCarloBarostat.html:
RPMDMonteCarloBarostatÂ¶ class openmm.openmm.RPMDMonteCarloBarostat(*args)Â¶ This class is very similar to MonteCarloBarostat, but it is specifically designed for use with RPMDIntegrator. For each trial move, it scales all copies of the system by the same amount, then accepts or rejects the move based on the change to the total energy of the ring polymer (as returned by the integratorâs getTotalEnergy() method). __init__(self, defaultPressure, frequency=25) → RPMDMonteCarloBarostatÂ¶ __init__(self, other) → RPMDMonteCarloBarostat Create a MonteCarloBarostat. Parameters defaultPressure (double) â the default pressure acting on the system (in bar) frequency (int) â the frequency at which Monte Carlo pressure changes should be attempted (in time steps) Methods Pressure() This is the name of the parameter which stores the current pressure acting on the system (in bar). __init__(->Â RPMDMonteCarloBarostat) Create a MonteCarloBarostat. getDefaultPressure(self) Get the default pressure acting on the system (in bar). getForceGroup(self) Get the force group this Force belongs to. getFrequency(self) Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. getName(self) Get the name of this Force. getRandomNumberSeed(self) Get the random number seed. setDefaultPressure(self,Â pressure) Set the default pressure acting on the system. setForceGroup(self,Â group) Set the force group this Force belongs to. setFrequency(self,Â freq) Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. setName(self,Â name) Set the name of this Force. setRandomNumberSeed(self,Â seed) Set the random number seed. usesPeriodicBoundaryConditions(self) Returns whether or not this force makes use of periodic boundary conditions. Attributes thisown The membership flag property thisownÂ¶ The membership flag static Pressure() → std::string const &Â¶ This is the name of the parameter which stores the current pressure acting on the system (in bar). getDefaultPressure(self) → doubleÂ¶ Get the default pressure acting on the system (in bar). Returns the default pressure acting on the system, measured in bar. Return type double setDefaultPressure(self, pressure)Â¶ Set the default pressure acting on the system. This will affect any new Contexts you create, but not ones that already exist. Parameters pressure (double) â the default pressure acting on the system, measured in bar. getFrequency(self) → intÂ¶ Get the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. setFrequency(self, freq)Â¶ Set the frequency (in time steps) at which Monte Carlo pressure changes should be attempted. If this is set to 0, the barostat is disabled. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. It is guaranteed that if two simulations are run with different random number seeds, the sequence of Monte Carlo steps will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not this force makes use of periodic boundary conditions. Returns true if force uses PBC and false otherwise Return type bool getForceGroup(self) → intÂ¶ Get the force group this Force belongs to. getName(self) → std::string const &Â¶ Get the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful. setForceGroup(self, group)Â¶ Set the force group this Force belongs to. Parameters group (int) â the group index. Legal values are between 0 and 31 (inclusive). setName(self, name)Â¶ Set the name of this Force. This is an arbitrary, user modifiable identifier. By default it equals the class name, but you can change it to anything useful.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.SerializationNode.html:
SerializationNodeÂ¶ class openmm.openmm.SerializationNode(*args, **kwargs)Â¶ A SerializationNode stores information about an object during serialization or deserialization. When an object is serialized, its SerializationProxy is first called to copy information about the object into a SerializationNode. That information can then be written to the output stream in the desired format. When an object is deserialized, the input stream is read and the information is stored into a SerializationNode. The appropriate SerializationProxy is then called to reconstruct the object. SerializationNodes are arranged in a tree. There will often be a one-to-one correspondence between objects and SerializationNodes, but that need not always be true. A proxy is free to create whatever child nodes it wants and store information in them using whatever organization is most convenient. Each SerializationNode can store an arbitrary set of âpropertiesâ, represented as key-value pairs. The key is always a string, while the value may be a string, an int, or a double. If a value is specified using one data type and then accessed as a different data type, the node will attempt to convert the value in an appropriate way. For example, it is always reasonable to call getStringProperty() to access a property as a string. Similarly, you can use setStringProperty() to specify a property and then access it using getIntProperty(). This will produce the expected result if the original value was, in fact, the string representation of an int, but if the original string was non-numeric, the result is undefined. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. createChildNode(self,Â name) Create a new child node by serializing an object. getBoolProperty(->Â bool) Get the property with a particular name, specified as a bool. getChildNode(->Â SerializationNode) Get a reference to the child node with a particular name. getChildren(->Â std) Get a reference to this nodeâs child nodes. getDoubleProperty(->Â double) Get the property with a particular name, specified as a double. getIntProperty(->Â int) Get the property with a particular name, specified as an int. getLongProperty(->Â longÂ long) Get the property with a particular name, specified as a long long. getName(self) Get the name of this SerializationNode. getProperties(self) Get a map containing all of this nodeâs properties. getStringProperty(->Â std) Get the property with a particular name, specified as a string. hasProperty(self,Â name) Determine whether this node has a property with a particular node. setBoolProperty(self,Â name,Â value) Set the value of a property, specified as a bool. setDoubleProperty(self,Â name,Â value) Set the value of a property, specified as a double. setIntProperty(self,Â name,Â value) Set the value of a property, specified as an int. setLongProperty(self,Â name,Â value) Set the value of a property, specified as a long long. setName(self,Â name) Set the name of this SerializationNode. setStringProperty(self,Â name,Â value) Set the value of a property, specified as a string. Attributes thisown The membership flag property thisownÂ¶ The membership flag getName(self) → std::string const &Â¶ Get the name of this SerializationNode. setName(self, name)Â¶ Set the name of this SerializationNode. Parameters name (string) â the new name of the SerializationNode getChildren(self) → std::vector< OpenMM::SerializationNode,std::allocator< OpenMM::SerializationNode > > constÂ¶ getChildren(self) → std::vector< OpenMM::SerializationNode,std::allocator< OpenMM::SerializationNode > > & Get a reference to this nodeâs child nodes. getChildNode(self, name) → SerializationNodeÂ¶ getChildNode(self, name) → SerializationNode Get a reference to the child node with a particular name. If there is no child with the specified name, this throws an exception. Parameters the (string) â name of the child node to get getProperties(self) → mapstringstringÂ¶ Get a map containing all of this nodeâs properties. hasProperty(self, name) → boolÂ¶ Determine whether this node has a property with a particular node. Parameters name (string) â the name of the property to check for getStringProperty(self, name) → std::string constÂ¶ getStringProperty(self, name, defaultValue) → std::string const & Get the property with a particular name, specified as a string. If there is no property with the specified name, a default value is returned instead. Parameters name (string) â the name of the property to get defaultValue (string) â the value to return if the specified property does not exist setStringProperty(self, name, value) → SerializationNodeÂ¶ Set the value of a property, specified as a string. Parameters name (string) â the name of the property to set value (string) â the value to set for the property getIntProperty(self, name) → intÂ¶ getIntProperty(self, name, defaultValue) → int Get the property with a particular name, specified as an int. If there is no property with the specified name, a default value is returned instead. Parameters name (string) â the name of the property to get defaultValue (int) â the value to return if the specified property does not exist setIntProperty(self, name, value) → SerializationNodeÂ¶ Set the value of a property, specified as an int. Parameters name (string) â the name of the property to set value (int) â the value to set for the property getLongProperty(self, name) → long longÂ¶ getLongProperty(self, name, defaultValue) → long long Get the property with a particular name, specified as a long long. If there is no property with the specified name, a default value is returned instead. Parameters name (string) â the name of the property to get defaultValue (long long) â the value to return if the specified property does not exist setLongProperty(self, name, value) → SerializationNodeÂ¶ Set the value of a property, specified as a long long. Parameters name (string) â the name of the property to set value (long long) â the value to set for the property getBoolProperty(self, name) → boolÂ¶ getBoolProperty(self, name, defaultValue) → bool Get the property with a particular name, specified as a bool. If there is no property with the specified name, a default value is returned instead. Parameters name (string) â the name of the property to get defaultValue (bool) â the value to return if the specified property does not exist setBoolProperty(self, name, value) → SerializationNodeÂ¶ Set the value of a property, specified as a bool. Parameters name (string) â the name of the property to set value (bool) â the value to set for the property getDoubleProperty(self, name) → doubleÂ¶ getDoubleProperty(self, name, defaultValue) → double Get the property with a particular name, specified as a double. If there is no property with the specified name, a default value is returned instead. Parameters name (string) â the name of the property to get defaultValue (double) â the value to return if the specified property does not exist setDoubleProperty(self, name, value) → SerializationNodeÂ¶ Set the value of a property, specified as a double. Parameters name (string) â the name of the property to set value (double) â the value to set for the property createChildNode(self, name) → SerializationNodeÂ¶ Create a new child node by serializing an object. A SerializationProxy is automatically selected based on the objectâs type, then invoked to populate the newly created node. Note that, while this method is templatized based on the type of object being serialized, the typeid() operator is used to select the proxy. This means the template argument may be a base class, and the correct proxies will still be selected for objects of different subclasses. Parameters name (string) â the name of the new node to create object (T *) â a pointer to the object to serialize Returns a reference to the newly created node Return type SerializationNode

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.SerializationProxy.html:
SerializationProxyÂ¶ class openmm.openmm.SerializationProxy(*args, **kwargs)Â¶ A SerializationProxy is an object that knows how to serialize and deserialize objects of a particular type. This is an abstract class. Subclasses implement the logic for serializing particular types of logic. A global registry maintains the list of what SerializationProxy to use for each type of object. Call registerProxy() to register the proxy for a particular type. This is typically done at application startup or by a dynamic libraryâs initialization code. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. deserialize(self,Â node) Reconstruct an object from its serialized data. getProxy(->Â SerializationProxy) Get the SerializationProxy to use for objects of a particular type, specified by type_info. getTypeName(self) Get the name of the object type this proxy manipulates, as passed to the constructor. registerProxy(type,Â proxy) Register a SerializationProxy to be used for objects of a particular type. serialize(self,Â object,Â node) Subclasses implement this method to record information about an object being serialized. Attributes thisown The membership flag property thisownÂ¶ The membership flag static registerProxy(type, proxy)Â¶ Register a SerializationProxy to be used for objects of a particular type. Parameters type (type_info) â the type_info for the object type proxy (SerializationProxy *) â the proxy to use for objects of the specified type static getProxy(typeName) → SerializationProxyÂ¶ static getProxy(type) → SerializationProxy Get the SerializationProxy to use for objects of a particular type, specified by type_info. Parameters type (type_info) â the type_info of the object type to get a proxy for getTypeName(self) → std::string const &Â¶ Get the name of the object type this proxy manipulates, as passed to the constructor. serialize(self, object, node)Â¶ Subclasses implement this method to record information about an object being serialized. Parameters object (void *) â a pointer to the object being serialized node (SerializationNode) â all data to be serialized should be stored into this node, either directly as properties or indirectly by adding child nodes to it deserialize(self, node) → void *Â¶ Reconstruct an object from its serialized data. Parameters node (SerializationNode) â a SerializationNode containing the objectâs description Returns a pointer to a new object created from the data. The caller assumes ownership of the object. Return type void *

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.State.html:
StateÂ¶ class openmm.openmm.State(*args)Â¶ A State object records a snapshot of the current state of a simulation at a point in time. You create it by calling getState() on a Context. When a State is created, you specify what information should be stored in it. This saves time and memory by only copying in the information that you actually want. This is especially important for forces and energies, since they may need to be calculated. If you query a State object for a piece of information which is not available (because it was not requested when the State was created), it will throw an exception. __init__(self) → StateÂ¶ __init__(self, other) → State Construct an empty State containing no data. This exists so State objects can be used in STL containers. Methods __init__(->Â State) Construct an empty State containing no data. getDataTypes(self) Get which data types are stored in this State. getEnergyParameterDerivatives(self) Get a map containing derivatives of the potential energy with respect to context parameters. getForces([asNumpy]) Get the force acting on each particle with units. getKineticEnergy(self) Get the total kinetic energy of the system. getParameters(self) Get a map containing the values of all parameters. getPeriodicBoxVectors([asNumpy]) Get the vectors defining the axes of the periodic box. getPeriodicBoxVolume(self) Get the volume of the periodic box (measured in nm^3). getPositions([asNumpy]) Get the position of each particle with units. getPotentialEnergy(self) Get the total potential energy of the system. getStepCount(self) Get the number of integration steps that had been performed when this State was created. getTime(self) Get the time for which this State was created. getVelocities([asNumpy]) Get the velocity of each particle with units. Attributes Energy Forces IntegratorParameters ParameterDerivatives Parameters Positions Velocities thisown The membership flag property thisownÂ¶ The membership flag getTime(self) → doubleÂ¶ Get the time for which this State was created. getStepCount(self) → long longÂ¶ Get the number of integration steps that had been performed when this State was created. getKineticEnergy(self) → doubleÂ¶ Get the total kinetic energy of the system. If this State does not contain energies, this will throw an exception. Note that this may be different from simply mv/2 summed over all particles. For example, a leapfrog integrator will store velocities offset by half a step, so they must be adjusted before computing the kinetic energy. This routine returns the kinetic energy at the current time, computed in a way that is appropriate for whatever Integrator is being used. getPotentialEnergy(self) → doubleÂ¶ Get the total potential energy of the system. If this State does not contain energies, this will throw an exception. getPeriodicBoxVolume(self) → doubleÂ¶ Get the volume of the periodic box (measured in nm^3). getParameters(self) → mapstringdoubleÂ¶ Get a map containing the values of all parameters. If this State does not contain parameters, this will throw an exception. getEnergyParameterDerivatives(self) → mapstringdoubleÂ¶ Get a map containing derivatives of the potential energy with respect to context parameters. In most cases derivatives are only calculated if the corresponding Force objects have been specifically told to compute them. Otherwise, the values in the map will be zero. Likewise, if multiple Forces depend on the same parameter but only some have been told to compute derivatives with respect to it, the returned value will include only the contributions from the Forces that were told to compute it. If this State does not contain parameter derivatives, this will throw an exception. getDataTypes(self) → intÂ¶ Get which data types are stored in this State. The return value is a sum of DataType flags. getPeriodicBoxVectors(asNumpy=False)Â¶ Get the vectors defining the axes of the periodic box. getPositions(asNumpy=False)Â¶ Get the position of each particle with units. Raises an exception if positions where not requested in the context.getState() call. Returns a list of Vec3s, unless asNumpy is True, in which case a Numpy array of arrays will be returned. getVelocities(asNumpy=False)Â¶ Get the velocity of each particle with units. Raises an exception if velocities where not requested in the context.getState() call. Returns a list of Vec3s if asNumpy is False, or a Numpy array if asNumpy is True. getForces(asNumpy=False)Â¶ Get the force acting on each particle with units. Raises an exception if forces where not requested in the context.getState() call. Returns a list of Vec3s if asNumpy is False, or a Numpy array if asNumpy is True. __copy__(self) → StateÂ¶

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.System.html:
SystemÂ¶ class openmm.openmm.System(*args)Â¶ This class represents a molecular system. The definition of a System involves four elements: The set of particles in the system The forces acting on them Pairs of particles whose separation should be constrained to a fixed value For periodic systems, the dimensions of the periodic box The particles and constraints are defined directly by the System object, while forces are defined by objects that extend the Force class. After creating a System, call addParticle() once for each particle, addConstraint() for each constraint, and addForce() for each Force. In addition, particles may be designated as âvirtual sitesâ. These are particles whose positions are computed automatically based on the positions of other particles. To define a virtual site, call setVirtualSite(), passing in a VirtualSite object that defines the rules for computing its position. __init__(self) → SystemÂ¶ __init__(self, other) → System Create a new System. Methods __init__(->Â System) Create a new System. addConstraint(self,Â particle1,Â particle2,Â â¦) Add a constraint to the System. addForce(self,Â force) Add a Force to the System. addParticle(self,Â mass) Add a particle to the System. getConstraintParameters(self,Â index) Get the parameters defining a distance constraint. getDefaultPeriodicBoxVectors(self) Get the default values of the vectors defining the axes of the periodic box (measured in nm). getForce(->Â Force) Get a writable reference to one of the Forces in this System. getForces() Get the list of Forces in this System getNumConstraints(self) Get the number of distance constraints in this System. getNumForces(self) Get the number of Force objects that have been added to the System. getNumParticles(self) Get the number of particles in this System. getParticleMass(self,Â index) Get the mass (in atomic mass units) of a particle. getVirtualSite(self,Â index) Get VirtualSite object for a particle. isVirtualSite(self,Â index) Get whether a particle is a VirtualSite. removeConstraint(self,Â index) Remove a constraint from the System. removeForce(self,Â index) Remove a Force from the System. setConstraintParameters(self,Â index,Â â¦) Set the parameters defining a distance constraint. setDefaultPeriodicBoxVectors(self,Â a,Â b,Â c) Set the default values of the vectors defining the axes of the periodic box (measured in nm). setParticleMass(self,Â index,Â mass) Set the mass (in atomic mass units) of a particle. setVirtualSite(self,Â index,Â virtualSite) Set a particle to be a virtual site. usesPeriodicBoundaryConditions(self) Returns whether or not any forces in this System use periodic boundaries. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles in this System. addParticle(self, mass) → intÂ¶ Add a particle to the System. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving. Parameters mass (double) â the mass of the particle (in atomic mass units) Returns the index of the particle that was added Return type int getParticleMass(self, index) → doubleÂ¶ Get the mass (in atomic mass units) of a particle. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving. Parameters index (int) â the index of the particle for which to get the mass setParticleMass(self, index, mass)Â¶ Set the mass (in atomic mass units) of a particle. If the mass is 0, Integrators will ignore the particle and not modify its position or velocity. This is most often used for virtual sites, but can also be used as a way to prevent a particle from moving. Parameters index (int) â the index of the particle for which to set the mass mass (double) â the mass of the particle setVirtualSite(self, index, virtualSite)Â¶ Set a particle to be a virtual site. The VirtualSite object should have been created on the heap with the ânewâ operator. The System takes over ownership of it, and deletes it when the System itself is deleted. Parameters index (int) â the index of the particle that should be treated as a virtual site virtualSite (VirtualSite *) â a pointer to the VirtualSite object describing it isVirtualSite(self, index) → boolÂ¶ Get whether a particle is a VirtualSite. Parameters index (int) â the index of the particle to check getVirtualSite(self, index) → VirtualSiteÂ¶ Get VirtualSite object for a particle. If the particle is not a virtual site, this throws an exception. Parameters index (int) â the index of the particle to get getNumConstraints(self) → intÂ¶ Get the number of distance constraints in this System. addConstraint(self, particle1, particle2, distance) → intÂ¶ Add a constraint to the System. Particles whose mass is 0 cannot participate in constraints. Parameters particle1 (int) â the index of the first particle involved in the constraint particle2 (int) â the index of the second particle involved in the constraint distance (double) â the required distance between the two particles, measured in nm Returns the index of the constraint that was added Return type int getConstraintParameters(self, index)Â¶ Get the parameters defining a distance constraint. Parameters index (int) â the index of the constraint for which to get parameters Returns particle1 (int) â the index of the first particle involved in the constraint particle2 (int) â the index of the second particle involved in the constraint distance (double) â the required distance between the two particles, measured in nm setConstraintParameters(self, index, particle1, particle2, distance)Â¶ Set the parameters defining a distance constraint. Particles whose mass is 0 cannot participate in constraints. Parameters index (int) â the index of the constraint for which to set parameters particle1 (int) â the index of the first particle involved in the constraint particle2 (int) â the index of the second particle involved in the constraint distance (double) â the required distance between the two particles, measured in nm removeConstraint(self, index)Â¶ Remove a constraint from the System. Parameters index (int) â the index of the constraint to remove addForce(self, force) → intÂ¶ Add a Force to the System. The Force should have been created on the heap with the ânewâ operator. The System takes over ownership of it, and deletes the Force when the System itself is deleted. Parameters force (Force *) â a pointer to the Force object to be added Returns the index within the System of the Force that was added Return type int getNumForces(self) → intÂ¶ Get the number of Force objects that have been added to the System. getForce(self, index) → ForceÂ¶ getForce(self, index) → Force Get a writable reference to one of the Forces in this System. Parameters index (int) â the index of the Force to get removeForce(self, index)Â¶ Remove a Force from the System. The memory associated with the removed Force object is deleted. Parameters index (int) â the index of the Force to remove getDefaultPeriodicBoxVectors(self)Â¶ Get the default values of the vectors defining the axes of the periodic box (measured in nm). Any newly created Context will have its box vectors set to these. They will affect any Force added to the System that uses periodic boundary conditions. Returns a (Vec3) â the vector defining the first edge of the periodic box b (Vec3) â the vector defining the second edge of the periodic box c (Vec3) â the vector defining the third edge of the periodic box setDefaultPeriodicBoxVectors(self, a, b, c)Â¶ Set the default values of the vectors defining the axes of the periodic box (measured in nm). Any newly created Context will have its box vectors set to these. They will affect any Force added to the System that uses periodic boundary conditions. Triclinic boxes are supported, but the vectors must satisfy certain requirements. In particular, a must point in the x direction, b must point âmostlyâ in the y direction, and c must point âmostlyâ in the z direction. See the documentation for details. Parameters a (Vec3) â the vector defining the first edge of the periodic box b (Vec3) â the vector defining the second edge of the periodic box c (Vec3) â the vector defining the third edge of the periodic box usesPeriodicBoundaryConditions(self) → boolÂ¶ Returns whether or not any forces in this System use periodic boundaries. If a force in this System does not implement usesPeriodicBoundaryConditions a OpenMM::OpenMMException is thrown Returns true if at least one force uses PBC and false otherwise Return type bool getForces()Â¶ Get the list of Forces in this System __copy__(self) → SystemÂ¶

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.TabulatedFunction.html:
TabulatedFunctionÂ¶ class openmm.openmm.TabulatedFunction(*args, **kwargs)Â¶ A TabulatedFunction uses a set of tabulated values to define a mathematical function. It can be used by various custom forces. TabulatedFunction is an abstract class with concrete subclasses for more specific types of functions. There are subclasses for: 1, 2, and 3 dimensional functions. The dimensionality of a function means the number of input arguments it takes. Continuous and discrete functions. A continuous function is interpolated by fitting a natural cubic spline to the tabulated values. A discrete function is only defined for integer values of its arguments (that is, at the tabulated points), and does not try to interpolate between them. Discrete function can be evaluated more quickly than continuous ones. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods Copy(self) __init__(*args,Â **kwargs) Initialize self. getPeriodic(self) Get the periodicity status of the tabulated function. getUpdateCount(self) Get the value of a counter that is updated every time setFunctionParameters() is called. Attributes thisown The membership flag property thisownÂ¶ The membership flag Copy(self) → TabulatedFunctionÂ¶ Deprecated This will be removed in a future release. getPeriodic(self) → boolÂ¶ Get the periodicity status of the tabulated function. getUpdateCount(self) → intÂ¶ Get the value of a counter that is updated every time setFunctionParameters() is called. This provides a fast way to detect when a function has changed. __eq__(self, other) → boolÂ¶ __ne__(self, other) → boolÂ¶

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.ThreeParticleAverageSite.html:
ThreeParticleAverageSiteÂ¶ class openmm.openmm.ThreeParticleAverageSite(*args)Â¶ This is a VirtualSite that computes the particle location as a weighted average of three other particleâs locations. This means the virtual site is in the plane of the three particles. __init__(self, particle1, particle2, particle3, weight1, weight2, weight3) → ThreeParticleAverageSiteÂ¶ __init__(self, other) → ThreeParticleAverageSite Create a new ThreeParticleAverageSite virtual site. Normally the weights should add up to 1, although this is not strictly required. Parameters particle1 (int) â the index of the first particle particle2 (int) â the index of the second particle particle3 (int) â the index of the third particle weight1 (double) â the weight factor (typically between 0 and 1) for the first particle weight2 (double) â the weight factor (typically between 0 and 1) for the second particle weight3 (double) â the weight factor (typically between 0 and 1) for the third particle Methods __init__(->Â ThreeParticleAverageSite) Create a new ThreeParticleAverageSite virtual site. getNumParticles(self) Get the number of particles this virtual site depends on. getParticle(self,Â particle) Get the index of a particle this virtual site depends on. getWeight(self,Â particle) Get the weight factor used for a particle this virtual site depends on. Attributes thisown The membership flag property thisownÂ¶ The membership flag getWeight(self, particle) → doubleÂ¶ Get the weight factor used for a particle this virtual site depends on. Parameters particle (int) â the particle to get (between 0 and getNumParticles()) Returns the weight factor used for that particle Return type double getNumParticles(self) → intÂ¶ Get the number of particles this virtual site depends on. getParticle(self, particle) → intÂ¶ Get the index of a particle this virtual site depends on. Parameters particle (int) â the particle to get (between 0 and getNumParticles()) Returns the index of the particle in the System Return type int

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.TwoParticleAverageSite.html:
TwoParticleAverageSiteÂ¶ class openmm.openmm.TwoParticleAverageSite(*args)Â¶ This is a VirtualSite that computes the particle location as a weighted average of two other particleâs locations. This means the virtual site is on the line passing through the two particles. __init__(self, particle1, particle2, weight1, weight2) → TwoParticleAverageSiteÂ¶ __init__(self, other) → TwoParticleAverageSite Create a new TwoParticleAverageSite virtual site. Normally weight1 and weight2 should add up to 1, although this is not strictly required. Parameters particle1 (int) â the index of the first particle particle2 (int) â the index of the second particle weight1 (double) â the weight factor (typically between 0 and 1) for the first particle weight2 (double) â the weight factor (typically between 0 and 1) for the second particle Methods __init__(->Â TwoParticleAverageSite) Create a new TwoParticleAverageSite virtual site. getNumParticles(self) Get the number of particles this virtual site depends on. getParticle(self,Â particle) Get the index of a particle this virtual site depends on. getWeight(self,Â particle) Get the weight factor used for a particle this virtual site depends on. Attributes thisown The membership flag property thisownÂ¶ The membership flag getWeight(self, particle) → doubleÂ¶ Get the weight factor used for a particle this virtual site depends on. Parameters particle (int) â the particle to get (between 0 and getNumParticles()) Returns the weight factor used for that particle Return type double getNumParticles(self) → intÂ¶ Get the number of particles this virtual site depends on. getParticle(self, particle) → intÂ¶ Get the index of a particle this virtual site depends on. Parameters particle (int) â the particle to get (between 0 and getNumParticles()) Returns the index of the particle in the System Return type int

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.VariableLangevinIntegrator.html:
VariableLangevinIntegratorÂ¶ class openmm.openmm.VariableLangevinIntegrator(*args)Â¶ This is an error controlled, variable time step Integrator that simulates a System using Langevin dynamics. It compares the result of the Langevin integrator to that of an explicit Euler integrator, takes the difference between the two as a measure of the integration error in each time step, and continuously adjusts the step size to keep the error below a specified tolerance. This both improves the stability of the integrator and allows it to take larger steps on average, while still maintaining comparable accuracy to a fixed step size integrator. It is best not to think of the error tolerance as having any absolute meaning. It is just an adjustable parameter that affects the step size and integration accuracy. You should try different values to find the largest one that produces a trajectory sufficiently accurate for your purposes. 0.001 is often a good starting point. You can optionally set a maximum step size it will ever use. This is useful to prevent it from taking excessively large steps in usual situations, such as when the system is right at a local energy minimum. __init__(self, temperature, frictionCoeff, errorTol) → VariableLangevinIntegratorÂ¶ __init__(self, other) → VariableLangevinIntegrator Create a VariableLangevinIntegrator. Parameters temperature (double) â the temperature of the heat bath (in Kelvin) frictionCoeff (double) â the friction coefficient which couples the system to the heat bath (in inverse picoseconds) errorTol (double) â the error tolerance Methods __init__(->Â VariableLangevinIntegrator) Create a VariableLangevinIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getErrorTolerance(self) Get the error tolerance. getFriction(self) Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). getIntegrationForceGroups(self) Get which force groups to use for integration. getMaximumStepSize(self) Get the maximum step size the integrator will ever use, in ps. getRandomNumberSeed(self) Get the random number seed. getStepSize(self) Get the size of each time step, in picoseconds. getTemperature(self) Get the temperature of the heat bath (in Kelvin). setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setErrorTolerance(self,Â tol) Set the error tolerance. setFriction(self,Â coeff) Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). setIntegrationForceGroups(groups) Set which force groups to use for integration. setMaximumStepSize(self,Â size) Set the maximum step size the integrator will ever use, in ps. setRandomNumberSeed(self,Â seed) Set the random number seed. setStepSize(self,Â size) Set the size of each time step, in picoseconds. setTemperature(self,Â temp) Set the temperature of the heat bath (in Kelvin). step(self,Â steps) Advance a simulation through time by taking a series of time steps. stepTo(self,Â time) Advance a simulation through time by taking a series of steps until a specified time is reached. Attributes thisown The membership flag property thisownÂ¶ The membership flag getTemperature(self) → doubleÂ¶ Get the temperature of the heat bath (in Kelvin). Returns the temperature of the heat bath, measured in Kelvin Return type double setTemperature(self, temp)Â¶ Set the temperature of the heat bath (in Kelvin). Parameters temp (double) â the temperature of the heat bath, measured in Kelvin getFriction(self) → doubleÂ¶ Get the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Returns the friction coefficient, measured in 1/ps Return type double setFriction(self, coeff)Â¶ Set the friction coefficient which determines how strongly the system is coupled to the heat bath (in inverse ps). Parameters coeff (double) â the friction coefficient, measured in 1/ps getErrorTolerance(self) → doubleÂ¶ Get the error tolerance. setErrorTolerance(self, tol)Â¶ Set the error tolerance. getMaximumStepSize(self) → doubleÂ¶ Get the maximum step size the integrator will ever use, in ps. If this is 0 (the default), no limit will be applied to step sizes. setMaximumStepSize(self, size)Â¶ Set the maximum step size the integrator will ever use, in ps. If this is 0 (the default), no limit will be applied to step sizes. getRandomNumberSeed(self) → intÂ¶ Get the random number seed. See setRandomNumberSeed() for details. setRandomNumberSeed(self, seed)Â¶ Set the random number seed. The precise meaning of this parameter is undefined, and is left up to each Platform to interpret in an appropriate way. It is guaranteed that if two simulations are run with different random number seeds, the sequence of random forces will be different. On the other hand, no guarantees are made about the behavior of simulations that use the same seed. In particular, Platforms are permitted to use non-deterministic algorithms which produce different results on successive runs, even if those runs were initialized identically. If seed is set to 0 (which is the default value assigned), a unique seed is chosen when a Context is created from this Force. This is done to ensure that each Context receives unique random seeds without you needing to set them explicitly. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take stepTo(self, time)Â¶ Advance a simulation through time by taking a series of steps until a specified time is reached. When this method returns, the simulation time will exactly equal the time which was specified. If you call this method and specify a time that is earlier than the current time, it will return without doing anything. Parameters time (double) â the time to which the simulation should be advanced getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.VariableVerletIntegrator.html:
VariableVerletIntegratorÂ¶ class openmm.openmm.VariableVerletIntegrator(*args)Â¶ This is an error controlled, variable time step Integrator that simulates a System using the leap-frog Verlet algorithm. It compares the result of the Verlet integrator to that of an explicit Euler integrator, takes the difference between the two as a measure of the integration error in each time step, and continuously adjusts the step size to keep the error below a specified tolerance. This both improves the stability of the integrator and allows it to take larger steps on average, while still maintaining comparable accuracy to a fixed step size integrator. It is best not to think of the error tolerance as having any absolute meaning. It is just an adjustable parameter that affects the step size and integration accuracy. You should try different values to find the largest one that produces a trajectory sufficiently accurate for your purposes. 0.001 is often a good starting point. Unlike a fixed step size Verlet integrator, variable step size Verlet is not symplectic. This means that at a given accuracy level, energy is not as precisely conserved over long time periods. This makes it most appropriate for constant temperate simulations. In constant energy simulations where precise energy conservation over long time periods is important, a fixed step size Verlet integrator may be more appropriate. You can optionally set a maximum step size it will ever use. This is useful to prevent it from taking excessively large steps in usual situations, such as when the system is right at a local energy minimum. __init__(self, errorTol) → VariableVerletIntegratorÂ¶ __init__(self, other) → VariableVerletIntegrator Create a VariableVerletIntegrator. Parameters errorTol (double) â the error tolerance Methods __init__(->Â VariableVerletIntegrator) Create a VariableVerletIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getErrorTolerance(self) Get the error tolerance. getIntegrationForceGroups(self) Get which force groups to use for integration. getMaximumStepSize(self) Get the maximum step size the integrator will ever use, in ps. getStepSize(self) Get the size of each time step, in picoseconds. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setErrorTolerance(self,Â tol) Set the error tolerance. setIntegrationForceGroups(groups) Set which force groups to use for integration. setMaximumStepSize(self,Â size) Set the maximum step size the integrator will ever use, in ps. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. stepTo(self,Â time) Advance a simulation through time by taking a series of steps until a specified time is reached. Attributes thisown The membership flag property thisownÂ¶ The membership flag getErrorTolerance(self) → doubleÂ¶ Get the error tolerance. setErrorTolerance(self, tol)Â¶ Set the error tolerance. getMaximumStepSize(self) → doubleÂ¶ Get the maximum step size the integrator will ever use, in ps. If this is 0 (the default), no limit will be applied to step sizes. setMaximumStepSize(self, size)Â¶ Set the maximum step size the integrator will ever use, in ps. If this is 0 (the default), no limit will be applied to step sizes. step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take stepTo(self, time)Â¶ Advance a simulation through time by taking a series of steps until a specified time is reached. When this method returns, the simulation time will exactly equal the time which was specified. If you call this method and specify a time that is earlier than the current time, it will return without doing anything. Parameters time (double) â the time to which the simulation should be advanced getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.VerletIntegrator.html:
VerletIntegratorÂ¶ class openmm.openmm.VerletIntegrator(*args)Â¶ This is an Integrator which simulates a System using the leap-frog Verlet algorithm. __init__(self, stepSize) → VerletIntegratorÂ¶ __init__(self, other) → VerletIntegrator Create a VerletIntegrator. Parameters stepSize (double) â the step size with which to integrate the system (in picoseconds) Methods __init__(->Â VerletIntegrator) Create a VerletIntegrator. getConstraintTolerance(self) Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) Get which force groups to use for integration. getStepSize(self) Get the size of each time step, in picoseconds. setConstraintTolerance(self,Â tol) Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups) Set which force groups to use for integration. setStepSize(self,Â size) Set the size of each time step, in picoseconds. step(self,Â steps) Advance a simulation through time by taking a series of time steps. Attributes thisown The membership flag property thisownÂ¶ The membership flag step(self, steps)Â¶ Advance a simulation through time by taking a series of time steps. Parameters steps (int) â the number of time steps to take getConstraintTolerance(self) → doubleÂ¶ Get the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. getIntegrationForceGroups(self) → intÂ¶ Get which force groups to use for integration. By default, all force groups are included. This is interpreted as a set of bit flags: the forces from group i will be included if (groups&(1<<i)) != 0. getStepSize(self) → doubleÂ¶ Get the size of each time step, in picoseconds. If this integrator uses variable time steps, the size of the most recent step is returned. Returns the step size, measured in ps Return type double setConstraintTolerance(self, tol)Â¶ Set the distance tolerance within which constraints are maintained, as a fraction of the constrained distance. setIntegrationForceGroups(groups)Â¶ Set which force groups to use for integration. By default, all force groups are included. Parameters groups (set or int) â a set of indices for which force groups to include when integrating the equations of motion. Alternatively, the groups can be passed as a single unsigned integer interpreted as a bitmask, in which case group i will be included if (groups&(1<<i)) != 0. setStepSize(self, size)Â¶ Set the size of each time step, in picoseconds. If this integrator uses variable time steps, the effect of calling this method is undefined, and it may simply be ignored. Parameters size (double) â the step size, measured in ps

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.VirtualSite.html:
VirtualSiteÂ¶ class openmm.openmm.VirtualSite(*args, **kwargs)Â¶ A VirtualSite describes the rules for computing a particleâs position based on other particles. This is an abstract class. Subclasses define particular rules. To define a virtual site, create an instance of a VirtualSite subclass and then call setVirtualSite() on the System. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. getNumParticles(self) Get the number of particles this virtual site depends on. getParticle(self,Â particle) Get the index of a particle this virtual site depends on. Attributes thisown The membership flag property thisownÂ¶ The membership flag getNumParticles(self) → intÂ¶ Get the number of particles this virtual site depends on. getParticle(self, particle) → intÂ¶ Get the index of a particle this virtual site depends on. Parameters particle (int) â the particle to get (between 0 and getNumParticles()) Returns the index of the particle in the System Return type int

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.openmm.XmlSerializer.html:
XmlSerializerÂ¶ class openmm.openmm.XmlSerializer(*args, **kwargs)Â¶ XmlSerializer is used for serializing objects as XML, and for reconstructing them again. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(*args,Â **kwargs) Initialize self. clone(object) Clone an object by first serializing it, then deserializing it again. deserialize(inputString) Reconstruct an object that has been serialized as XML. deserializeSystem(inputString) This method exists only for backward compatibility. serialize(object) Serialize an object as XML. serializeSystem(object) This method exists only for backward compatibility. Attributes thisown The membership flag property thisownÂ¶ The membership flag static serializeSystem(object) → std::stringÂ¶ This method exists only for backward compatibility. Deprecated Use serialize() instead. static deserializeSystem(inputString) → SystemÂ¶ This method exists only for backward compatibility. Deprecated Use deserialize() instead. static serialize(object)Â¶ Serialize an object as XML. static deserialize(inputString)Â¶ Reconstruct an object that has been serialized as XML. static clone(object)Â¶ Clone an object by first serializing it, then deserializing it again. This method constructs the new object directly from the SerializationNodes without first converting them to XML. This means it is faster and uses less memory than making separate calls to serialize() and deserialize().

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.OpenMMException.html:
OpenMMExceptionÂ¶ class openmm.OpenMMExceptionÂ¶ This is the class used for all exceptions thrown by the C++ library. __init__(*args, **kwargs)Â¶ Initialize self. See help(type(self)) for accurate signature. with_traceback()Â¶ Exception.with_traceback(tb) â set self.__traceback__ to tb and return self.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.unit.basedimension.BaseDimension.html:
BaseDimensionÂ¶ class openmm.unit.basedimension.BaseDimension(name)Â¶ A physical dimension such as length, mass, or temperature. It is unlikely the user will need to create new ones. __init__(name)Â¶ Create a new BaseDimension. Each new BaseDimension is assumed to be independent of all other BaseDimensions. Use the existing BaseDimensions instead of creating new ones. Methods __init__(name) Create a new BaseDimension. __lt__(other)Â¶ The implicit order of BaseDimensions is the order in which they were created. This method is used for using BaseDimensions as hash keys, and also affects the order in which units appear in multi-dimensional Quantities. Returns True if self < other, False otherwise. __hash__()Â¶ Needed for using BaseDimensions as hash keys.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.unit.baseunit.BaseUnit.html:
BaseUnitÂ¶ class openmm.unit.baseunit.BaseUnit(base_dim, name, symbol)Â¶ Physical unit expressed in exactly one BaseDimension. For example, meter_base_unit could be a BaseUnit for the length dimension. The BaseUnit class is used internally in the more general Unit class. __init__(base_dim, name, symbol)Â¶ Creates a new BaseUnit. Parameters self: The newly created BaseUnit. base_dim: (BaseDimension) The dimension of the new unit, e.g. âmassâ name: (string) Name of the unit, e.g. âkilogramâ symbol: (string) Symbol for the unit, e.g. âkgâ. This symbol will appear inQuantity string descriptions. Methods __init__(base_dim,Â name,Â symbol) Creates a new BaseUnit. conversion_factor_to(other) Returns a conversion factor from this BaseUnit to another BaseUnit. define_conversion_factor_to(other,Â factor) Defines a conversion factor between two BaseUnits. get_dimension_tuple() Returns a sorted tuple of (BaseDimension, exponent) pairs, that can be used as a dictionary key. iter_base_dimensions() Returns a dictionary of BaseDimension:exponent pairs, describing the dimension of this unit. iter_base_units() __lt__(other)Â¶ Comparison function that sorts BaseUnits by BaseDimension iter_base_dimensions()Â¶ Returns a dictionary of BaseDimension:exponent pairs, describing the dimension of this unit. get_dimension_tuple()Â¶ Returns a sorted tuple of (BaseDimension, exponent) pairs, that can be used as a dictionary key. __str__()Â¶ Returns a string with the name of this BaseUnit define_conversion_factor_to(other, factor)Â¶ Defines a conversion factor between two BaseUnits. self * factor = other Parameters: self: (BaseUnit) âFromâ unit in conversion. other: (BaseUnit) âToâ unit in conversion. factor: (float) Conversion factor. After calling this method, both self and other will have stored conversion factors for one another, plus all other BaseUnits which self and other have previously defined. Both self and other must have the same dimension, otherwise a TypeError will be raised. Returns None. conversion_factor_to(other)Â¶ Returns a conversion factor from this BaseUnit to another BaseUnit. It does not matter which existing BaseUnit you define the conversion factor to. Conversions for all other known BaseUnits will be computed at the same time. Raises TypeError if dimension does not match. Raises LookupError if no conversion has been defined. (see define_conversion_factor_to).

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.unit.prefix.SiPrefix.html:
SiPrefixÂ¶ class openmm.unit.prefix.SiPrefix(prefix, factor, symbol)Â¶ Unit prefix that can be multiplied by a unit to yield a new unit. e.g. millimeter = milli*meter __init__(prefix, factor, symbol)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(prefix,Â factor,Â symbol) Initialize self. __mul__(unit)Â¶ SiPrefix * BaseUnit yields new BaseUnit SiPrefix * ScaledUnit yields new ScaledUnit SiPrefix * Unit with exactly one BaseUnit or ScaledUnit yields new Unit

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.unit.quantity.Quantity.html:
QuantityÂ¶ class openmm.unit.quantity.Quantity(value=None, unit=None)Â¶ Physical quantity, such as 1.3 meters per second. Quantities contain both a value, such as 1.3; and a unit, such as âmeters per secondâ. Supported value types include: numbers (float, int, long) lists of numbers, e.g. [1,2,3] tuples of numbers, e.g. (1,2,3) Note: unit conversions will cause tuples to be converted to lists lists of tuples of numbers, lists of lists of â¦ etc. of numbers numpy.arrays __init__(value=None, unit=None)Â¶ Create a new Quantity from a value and a unit. Parameters value: (any type, usually a number) Measure of this quantity unit: (Unit) the physical unit, e.g. openmm.unit.meters. Methods __init__([value,Â unit]) Create a new Quantity from a value and a unit. append(item) count(item) extend(rhs) format(format_spec) in_unit_system(system) Returns a new Quantity equal to this one, expressed in a particular unit system. in_units_of(other_unit) Returns an equal Quantity expressed in different units. index(item) insert(index,Â item) max(*args,Â **kwargs) Computes the maximum value of the sequence, with the result having the same unit as the current sequence. mean(*args,Â **kwargs) Computes the mean of a sequence, with the result having the same unit as the current sequence. min(*args,Â **kwargs) Computes the minimum value of the sequence, with the result having the same unit as the current sequence. pop(*args) reduce_unit([guide_unit]) Combine similar component units and scale, to form an equal Quantity in simpler units. remove(item) reshape(shape[,Â order]) Same as numpy.ndarray.reshape, except the result is a Quantity with the same units as the current object rather than a plain numpy.ndarray sqrt() Returns square root of a Quantity. std(*args,Â **kwargs) Computes the square root of the variance of a sequence, with the result having the same unit as the current sequence. sum(*args,Â **kwargs) Computes the sum of a sequence, with the result having the same unit as the current sequence. value_in_unit(unit) Returns underlying value, in the specified units. value_in_unit_system(system) Returns the underlying value type, after conversion to a particular unit system. __copy__()Â¶ Shallow copy produces a new Quantity with the shallow copy of value and the same unit. Because we want copy operations to work just the same way they would on the underlying value. __deepcopy__(memo)Â¶ Deep copy produces a new Quantity with a deep copy of the value, and the same unit. Because we want copy operations to work just the same way they would on the underlying value. __getattr__(attribute)Â¶ Delegate unrecognized attribute calls to the underlying value type. __str__()Â¶ Printable string version of this Quantity. Returns a string consisting of quantity number followed by unit abbreviation. __repr__()Â¶ __add__(other)Â¶ Add two Quantities. Only Quantities with the same dimensions (e.g. length) can be added. Raises TypeError otherwise. Parameters self: left hand member of sum other: right hand member of sum Returns a new Quantity that is the sum of the two arguments. __sub__(other)Â¶ Subtract two Quantities. Only Quantities with the same dimensions (e.g. length) can be subtracted. Raises TypeError otherwise. Parameters self: left hand member (a) of a - b. other: right hand member (b) of a - b. Returns a new Quantity that is the difference of the two arguments. __eq__(other)Â¶ __ne__(other)Â¶ reduce_unit(guide_unit=None)Â¶ Combine similar component units and scale, to form an equal Quantity in simpler units. Returns underlying value type if unit is dimensionless. __mul__(other)Â¶ Multiply a quantity by another object Returns a new Quantity that is the product of the self * other, unless the resulting unit is dimensionless, in which case the underlying value type is returned, instead of a Quantity. __rmul__(other)Â¶ Multiply a scalar by a Quantity Returns a new Quantity with the same units as self, but with the value multiplied by other. __truediv__(other)Â¶ Divide a Quantity by another object Returns a new Quantity, unless the resulting unit type is dimensionless, in which case the underlying value type is returned. __div__(other)Â¶ Divide a Quantity by another object Returns a new Quantity, unless the resulting unit type is dimensionless, in which case the underlying value type is returned. __rtruediv__(other)Â¶ Divide a scalar by a quantity. Returns a new Quantity. The resulting units are the inverse of the self argument units. __rdiv__(other)Â¶ Divide a scalar by a quantity. Returns a new Quantity. The resulting units are the inverse of the self argument units. __pow__(exponent)Â¶ Raise a Quantity to a power. Generally both the value and the unit of the Quantity are affected by this operation. Returns a new Quantity equal to self**exponent. sqrt()Â¶ Returns square root of a Quantity. Raises ArithmeticError if component exponents are not even. This behavior can be changed if you present a reasonable real life case to me. sum(*args, **kwargs)Â¶ Computes the sum of a sequence, with the result having the same unit as the current sequence. If the value is not iterable, it raises a TypeError (same behavior as if you tried to iterate over, for instance, an integer). This function can take as arguments any arguments recognized by numpy.sum. If arguments are passed to a non-numpy array, a TypeError is raised mean(*args, **kwargs)Â¶ Computes the mean of a sequence, with the result having the same unit as the current sequence. If the value is not iterable, it raises a TypeError This function can take as arguments any arguments recognized by numpy.mean. If arguments are passed to a non-numpy array, a TypeError is raised std(*args, **kwargs)Â¶ Computes the square root of the variance of a sequence, with the result having the same unit as the current sequence. If the value is not iterable, it raises a TypeError This function can take as arguments any arguments recognized by numpy.std. If arguments are passed to a non-numpy array, a TypeError is raised max(*args, **kwargs)Â¶ Computes the maximum value of the sequence, with the result having the same unit as the current sequence. If the value is not iterable, it raises a TypeError This function can take as arguments any arguments recognized by numpy.max. If arguments are passed to a non-numpy array, a TypeError is raised min(*args, **kwargs)Â¶ Computes the minimum value of the sequence, with the result having the same unit as the current sequence. If the value is not iterable, it raises a TypeError This function can take as arguments any arguments recognized by numpy.min. If arguments are passed to a non-numpy array, a TypeError is raised reshape(shape, order='C')Â¶ Same as numpy.ndarray.reshape, except the result is a Quantity with the same units as the current object rather than a plain numpy.ndarray __abs__()Â¶ Return absolute value of a Quantity. The unit is unchanged. A negative value of self will result in a positive value in the result. __pos__()Â¶ Returns a reference to self. __neg__()Â¶ Negate a Quantity. Returns a new Quantity with a different sign on the value. __nonzero__()Â¶ Returns True if value underlying Quantity is zero, False otherwise. value_in_unit(unit)Â¶ Returns underlying value, in the specified units. value_in_unit_system(system)Â¶ Returns the underlying value type, after conversion to a particular unit system. in_unit_system(system)Â¶ Returns a new Quantity equal to this one, expressed in a particular unit system. in_units_of(other_unit)Â¶ Returns an equal Quantity expressed in different units. If the units are the same as those in self, a reference to self is returned. Raises a TypeError if the new unit is not compatible with the original unit. The post_multiply argument is used in case the multiplication operation is not commutative.i.e. result = factor * value when post_multiply is False and result = value * factor when post_multiply is True __len__()Â¶ Return size of internal value type. __getitem__(key)Â¶ Keep the same units on contained elements.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.unit.unit.ScaledUnit.html:
ScaledUnitÂ¶ class openmm.unit.unit.ScaledUnit(factor, master, name, symbol)Â¶ ScaledUnit is like a BaseUnit, but it is based on another Unit. ScaledUnit and BaseUnit are both used in the internals of Unit. They should only be used during the construction of Units. __init__(factor, master, name, symbol)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(factor,Â master,Â name,Â symbol) Initialize self. conversion_factor_to(other) get_conversion_factor_to_base_units() get_dimension_tuple() Returns a sorted tuple of (BaseDimension, exponent) pairs, that can be used as a dictionary key. iter_base_dimensions() Returns a sorted tuple of (BaseDimension, exponent) pairs, describing the dimension of this unit. iter_base_units() iter_base_dimensions()Â¶ Returns a sorted tuple of (BaseDimension, exponent) pairs, describing the dimension of this unit. get_dimension_tuple()Â¶ Returns a sorted tuple of (BaseDimension, exponent) pairs, that can be used as a dictionary key. __lt__(other)Â¶ Compare two ScaledUnits. __str__()Â¶ Returns a string with the name of this ScaledUnit __repr__()Â¶

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.unit.unit.Unit.html:
UnitÂ¶ class openmm.unit.unit.Unit(base_or_scaled_units)Â¶ Physical unit such as meter or ampere. __init__(base_or_scaled_units)Â¶ Create a new Unit. Parameters self (Unit) â The newly created Unit. base_or_scaled_units (dict) â Keys are BaseUnits or ScaledUnits. Values are exponents (numbers). Methods __init__(base_or_scaled_units) Create a new Unit. conversion_factor_to(other) Returns conversion factor for computing all of the common dimensions between self and other from self base units to other base units. create_unit(scale,Â name,Â symbol) Convenience method for creating a new simple unit from another simple unit. get_conversion_factor_to_base_units() There may be ScaleUnit components to this Unit. get_name() Returns a unit name (string) for this Unit, composed of its various BaseUnit symbols. get_symbol() Returns a unit symbol (string) for this Unit, composed of its various BaseUnit symbols. in_unit_system(system) Returns a new Unit with the same dimensions as this one, expressed in a particular unit system. is_compatible(other) Returns True if two Units share the same dimension. is_dimensionless() Returns True if this Unit has no dimensions. iter_all_base_units() Yields (BaseUnit, exponent) tuples comprising this unit, including those BaseUnits found within ScaledUnits. iter_base_dimensions() Yields (BaseDimension, exponent) tuples comprising this unit. iter_base_or_scaled_units() iter_scaled_units() iter_top_base_units() Yields (BaseUnit, exponent) tuples in this Unit, excluding those within BaseUnits. sqrt() Returns square root of a unit. create_unit(scale, name, symbol)Â¶ Convenience method for creating a new simple unit from another simple unit. Both units must consist of a single BaseUnit. iter_base_dimensions()Â¶ Yields (BaseDimension, exponent) tuples comprising this unit. iter_all_base_units()Â¶ Yields (BaseUnit, exponent) tuples comprising this unit, including those BaseUnits found within ScaledUnits. There might be multiple BaseUnits with the same dimension. iter_top_base_units()Â¶ Yields (BaseUnit, exponent) tuples in this Unit, excluding those within BaseUnits. get_conversion_factor_to_base_units()Â¶ There may be ScaleUnit components to this Unit. Returns conversion factor to the set of BaseUnits returned by iter_all_base_units(). Units comprised of only BaseUnits return 1.0 __lt__(other)Â¶ Compare two Units. Raises a TypeError if the units have different dimensions. Returns True if self < other, False otherwise. __hash__()Â¶ Compute a hash code for this object. __truediv__(other)Â¶ Divide a Unit by another object. Returns a composite Unit if other is another Unit. Returns a Quantity otherwise. UNLESS other is a Quantity AND the resulting unit type is dimensionless, in which case the underlying value type of the Quantity is returned. __div__(other)Â¶ Divide a Unit by another object. Returns a composite Unit if other is another Unit. Returns a Quantity otherwise. UNLESS other is a Quantity AND the resulting unit type is dimensionless, in which case the underlying value type of the Quantity is returned. __pow__(exponent)Â¶ Raise a Unit to a power. Returns a new Unit with different exponents on the BaseUnits. sqrt()Â¶ Returns square root of a unit. Raises ArithmeticError if component exponents are not even. This behavior can be changed if you present a reasonable real life case to me. __str__()Â¶ Returns the human-readable name of this unit __repr__()Â¶ Returns a unit name (string) for this Unit, composed of its various BaseUnit symbols. e.g. âkilogram meter**2 second**-1â is_compatible(other)Â¶ Returns True if two Units share the same dimension. Returns False otherwise. is_dimensionless()Â¶ Returns True if this Unit has no dimensions. Returns False otherwise. conversion_factor_to(other)Â¶ Returns conversion factor for computing all of the common dimensions between self and other from self base units to other base units. The two units need not share all of the same dimensions. In case they do not, the conversion factor applies only to the BaseUnits of self that correspond to different BaseUnits in other. This method requires strict compatibility between the two units. in_unit_system(system)Â¶ Returns a new Unit with the same dimensions as this one, expressed in a particular unit system. Strips off any ScaledUnits in the Unit, leaving only BaseUnits. Parameters system (a dictionary of (BaseDimension, BaseUnit) pairs) â get_symbol()Â¶ Returns a unit symbol (string) for this Unit, composed of its various BaseUnit symbols. e.g. âkg m**2 s**-1â get_name()Â¶ Returns a unit name (string) for this Unit, composed of its various BaseUnit symbols. e.g. âkilogram meter**2 secon**-1â.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.unit.unit.UnitSystem.html:
UnitSystemÂ¶ class openmm.unit.unit.UnitSystem(units)Â¶ A complete system of units defining the base unit in each dimension Parameters units (list) â List of base units from which to construct the unit system __init__(units)Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__(units) Initialize self. express_unit(old_unit) __str__()Â¶ express_unit(old_unit)Â¶

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_generated_openmm.vec3.Vec3.html:
Vec3Â¶ class openmm.vec3.Vec3(x, y, z)Â¶ Vec3 is a 3-element tuple that supports many math operations. __init__()Â¶ Initialize self. See help(type(self)) for accurate signature. Methods __init__() Initialize self. count(value,Â /) Return number of occurrences of value. index(value[,Â start,Â stop]) Return first index of value. Attributes x Alias for field number 0 y Alias for field number 1 z Alias for field number 2 static __new__(cls, x, y, z)Â¶ Create a new Vec3. __getnewargs__()Â¶ Support for pickle protocol 2: http://docs.python.org/2/library/pickle.html#pickling-and-unpickling-normal-class-instances __add__(other)Â¶ Add two Vec3s. __radd__(other)Â¶ Add two Vec3s. __sub__(other)Â¶ Add two Vec3s. __rsub__(other)Â¶ Add two Vec3s. __mul__(other)Â¶ Multiply a Vec3 by a constant. __rmul__(other)Â¶ Multiply a Vec3 by a constant. __div__(other)Â¶ Divide a Vec3 by a constant. __truediv__(other)Â¶ Divide a Vec3 by a constant. count(value, /)Â¶ Return number of occurrences of value. index(value, start=0, stop=9223372036854775807, /)Â¶ Return first index of value. Raises ValueError if the value is not present. property xÂ¶ Alias for field number 0 property yÂ¶ Alias for field number 1 property zÂ¶ Alias for field number 2

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_index.html:
OpenMM Python APIÂ¶ The Python API provides information about the classes and methods available in OpenMM for Python developers. OpenMM consists of two parts. First, there is a set of libraries for performing many types of computations needed for molecular simulations: force evaluation, numerical integration, energy minimization, etc. Second, there is an application layer, a set of Python libraries providing a high level interface for running simulations. This layer is targeted at computational biologists or other people who want to run simulations, and who may or may not be programmers. See the user guide for more details. Application Layer Loaders and Setup Representation and Manipulation Simulation Reporting Output Extras Units Library Layer Core Objects Forces Integrators Extras

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_api-python_library.html:
Library LayerÂ¶ Core ObjectsÂ¶ System This class represents a molecular system. Context A Context stores the complete state of a simulation. Platform A Platform defines an implementation of all the kernels needed to perform some calculation. State A State object records a snapshot of the current state of a simulation at a point in time. ForcesÂ¶ ATMForce The ATMForce class implements the Alchemical Transfer Method (ATM) for OpenMM. AmoebaGeneralizedKirkwoodForce This class implements an implicit solvation force using the generalized Kirkwood/Grycuk model. AmoebaMultipoleForce This class implements the Amoeba multipole interaction. AmoebaTorsionTorsionForce This class implements the Amoeba torsion-torsion interaction. AmoebaVdwForce This class models van der Waals forces in the AMOEBA force field. AmoebaWcaDispersionForce This class implements a nonbonded interaction between pairs of particles typically used along with AmoebaGeneralizedKirkwoodForce as part of an implicit solvent model. AndersenThermostat This class uses the Andersen method to maintain constant temperature. CMAPTorsionForce This class implements an interaction between pairs of dihedral angles. CMMotionRemover This class prevents the center of mass of a System from drifting. CustomAngleForce This class implements interactions between sets of three particles that depend on the angle between them. CustomBondForce This class implements bonded interactions between pairs of particles. CustomCVForce This class supports energy functions that depend on collective variables. CustomCentroidBondForce This class is similar to CustomCompoundBondForce, but instead of applying forces between individual particles, it applies them between the centers of groups of particles. CustomCompoundBondForce This class supports a wide variety of bonded interactions. CustomExternalForce This class implements an âexternalâ force on particles. CustomGBForce This class implements complex, multiple stage nonbonded interactions between particles. CustomHbondForce This class supports a wide variety of energy functions used to represent hydrogen bonding. CustomManyParticleForce This class supports a wide variety of nonbonded N-particle interactions, where N is user specified. CustomNonbondedForce This class implements nonbonded interactions between particles. CustomTorsionForce This class implements interactions between sets of four particles that depend on the torsion angle between them. DrudeForce This class implements forces that are specific to Drude oscillators. Force Force objects apply forces to the particles in a System, or alter their behavior in other ways. GBSAOBCForce This class implements an implicit solvation force using the GBSA-OBC model. GayBerneForce This class implements the Gay-Berne anisotropic potential. HarmonicAngleForce This class implements an interaction between groups of three particles that varies harmonically with the angle between them. HarmonicBondForce This class implements an interaction between pairs of particles that varies harmonically with the distance between them. HippoNonbondedForce This class implements all nonbonded interactions in the HIPPO force field: electrostatics, induction, charge transfer, dispersion, and repulsion. MonteCarloAnisotropicBarostat This class uses a Monte Carlo algorithm to adjust the size of the periodic box, simulating the effect of constant pressure. MonteCarloBarostat This class uses a Monte Carlo algorithm to adjust the size of the periodic box, simulating the effect of constant pressure. MonteCarloFlexibleBarostat This class uses a Monte Carlo algorithm to adjust the size and shape of the periodic box, simulating the effect of constant pressure. MonteCarloMembraneBarostat This is a Monte Carlo barostat designed specifically for membrane simulations. NonbondedForce This class implements nonbonded interactions between particles, including a Coulomb force to represent electrostatics and a Lennard-Jones force to represent van der Waals interactions. PeriodicTorsionForce This class implements an interaction between groups of four particles that varies periodically with the torsion angle between them. RBTorsionForce This class implements an interaction between groups of four particles that varies with the torsion angle between them according to the Ryckaert-Bellemans potential. RMSDForce This is a force whose energy equals the root mean squared deviation (RMSD) between the current coordinates and a reference structure. RPMDMonteCarloBarostat This class is very similar to MonteCarloBarostat, but it is specifically designed for use with RPMDIntegrator. IntegratorsÂ¶ AMDForceGroupIntegrator AMDForceGroupIntegrator implements a single boost aMD integration algorithm. AMDIntegrator AMDIntegrator implements the aMD integration algorithm. BrownianIntegrator This is an Integrator which simulates a System using Brownian dynamics. CompoundIntegrator This class allows you to use multiple integration algorithms within a single simulation, switching back and forth between them. CustomIntegrator This is an Integrator that can be used to implemented arbitrary, user defined integration algorithms. DrudeIntegrator A base class to encapsulate features common to Drude integrators. DrudeLangevinIntegrator This Integrator simulates systems that include Drude particles. DrudeNoseHooverIntegrator This Integrator simulates systems that include Drude particles. DrudeSCFIntegrator This is a leap-frog Verlet Integrator that simulates systems with Drude particles. DualAMDIntegrator DualAMDIntegrator implements a dual boost aMD integration algorithm. Integrator An Integrator defines a method for simulating a System by integrating the equations of motion. LangevinIntegrator This is an Integrator which simulates a System using Langevin dynamics. LangevinMiddleIntegrator This is an Integrator which simulates a System using Langevin dynamics, with the LFMiddle discretization (J. MTSIntegrator MTSIntegrator implements the rRESPA multiple time step integration algorithm. MTSLangevinIntegrator MTSLangevinIntegrator implements the BAOAB-RESPA multiple time step algorithm for constant temperature dynamics. NoseHooverIntegrator This is an Integrator which simulates a System using one or more Nose Hoover chain thermostats, using the âmiddleâ leapfrog propagation algorithm described in J. RPMDIntegrator This is an Integrator which simulates a System using ring polymer molecular dynamics (RPMD). VariableLangevinIntegrator This is an error controlled, variable time step Integrator that simulates a System using Langevin dynamics. VariableVerletIntegrator This is an error controlled, variable time step Integrator that simulates a System using the leap-frog Verlet algorithm. VerletIntegrator This is an Integrator which simulates a System using the leap-frog Verlet algorithm. ExtrasÂ¶ Continuous1DFunction This is a TabulatedFunction that computes a continuous one dimensional function. Continuous2DFunction This is a TabulatedFunction that computes a continuous two dimensional function. Continuous3DFunction This is a TabulatedFunction that computes a continuous three dimensional function. Discrete1DFunction This is a TabulatedFunction that computes a discrete one dimensional function f(x). Discrete2DFunction This is a TabulatedFunction that computes a discrete two dimensional function f(x,y). Discrete3DFunction This is a TabulatedFunction that computes a discrete three dimensional function f(x,y,z). LocalCoordinatesSite This is a VirtualSite that uses the locations of several other particles to compute a local coordinate system, then places the virtual site at a fixed location in that coordinate system. LocalEnergyMinimizer Given a Context, this class searches for a new set of particle positions that represent a local minimum of the potential energy. MinimizationReporter A MinimizationReporter can be passed to LocalEnergyMinimizer::minimize() to provide periodic information on the progress of minimization, and to give you the chance to stop minimization early. NoseHooverChain This class defines a chain of Nose-Hoover particles to be used as a heat bath to scale the velocities of a collection of particles subject to thermostating. OpenMMException This is the class used for all exceptions thrown by the C++ library. OutOfPlaneSite This is a VirtualSite that computes the particle location based on three other particlesâ locations. SerializationNode A SerializationNode stores information about an object during serialization or deserialization. SerializationProxy A SerializationProxy is an object that knows how to serialize and deserialize objects of a particular type. TabulatedFunction A TabulatedFunction uses a set of tabulated values to define a mathematical function. ThreeParticleAverageSite This is a VirtualSite that computes the particle location as a weighted average of three other particleâs locations. TwoParticleAverageSite This is a VirtualSite that computes the particle location as a weighted average of two other particleâs locations. Vec3 Vec3 is a 3-element tuple that supports many math operations. VirtualSite A VirtualSite describes the rules for computing a particleâs position based on other particles. XmlSerializer XmlSerializer is used for serializing objects as XML, and for reconstructing them again.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide.html:
OpenMM Developerâs GuideÂ¶ 1. Introduction 2. The Core Library 3. Writing Plugins 3.1. Creating New Platforms 3.2. Creating New Forces 4. The Reference Platform 5. The CPU Platform 6. The OpenCL Platform 6.1. Overview 6.2. Numerical Precision 6.3. Computing Forces 6.4. Nonbonded Forces 6.5. Bonded Forces 6.6. Reordering of Particles 6.7. Integration Utilities 7. The CUDA Platform 7.1. Caching Kernels 7.2. Accumulating Forces 8. Common Compute 8.1. Writing Device Code 8.2. Writing Host Code 9. Platform-Independent Code with CustomCPPForceImpl Portions copyright (c) 2011-2023 Stanford University and the Authors Contributors: Peter Eastman Permission is hereby granted, free of charge, to any person obtaining a copy of this document (the âDocumentâ), to deal in the Document without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Document, and to permit persons to whom the Document is furnished to do so, subject to the following conditions: This copyright and permission notice shall be included in all copies or substantial portions of the Document. THE DOCUMENT IS PROVIDED âAS ISâ, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS, CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE DOCUMENT OR THE USE OR OTHER DEALINGS IN THE DOCUMENT. Acknowledgments OpenMM software and all related activities, such as this manual, are funded by the Simbios National Center for Biomedical Computing through the National Institutes of Health Roadmap for Medical Research, Grant U54 GM072970. Information on the National Centers can be found at https://commonfund.nih.gov/bioinformatics.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_01_introduction.html:
1. IntroductionÂ¶ This guide describes the internal architecture of the OpenMM library. It is targeted at developers who want to add features to OpenMM, either by modifying the core library directly or by writing plugins. If you just want to write applications that use OpenMM, you do not need to read this guide; the Userâs Manual tells you everything you need to know. This guide is intended for people who want to contribute to OpenMM itself. It is organized as follows: Chapter 2 describes the architecture of the core OpenMM library. It discusses how the high level and low level APIs relate to each other, and the flow of execution between them. Chapter 3 describes in detail how to write a plugin. It focuses on the two most common types of plugins: those which define new Forces, and those which implement new Platforms. Chapter 4 discusses the architecture of the reference Platform, providing information relevant to writing reference implementations of new features. Chapter 5 discusses the architecture of the CPU Platform, providing information relevant to writing CPU implementations of new features. Chapter 6 discusses the architecture of the OpenCL Platform, providing information relevant to writing OpenCL implementations of new features. Chapter 7 discusses the architecture of the CUDA Platform, providing information relevant to writing CUDA implementations of new features. Chapter 8 describes the Common Compute framework, which lets you write a single implementation of a feature that can be used for both OpenCL and CUDA. This guide assumes you are already familiar with the public API and how to use OpenMM in applications. If that is not the case, you should first read the Userâs Manual and work through some of the example programs. Pay especially close attention to the âIntroduction to the OpenMM Libraryâ chapter, since it introduces concepts that are important in understanding this guide.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_02_core_library.html:
2. The Core LibraryÂ¶ OpenMM is based on a layered architecture, as shown in the following diagram: Figure 2-1: OpenMM architectureÂ¶ The public API layer consists of the classes you access when using OpenMM in an application: System; Force and its subclasses; Integrator and its subclasses; and Context. These classes define a public interface but do no computation. The next layer down consists of âimplementationâ classes that mirror the public API classes: ContextImpl, ForceImpl, and a subclass of ForceImpl for each subclass of Force (HarmonicBondForceImpl, NonbondedForceImpl, etc.). These objects are created automatically when you create a Context. They store information related to a particular simulation, and define methods for performing calculations. Note that, whereas a Force is logically âpart ofâ a System, a ForceImpl is logically âpart ofâ a Context. (See Figure 2-2.) If you create many Contexts for simulating the same System, there is still only one System and only one copy of each Force in it. But there will be separate ForceImpls for each Context, and those ForceImpls store information related to their particular Contexts. Figure 2-2: Relationships between public API and implementation layer objectsÂ¶ Also note that there is no âIntegratorImplâ class, because it is not needed. Integrator is already specific to one Context. Many Contexts can all simulate the same System, but each of them must have its own Integrator, so information specific to one simulation can be stored directly in the Integrator. The next layer down is the OpenMM Low Level API (OLLA). The important classes in this layer are: Platform; Kernel; KernelImpl and its subclasses; and KernelFactory. A Kernel is just a reference counted pointer to a KernelImpl; the real work is done by KernelImpl objects (or more precisely, by instances of its subclasses). A KernelFactory creates KernelImpl objects, and a Platform ties together a set of KernelFactories, as well as defining information that applies generally to performing computations with that Platform. All of these classes (except Kernel) are abstract. A particular Platform provides concrete subclasses of all of them. For example, the reference platform defines a Platform subclass called ReferencePlatform, a KernelFactory subclass called ReferenceKernelFactory, and a concrete subclass of each abstract KernelImpl type: ReferenceCalcNonbondedForceKernel extends CalcNonbondedForceKernel (which in turn extends KernelImpl), ReferenceIntegrateVerletStepKernel extends IntegrateVerletStepKernel, and so on. We can understand this better by walking through the entire sequence of events that takes place when you create a Context. As an example, suppose you create a System; add a NonbondedForce to it; create a VerletIntegrator; and then create a Context for them using the reference Platform. Here is what happens. The Context constructor creates a ContextImpl. The ContextImpl calls createImpl() on each Force in the System, which creates an instance of the appropriate ForceImpl subclass. The ContextImpl calls contextCreated() on the Platform(), which in turn calls setPlatformData() on the ContextImpl. This allows Platform-specific information to be stored in a ContextImpl. Every Platform has its own mechanism for storing particle masses, constraint definitions, particle positions, and so on. ContextImpl therefore allows the Platform to create an arbitrary block of data and store it where it can be accessed by that Platformâs kernels. The ContextImpl calls createKernel() on the Platform several times to get instances of various kernels that it needs: CalcKineticEnergyKernel, ApplyConstraintsKernel, etc. For each kernel, the Platform looks up which KernelFactory has been registered for that particular kernel. In this case, it will be a ReferenceKernelFactory. It calls createKernelImpl() on the KernelFactory, which creates and returns an instance of an appropriate KernelImpl subclass: ReferenceCalcKineticEnergyKernel, ReferenceApplyConstraintsKernel, etc. The ContextImpl loops over all of its ForceImpls and calls initialize() on each one. Each ForceImpl asks the Platform to create whatever kernels it needs. In this example, NonbondedForceImpl will request a CalcNonbondedForceKernel, and get back a ReferenceCalcNonbondedForceKernel. The ContextImpl calls initialize() on the Integrator which, like the other objects, requests kernels from the Platform. In this example, VerletIntegrator requests an IntegrateVerletStepKernel and gets back a ReferenceIntegrateVerletStepKernel. At this point, the Context is fully initialized and ready for doing computation. Reference implementations of various KernelImpls have been created, but they are always referenced through abstract superclasses. Similarly, data structures specific to the reference Platform have been created and stored in the ContextImpl, but the format and content of these structures is opaque to the ContextImpl. Whenever it needs to access them (for example, to get or set particle positions), it does so through a kernel (UpdateStateDataKernel in this case). Now suppose that you call step() on the VerletIntegrator. Here is what happens to execute each time step. The VerletIntegrator calls updateContextState() on the ContextImpl. This gives each Force an opportunity to modify the state of the Context at the start of each time step. The ContextImpl loops over its ForceImpls and calls updateContextState() on each one. In this case, our only ForceImpl is a NonbondedForceImpl, which returns without doing anything. On the other hand, if we had an AndersenThermostat in our System, its ForceImpl would invoke a kernel to modify particle velocities. The VerletIntegrator calls calcForcesAndEnergy() on the ContextImpl to request that the forces be computed. The ContextImpl calls beginComputation() on its CalcForcesAndEnergyKernel. This initializes all the forces to zero and does any other initialization the Platform requires before forces can be computed. For example, some Platforms construct their nonbonded neighbor lists at this point. The ContextImpl loops over its ForceImpls and calls calcForcesAndEnergy() on each one. In this case, we have a NonbondedForceImpl which invokes its CalcNonbondedForceKernel to compute forces. Finally, the ContextImpl calls finishComputation() on its CalcForcesAndEnergyKernel. This does any additional work needed to determine the final forces, such as summing the values from intermediate buffers. Finally, the VerletIntegrator invokes its IntegrateVerletStepKernel. This takes the forces, positions, and velocities that are stored in a Platform- specific format in the ContextImpl, uses them to compute new positions and velocities, and stores them in the ContextImpl.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_03_writing_plugins.html:
3. Writing PluginsÂ¶ A plugin is a dynamic library that adds new features to OpenMM. It is typically stored in the lib/plugins directory inside your OpenMM installation, and gets loaded along with all other plugins when the user calls Platform::loadPluginsFromDirectory(Platform::getDefaultPluginsDirectory()); It is also possible to load plugins from a different directory, or to load them individually by calling Platform::loadPluginLibrary(). Every plugin must implement two functions that are declared in the PluginInitializer.h header file: extern "C" void registerPlatforms(); extern "C" void registerKernelFactories(); When a plugin is loaded, these two functions are invoked to register any Platforms and KernelFactories defined by the plugin. When many plugins are loaded at once by calling Platform::loadPluginsFromDirectory(), registerPlatforms() is first called on all of them, then registerKernelFactories() is called on all of them. This allows one plugin to define a Platform, and a different plugin to add KernelFactories to it; the Platform is guaranteed to be registered by the first plugin before the second plugin tries to add its KernelFactories, regardless of what order the plugins happen to be loaded in. 3.1. Creating New PlatformsÂ¶ One common type of plugin defines a new Platform. There are four such plugins that come with OpenMM: one for the Reference platform, one for the CPU Platform, one for the CUDA Platform, and one for the OpenCL Platform. To define a new Platform, you must create subclasses of the various abstract classes in the OpenMM Low Level API: a subclass of Platform, one or more subclasses of KernelFactory, and a subclass of each KernelImpl. That is easy to say, but a huge amount of work to actually do. There are many different algorithms involved in computing forces, enforcing constraints, performing integration, and so on, all of which together make up a Platform. Of course, there is no requirement that every Platform must implement every possible feature. If you do not provide an implementation of a particular kernel, it simply means your Platform cannot be used for any simulation that requires that kernel; if a user tries to do so, an exception will be thrown. Your pluginâs registerPlatforms() function should create an instance of your Platform subclass, then register it by calling Platform::registerPlatform(). You also must register the KernelFactory for each kernel your Platform supports. This can be done in the registerKernelFactories() function, or more simply, directly in the Platformâs constructor. You can use as many different KernelFactories as you want for different kernels, but usually it is simplest to use a single KernelFactory for all of them. The support for multiple KernelFactories exists primarily to let plugins add new features to existing Platforms, as described in the next section. 3.2. Creating New ForcesÂ¶ Another common type of plugin defines new Forces and provides implementations of them for existing Platforms. (Defining new Integrators is not specifically discussed here, but the process is very similar.) There are two such plugins that come with OpenMM. They implement the AMOEBA force field and Drude oscillators, respectively. As an example, suppose you want to create a new Force subclass called StringForce that uses the equations of String Theory to compute the interactions between particles. You want to provide implementations of it for all four standard platforms: Reference, CPU, CUDA, and OpenCL. The first thing to realize is that this cannot be done with only a plugin library. Plugins are loaded dynamically at runtime, and they relate to the low level API; but you must also provide a public API. Users of your class need to create StringForce objects and call methods on them. That means providing a header file with the class declaration, and a (non-plugin) library with the class definition to link their code against. The implementations for particular Platforms can be in plugins, but the public API class itself cannot. Or to put it differently, the full âpluginâ (from the userâs perspective) consists of three parts: the library OpenMM loads at runtime (which is what OpenMM considers to be the âpluginâ), a second library for users to link their code against, and a header file for them to include in their source code. To define the API, you will need to create the following classes: StringForce. This is the public API for your force, and users will directly link against the library containing it. StringForceImpl. This is the ForceImpl subclass corresponding to StringForce. It should be defined in the same library as StringForce, and StringForceâs createImpl() method should create an instance of it. CalcStringForceKernel. This is an abstract class that extends KernelImpl, and defines the API by which StringForceImpl invokes its kernel. You only need to provide a header file for it, not an implementation; those will be provided by Platforms. Now suppose you are writing the OpenCL implementation of StringForce. Here are the classes you need to write: OpenCLCalcStringForceKernel. This extends CalcStringForceKernel and provides implementations of its virtual methods. The code for this class will probably be very complicated (and if it actually works, worth a Nobel Prize). It may execute many different GPU kernels and create its own internal data structures. But those details are entirely internal to your own code. As long as this class implements the virtual methods of CalcStringForceKernel, you can do anything you want inside it. OpenCLStringForceKernelFactory. This is a KernelFactory subclass that knows how to create instances of OpenCLCalcStringForceKernel. Both of these classes should be packaged into a dynamic library (.so on Linux, .dylib on Mac, .dll on Windows) that can be loaded as a plugin. This library must also implement the two functions from PluginInitializer.h. registerPlatforms() will do nothing, since this plugin does not implement any new Platforms. registerKernelFactories() should call Platform::getPlatformByName(âOpenCLâ) to get the OpenCL Platform, then create a new OpenCLStringForceKernelFactory and call registerKernelFactory() on the Platform to register it. If the OpenCL Platform is not available, you should catch the exception then return without doing anything. Most likely this means there is no OpenCL runtime on the computer your code is running on.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_04_reference_platform.html:
4. The Reference PlatformÂ¶ The reference Platform is written with simplicity and clarity in mind, not performance. (It is still not always as simple or clear as one might hope, but that is the goal.) When implementing a new feature, it is recommended to create the reference implementation first, then use that as a model for the versions in other Platforms. When using the reference Platform, the âplatform-specific dataâ stored in ContextImpl is of type ReferencePlatform::PlatformData, which is declared in ReferencePlatform.h. It has fields for storing positions, velocities, box vectors, and other types of data. The PlatformDataâs vector of forces contains one element for each particle. At the start of each force evaluation, all elements of it are set to zero. Each Force adds its own contributions to the vector, so that at the end, it contains the total force acting on each particle. There are a few additional classes that contain useful static methods. SimTKOpenMMUtilities has various utility functions, of which the most important is a random number generator. ReferenceForce provides methods for calculating the displacement between two positions, optionally taking periodic boundary conditions into account.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_05_cpu_platform.html:
5. The CPU PlatformÂ¶ CpuPlatform is a subclass of ReferencePlatform. It provides optimized versions of a small number of kernels, while using the reference implementations for all the others. Any kernel implementation written for the reference Platform will work equally well with the CPU platform. Of course, if that kernel happens to be a performance bottleneck, you will probably want to write an optimized version of it. But many kernels have negligible effect on performance, and for these you can just use the same implementation for both platforms. If you choose to do that, you can easily support both platforms with a single plugin library. Just implement registerKernelFactories() like this: extern "C" void registerKernelFactories() { for (int i = 0; i < Platform::getNumPlatforms(); i++) { Platform& platform = Platform::getPlatform(i); if (dynamic_cast<ReferencePlatform*>(&platform) != NULL) { // Create and register your KernelFactory. } } } The loop identifies every ReferencePlatform, either an instance of the base class or of a subclass, and registers a KernelFactory for every one.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_06_opencl_platform.html:
6. The OpenCL PlatformÂ¶ The OpenCL Platform is much more complicated than the reference Platform. It also provides many more tools to simplify your work, but those tools themselves can be complicated to use correctly. This chapter will attempt to explain how to use some of the most important ones. It will not teach you how to program with OpenCL. There are many tutorials on that subject available elsewhere, and this guide assumes you already understand it. 6.1. OverviewÂ¶ When using the OpenCL Platform, the âplatform-specific dataâ stored in ContextImpl is of type OpenCLPlatform::PlatformData, which is declared in OpenCLPlatform.h. The most important field of this class is contexts , which is a vector of OpenCLContexts. (There is one OpenCLContext for each device you are using. The most common case is that you are running everything on a single device, in which case there will be only one OpenCLContext. Parallelizing computations across multiple devices is not discussed here.) The OpenCLContext stores most of the important information about a simulation: positions, velocities, forces, an OpenCL CommandQueue used for executing kernels, workspace buffers of various sorts, etc. It provides many useful methods for compiling and executing kernels, clearing and reducing buffers, and so on. It also provides access to three other important objects: the OpenCLIntegrationUtilities, OpenCLNonbondedUtilities, and OpenCLBondedUtilities. These are discussed below. Allocation of device memory is generally done through the OpenCLArray class. It takes care of much of the work of memory management, and provides a simple interface for transferring data between host and device memory. Every kernel is specific to a particular OpenCLContext, which in turn is specific to a particular OpenMM::Context. This means that kernel source code can be customized for a particular simulation. For example, values such as the number of particles can be turned into compile-time constants, and specific versions of kernels can be selected based on the device being used or on particular aspects of the system being simulated. OpenCLContext::createProgram() makes it easy to specify a list of preprocessor definitions to use when compiling a kernel. The normal way to execute a kernel is by calling executeKernel() on the OpenCLContext. It allows you to specify the total number of work-items to execute, and optionally the size of each work-group. (If you do not specify a work-group size, it uses 64 as a default.) The number of work-groups to launch is selected automatically based on the work-group size, the total number of work-items, and the number of compute units in the device it will execute on. 6.2. Numerical PrecisionÂ¶ The OpenCL platform supports three precision modes: Single: All values are stored in single precision, and nearly all calculations are done in single precision. The arrays of positions, velocities, forces, and energies (returned by the OpenCLContextâs getPosq(), getVelm(), getForce(), getForceBuffers(), and getEnergyBuffer() methods) are all of type float4 (or float in the case of getEnergyBuffer()). Mixed: Forces are computed and stored in single precision, but integration is done in double precision. The velocities have type double4. The positions are still stored in single precision to avoid adding overhead to the force calculations, but a second array of type float4 is created to store âcorrectionsâ to the positions (returned by the OpenCLContextâs getPosqCorrection() method). Adding the position and the correction together gives the full double precision position. Double: Positions, velocities, forces, and energies are all stored in double precision, and nearly all calculations are done in double precision. You can call getUseMixedPrecision() and getUseDoublePrecision() on the OpenCLContext to determine which mode is being used. In addition, when you compile a kernel by calling createKernel(), it automatically defines two types for you to make it easier to write kernels that work in any mode: real is defined as float in single or mixed precision mode, double in double precision mode. mixed is defined as float in single precision mode, double in mixed or double precision mode. It also defines vector versions of these types (real2, real4, etc.). 6.3. Computing ForcesÂ¶ When forces are computed, they can be stored in either of two places. There is an array of long values storing them as 64 bit fixed point values, and a collection of buffers of real4 values storing them in floating point format. Most GPUs support atomic operations on 64 bit integers, which allows many threads to simultaneously record forces without a danger of conflicts. Some low end GPUs do not support this, however, especially the embedded GPUs found in many laptops. These devices write to the floating point buffers, with careful coordination to make sure two threads will never write to the same memory location at the same time. At the start of a force calculation, all forces in all buffers are set to zero. Each Force is then free to add its contributions to any or all of the buffers. Finally, the buffers are summed to produce the total force on each particle. The total is recorded in both the floating point and fixed point arrays. The size of each floating point buffer is equal to the number of particles, rounded up to the next multiple of 32. Call getPaddedNumAtoms() on the OpenCLContext to get that number. The actual force buffers are obtained by calling getForceBuffers(). The first n entries (where n is the padded number of atoms) represent the first force buffer, the next n represent the second force buffer, and so on. More generally, the iâth force bufferâs contribution to the force on particle j is stored in element i*context.getPaddedNumAtoms()+j. The fixed point buffer is ordered differently. For atom i, the x component of its force is stored in element i, the y component in element i+context.getPaddedNumAtoms(), and the z component in element i+2*context.getPaddedNumAtoms(). To convert a value from floating point to fixed point, multiply it by 0x100000000 (232), then cast it to a long. Call getLongForceBuffer() to get the array of fixed point values. The potential energy is also accumulated in a set of buffers, but this one is simply a list of floating point values. All of them are set to zero at the start of a computation, and they are summed at the end of the computation to yield the total energy. The OpenCL implementation of each Force object should define a subclass of ComputeForceInfo, and register an instance of it by calling addForce() on the OpenCLContext. It implements methods for determining whether particular particles or groups of particles are identical. This is important when reordering particles, and is discussed below. 6.4. Nonbonded ForcesÂ¶ Computing nonbonded interactions efficiently is a complicated business in the best of cases. It is even more complicated on a GPU. Furthermore, the algorithms must vary based on the type of processor being used, whether there is a distance cutoff, and whether periodic boundary conditions are being applied. The OpenCLNonbondedUtilities class tries to simplify all of this. To use it you need provide only a piece of code to compute the interaction between two particles. It then takes responsibility for generating a neighbor list, looping over interacting particles, loading particle parameters from global memory, and writing the forces and energies to the appropriate buffers. All of these things are done using an algorithm appropriate to the processor you are running on and high level aspects of the interaction, such as whether it uses a cutoff and whether particular particle pairs need to be excluded. Of course, this system relies on certain assumptions, the most important of which is that the Force can be represented as a sum of independent pairwise interactions. If that is not the case, things become much more complicated. You may still be able to use features of OpenCLNonbondedUtilities, but you cannot use the simple mechanism outlined above. That is beyond the scope of this guide. To define a nonbonded interaction, call addInteraction() on the OpenCLNonbondedUtilities, providing a block of OpenCL source code for computing the interaction. This block of source code will be inserted into the middle of an appropriate kernel. At the point where it is inserted, various variables will have been defined describing the interaction to compute: atom1 and atom2 are the indices of the two interacting particles. r, r2, and invR are the distance r between the two particles, r2, and 1/r respectively. isExcluded is a bool specifying whether this pair of particles is marked as an excluded interaction. (Excluded pairs are not skipped automatically, because in some cases they still need to be processed, just differently from other pairs.) posq1 and posq2 are real4s containing the positions (in the xyz fields) and charges (in the w fields) of the two particles. Other per-particle parameters may be specified, as described below. The following preprocessor macros will also have been defined: NUM_ATOMS is the total number of particles in the system. PADDED_NUM_ATOMS is the padded number of particles in the system. USE_CUTOFF is defined if and only if a cutoff is being used USE_PERIODIC is defined if and only if periodic boundary conditions are being used. CUTOFF and CUTOFF_SQUARED are the cutoff distance and its square respectively (but only defined if a cutoff is being used). Finally, two output variables will have been defined: You should add the energy of the interaction to tempEnergy. You should add the derivative of the energy with respect to the inter-particle distance to dEdR. You can also define arbitrary per-particle parameters by calling addParameter() on the OpenCLNonbondedUtilities. You provide an array in device memory containing the set of values, and the values for the two interacting particles will be loaded and stored into variables called <name>1 and <name>2, where <name> is the name you specify for the parameter. Note that nonbonded interactions are not computed until after calcForcesAndEnergy() has been called on every ForceImpl, so it is possible to make the parameter values change with time by modifying them inside calcForcesAndEnergy(). Also note that the length of the array containing the parameter values must equal the padded number of particles in the system. Finally, you can specify arbitrary other memory objects that should be passed as arguments to the interaction kernel by calling addArgument(). The rest of the kernel ignores these arguments, but you can make use of them in your interaction code. Consider a simple example. Suppose we want to implement a nonbonded interaction of the form E=k1k2r2, where k is a per-particle parameter. First we create a parameter as follows nb.addParameter(ComputeParameterInfo(kparam, "kparam", "float", 1)); where nb is the OpenCLNonbondedUtilities for the context. Now we call addInteraction() to define an interaction with the following source code: #ifdef USE_CUTOFF if (!isExcluded && r2 < CUTOFF_SQUARED) { #else if (!isExcluded) { #endif tempEnergy += kparam1*kparam2*r2; dEdR += 2*kparam1*kparam2*r; } An important point is that this code is executed for every pair of particles in the padded list of atoms. This means that some interactions involve padding atoms, and should not actually be included. You might think, then, that the above code is incorrect and we need another check to filter out the extra interactions: if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) This is not necessary in our case, because the isExcluded flag is always set for interactions that involve a padding atom. If our force did not use excluded interactions (and so did not check isExcluded), then we would need to add this extra check. Self interactions are a similar case: we do not check for (atom1 == atom2) because the exclusion flag prevents them from being processed, but for some forces that check is necessary. 6.5. Bonded ForcesÂ¶ Just as OpenCLNonbondedUtilities simplifies the task of creating nonbonded interactions, OpenCLBondedUtilities simplifies the process for many types of bonded interactions. A âbonded interactionâ means one that is applied to small, fixed groups of particles. This includes bonds, angles, torsions, etc. The important point is that the list of particles forming a âbondâ is known in advance and does not change with time. Using OpenCLBondedUtilities is very similar to the process described above. You provide a block of OpenCL code for evaluating a single interaction. This block of code will be inserted into the middle of a kernel that loops over all interactions and evaluates each one. At the point where it is inserted, the following variables will have been defined describing the interaction to compute: index is the index of the interaction being evaluated. atom1, atom2, â¦ are the indices of the interacting particles. pos1, pos2, â¦ are real4s containing the positions (in the xyz fields) of the interacting particles. A variable called energy will have been defined for accumulating the total energy of all interactions. Your code should add the energy of the interaction to it. You also should define real4 variables called force1, force2, â¦ and store the force on each atom into them. As a simple example, the following source code implements a pairwise interaction of the form E=r2: real4 delta = pos2-pos1; energy += delta.x*delta.x + delta.y*delta.y + delta.z*delta.z; real4 force1 = 2.0f*delta; real4 force2 = -2.0f*delta; To use it, call addInteraction() on the Contextâs OpenCLBondedUtilities object. You also provide a list of the particles involved in every bonded interaction. Exactly as with nonbonded interactions, you can call addArgument() to specify arbitrary memory objects that should be passed as arguments to the interaction kernel. These might contain per-bond parameters (use index to look up the appropriate element) or any other information you want. 6.6. Reordering of ParticlesÂ¶ Nonbonded calculations are done a bit differently in the OpenCL Platform than in most CPU based codes. In particular, interactions are computed on blocks of 32 particles at a time (which is why the number of particles needs to be padded to bring it up to a multiple of 32), and the neighbor list actually lists pairs of blocks, not pairs of individual particles, that are close enough to interact with each other. This only works well if sequential particles tend to be close together so that blocks are spatially compact. This is generally true of particles in a macromolecule, but it is not true for solvent molecules. Each water molecule, for example, can move independently of other water molecules, so particles that happen to be sequential in whatever order the molecules were defined in need not be spatially close together. The OpenCL Platform addresses this by periodically reordering particles so that sequential particles are close together. This means that what the OpenCL Platform calls particle i need not be the same as what the System calls particle i. This reordering is done frequently, so it must be very fast. If all the data structures describing the structure of the System and the Forces acting on it needed to be updated, that would make it prohibitively slow. The OpenCL Platform therefore only reorders particles in ways that do not alter any part of the System definition. In practice, this means exchanging entire molecules; as long as two molecules are truly identical, their positions and velocities can be exchanged without affecting the System in any way. Every Force can contribute to defining the boundaries of molecules, and to determining whether two molecules are identical. This is done through the ComputeForceInfo it adds to the OpenCLContext. It can specify two types of information: Given a pair of particles, it can say whether those two particles are identical (as far as that Force is concerned). For example, a Force object implementing a Coulomb force would check whether the two particles had equal charges. It can define particle groups. The OpenCL Platform will ensure that all the particles in a group are part of the same molecule. It also can specify whether two groups are identical to each other. For example, in a Force implementing harmonic bonds, each group would consist of the two particles connected by a bond, and two groups would be identical if they had the same spring constants and equilibrium lengths. 6.7. Integration UtilitiesÂ¶ The OpenCLContextâs OpenCLIntegrationUtilities provides features that are used by many integrators. The two most important are random number generation and constraint enforcement. If you plan to use random numbers, you should call initRandomNumberGenerator() during initialization, specifying the random number seed to use. Be aware that there is only one random number generator, even if multiple classes make use of it. If two classes each call initRandomNumberGenerator() and request different seeds, an exception will be thrown. If they each request the same seed, the second call will simply be ignored. For efficiency, random numbers are generated in bulk and stored in an array in device memory, which you can access by calling getRandom(). Each time you need to use a block of random numbers, call prepareRandomNumbers(), specifying how many values you need. It will register that many values as having been used, and return the index in the array at which you should start reading values. If not enough unused values remain in the array, it will generate a new batch of random values before returning. To apply constraints, simply call applyConstraints(). For numerical accuracy, the constraint algorithms do not work on particle positions directly, but rather on the displacements taken by the most recent integration step. These displacements must be stored in an array which you can get by calling getPosDelta(). That is, the constraint algorithms assume the actual (unconstrained) position of each particle equals the position stored in the OpenCLContext plus the delta stored in the OpenCLIntegrationUtilities. It then modifies the deltas so that all distance constraints are satisfied. The integrator must then finish the time step by adding the deltas to the positions and storing them into the main position array.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_07_cuda_platform.html:
7. The CUDA PlatformÂ¶ The CUDA platform is very similar to the OpenCL platform, and most of the previous chapter applies equally well to it, just changing âOpenCLâ to âCudaâ in class names. There are a few differences worth noting. 7.1. Caching KernelsÂ¶ Like the OpenCL platform, the CUDA platform compiles all its kernels at runtime. To improve performance, it tries to cache the compiled kernels on disk for later use. This allows subsequent Contexts to skip compiling some kernels. To make this work, it needs a directory on disk where it can write out temporary files. It is specified by the âCudaTempDirectoryâ property when you create a new Context. It usually can figure out a suitable value on its own, but sometimes it needs help. See the âPlatform-Specific Propertiesâ chapter of the Userâs Manual for details. 7.2. Accumulating ForcesÂ¶ The OpenCL platform, as described in Section 6.3, uses two types of buffers for accumulating forces: a set of floating point buffers, and a single fixed point buffer. In contrast, the CUDA platform uses only the fixed point buffer (represented by the CUDA type long long).

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_08_common_compute.html:
8. Common ComputeÂ¶ Common Compute is not a platform, but it shares many elements of one. It exists to reduce code duplication between the OpenCL and CUDA platforms. It allows a single implementation to be written for most kernels that can be used by both platforms. OpenCL and CUDA are very similar to each other. Their computational models are nearly identical. For example, each is based around launching kernels that are executed in parallel by many threads. Each of them groups threads into blocks, with more communication and synchronization permitted between the threads in a block than between ones in different blocks. They have very similar memory hierarchies: high latency global memory, low latency local/shared memory that can be used for communication between the threads of a block, and local variables that are visible only to a single thread. Even their languages for writing kernels are very similar. Here is an OpenCL kernel that adds two arrays together, storing the result in a third array. __kernel void addArrays(__global const float* restrict a, __global const float* restrict b, __global float* restrict c int length) { for (int i = get_global_id(0); i < length; i += get_global_size(0)) c[i] = a[i]+b[i]; } Here is the corresponding CUDA kernel. __extern "C" __global__ void addArrays(const float* __restrict__ a, const float* __restrict__ b, _float* __restrict__ c int length) { for (int i = blockIdx.x*blockDim.x+threadIdx.x; i < length; i += blockDim.x*gridDim.x) c[i] = a[i]+b[i]; } The difference between them is largely just a mechanical find-and-replace. After many years of writing and maintaining nearly identical kernels by hand, it finally occurred to us that the translation could be done automatically by the compiler. Simply by defining a few preprocessor macros, the following kernel can be compiled equally well either as OpenCL or as CUDA. KERNEL void addArrays(GLOBAL const float* RESTRICT a, GLOBAL const float* RESTRICT b, GLOBAL float* RESTRICT c int length) { for (int i = GLOBAL_ID; i < length; i += GLOBAL_SIZE) c[i] = a[i]+b[i]; } 8.1. Writing Device CodeÂ¶ When compiling kernels with the Common Compute API, the following macros are defined. Macro OpenCL Definition CUDA Definition KERNEL __kernel extern âCâ __global__ DEVICE __device__ LOCAL __local __shared__ LOCAL_ARG __local GLOBAL __global RESTRICT restrict __restrict__ LOCAL_ID get_local_id(0) threadIdx.x LOCAL_SIZE get_local_size(0) blockDim.x GLOBAL_ID get_global_id(0) (blockIdx.x*blockDim.x+threadIdx.x) GLOBAL_SIZE get_global_size(0) (blockDim.x*gridDim.x) GROUP_ID get_group_id(0) blockIdx.x NUM_GROUPS get_num_groups(0) gridDim.x SYNC_THREADS barrier(CLK_LOCAL_MEM_FENCE+CLK_GLOBAL_MEM_FENCE); __syncthreads(); SYNC_WARPS if SIMT width >= 32: mem_fence(CLK_LOCAL_MEM_FENCE) otherwise: barrier(CLK_LOCAL_MEM_FENCE) if compute capability >= 7.0: __syncwarp(); otherwise empty MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE+CLK_GLOBAL_MEM_FENCE); __threadfence_block(); ATOMIC_ADD(dest, value) atom_add(dest, value) atomicAdd(dest, value) A few other symbols may or may not be defined based on the device you are running on: SUPPORTS_DOUBLE_PRECISION and SUPPORTS_64_BIT_ATOMICS. You can use #ifdef blocks with these symbols to conditionally compile code based on the features supported by the device. In addition, the CUDA compiler defines the symbol __CUDA_ARCH__, so you can check for this symbol if you want to have different code blocks for CUDA and OpenCL. Both OpenCL and CUDA define vector types like int2 and float4. The types they support are different but overlapping. When writing common code, use only the vector types that are supported by both OpenCL and CUDA: 2, 3, and 4 element vectors of type short, int, float, and double. CUDA uses functions to construct vector values, such as make_float2(x, y). OpenCL instead uses a typecast like syntax: (float2) (x, y). In common code, use the CUDA style make_ functions. OpenMM provides definitions of these functions when compiling as OpenCL. In CUDA, vector types are simply data structures. You can access their elements, but not do much more with them. In contrast, OpenCLâs vectors are mathematical types. All standard math operators are defined for them, as well as geometrical functions like dot() and cross(). When compiling kernels as CUDA, OpenMM provides definitions of these operators and functions. OpenCL also supports âswizzleâ notation for vectors. For example, if f is a float4 you can construct a vector of its first three elements by writing f.xyz, or you can swap its first two elements by writing f.xy = f.yx. Unfortunately, there is no practical way to support this in CUDA, so swizzle notation cannot be used in common code. Because stripping the final element from a four component vector is such a common operation, OpenMM provides a special function for doing it: trimTo3(f) is a vector of its first three elements. 64 bit integers are another data type that needs special handling. Both OpenCL and CUDA support them, but they use different names for them: long in OpenCL, long long in CUDA. To work around this inconsistency, OpenMM provides the typedefs mm_long and mm_ulong for signed and unsigned 64 bit integers in device code. 8.2. Writing Host CodeÂ¶ Host code for Common Compute is very similar to host code for OpenCL or CUDA. In fact, most of the classes provided by the OpenCL and CUDA platforms are subclasses of Common Compute classes. For example, OpenCLContext and CudaContext are both subclasses of ComputeContext. When writing common code, each KernelImpl should expect a ComputeContext to be passed to its constructor. By using the common API provided by that abstract class, it can be used for either OpenCL or CUDA just based on the particular context passed to it at runtime. Similarly, OpenCLNonbondedUtilities and CudaNonbondedUtilities are subclasses of the abstract NonbondedUtilities class, and so on. ArrayInterface is an abstract class defining the interface for arrays stored on the device. OpenCLArray and CudaArray are both subclasses of it. To simplify code that creates and uses arrays, there is also a third subclass called ComputeArray. It acts as a wrapper around an OpenCLArray or CudaArray, automatically creating an array of the appropriate type for the current platform. In practice, just follow these rules: Whenever you need to create an array, make it a ComputeArray. Whenever you write a function that expects an array to be passed to it, declare the type to be ArrayInterface. If you do these two things, all differences between platforms will be handled automatically. OpenCL and CUDA have quite different APIs for compiling and invoking kernels. To hide these differences, OpenMM provides a set of abstract classes. To compile device code, pass the source code to compileProgram() on the ComputeContext. This returns a ComputeProgram. You can then call its createKernel() method to get a ComputeKernel object, which has methods for setting arguments and invoking the kernel. Sometimes you need to refer to vector types in host code, such as to set the value for a kernel argument or to access the elements of an array. OpenCL and CUDA both define types for them, but they have different names, and in any case you want to avoid using OpenCL-specific or CUDA-specific types in common code. OpenMM therefore defines types for vectors in host code. They have the same names as the corresponding types in device code, only with the prefix mm_, for example mm_int2 and mm_float4. Three component vectors need special care in this context, because the platforms define them differently. In OpenCL, a three component vector is essentially a four component vector whose last component is ignored. For example, sizeof(float3) is 12 in CUDA but 16 in OpenCL. Within a kernel this distinction can usually be ignored, but when communicating between host and device it becomes vitally important. It is generally best to avoid storing three component vectors in arrays or passing them as arguments. There are no mm_ host types defined for three component vectors, because CUDA and OpenCL would require them to be defined in different ways.

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_developerguide_09_customcppforceimpl.html:
9. Platform-Independent Code with CustomCPPForceImplÂ¶ In most cases, Forces are written with platform-specific code that runs as efficiently as possible on the available hardware. There are some situations where that is unnecessarily complicated. For example, you might write a plugin that interfaces to an external library through its own public API. Because all expensive calculations are done by the external library, there is little opportunity for any kind of platform-specific optimization. All you can do is copy positions over to the external library and copy forces back, hopefully in a way that is not too inefficient, and preferably with as little code as possible. CustomCPPForceImpl is a tool for doing that. To use it, you write your Force subclass in the usual way, providing whatever API is appropriate for it. Then for the corresponding ForceImpl, simply subclass CustomCPPForceImpl and override computeForce() to perform the calculation using platform-independent C++ code. Nothing more is required. It will automatically work on all platforms. You do not need to write any GPU code, provide a Kernel or KernelFactory, define registration functions, or even create plugin libraries to be loaded dynamically. The single library containing the Force and ForceImpl is all you need. Here is an example of what the code to implement your ForceImpl might look like. class ExampleForceImpl : public CustomCPPForceImpl { public: ExampleForceImpl(const ExampleForce& owner) : CustomCPPForceImpl(owner), owner(owner) { } double computeForce(ContextImpl& context, const vector<Vec3>& positions, vector<Vec3>& forces) { // Compute the forces and energy here. Store the forces into the // vector and return the energy. } const ExampleForce& getOwner() const { return owner; } private: const ExampleForce& owner; };

==================================================

Content from C:\Users\wes\AutoMol-v2\scraped_api_docs\latest_userguide.html:
OpenMM Userâs Manual and Theory GuideÂ¶ 1. Introduction 1.1. Online Resources 1.2. Referencing OpenMM 1.3. Acknowledgments Part I: The OpenMM Application Layer 2. Getting Started 2.1. Introduction 2.2. Installing OpenMM 3. Running Simulations 3.1. A First Example 3.2. Using AMBER Files 3.3. Using Gromacs Files 3.4. Using CHARMM Files 3.5. The OpenMM-Setup Application 3.6. Simulation Parameters 3.6.1. Platforms 3.6.2. Force Fields 3.6.3. Small molecule parameters 3.6.4. AMBER Implicit Solvent 3.6.5. Nonbonded Interactions 3.6.6. Constraints 3.6.7. Heavy Hydrogens 3.6.8. Integrators 3.6.9. Temperature Coupling 3.6.10. Pressure Coupling 3.6.11. Energy Minimization 3.6.12. Removing Center of Mass Motion 3.6.13. Writing Trajectories 3.6.14. Recording Other Data 3.6.15. Saving Simulation Progress and Results 3.6.16. Enhanced Sampling Methods 4. Model Building and Editing 4.1. Adding Hydrogens 4.2. Adding Solvent 4.3. Adding a Membrane 4.4. Adding or Removing Extra Particles 4.5. Removing Water 4.6. Saving The Results 5. Advanced Simulation Examples 5.1. Simulated Annealing 5.2. Applying an External Force to Particles: a Spherical Container 5.3. Extracting and Reporting Forces (and other data) 5.4. Computing Energies 6. Add-On Packages 6.1. OpenMM-Torch 6.2. OpenMM-ML 6.3. OpenMMTools 6.4. OpenMM-HIP 6.5. openmmforcefields 6.6. OpenMM-PLUMED 7. Creating Force Fields 7.1. Basic Concepts 7.1.1. Atom Types and Atom Classes 7.1.2. Residue Templates 7.1.3. Forces 7.2. Writing the XML File 7.2.1. <AtomTypes> 7.2.2. <Residues> 7.2.3. <Patches> 7.2.4. Missing residue templates 7.2.5. <HarmonicBondForce> 7.2.6. <HarmonicAngleForce> 7.2.7. <PeriodicTorsionForce> 7.2.8. <RBTorsionForce> 7.2.9. <CMAPTorsionForce> 7.2.10. <NonbondedForce> 7.2.11. <GBSAOBCForce> 7.2.12. <CustomBondForce> 7.2.13. <CustomAngleForce> 7.2.14. <CustomTorsionForce> 7.2.15. <CustomNonbondedForce> 7.2.16. <CustomGBForce> 7.2.17. <CustomHbondForce> 7.2.18. <CustomManyParticleForce> 7.2.19. <LennardJonesForce> 7.2.20. Writing Custom Expressions 7.2.21. Tabulated Functions 7.2.22. Residue Template Parameters 7.2.23. Including Other Files 7.3. Using Multiple Files 7.4. Extending ForceField 7.4.1. Adding new force types 7.4.2. Adding residue template generators Part II: The OpenMM Library 8. Introduction 8.1. What Is the OpenMM Library? 8.1.1. How to get started 8.1.2. License 8.2. Design Principles 8.3. Choice of Language 8.4. Architectural Overview 8.5. The OpenMM Public API 8.6. The OpenMM Low Level API 8.7. Platforms 9. Compiling OpenMM from Source Code 9.1. Compiling on Linux and Mac 9.1.1. Prerequisites 9.1.2. Step 1: Configure with CMake 9.1.3. Step 2: Build 9.1.4. Step 3: Test your build 9.1.5. Step 3: Install 9.1.6. Step 3: Install the Python API 9.2. Compiling on Windows 9.2.1. Prerequisites 9.2.2. Step 1: Configure with CMake 9.2.3. Step 2: Build and Install 9.2.4. Step 3: Install the Python API 9.2.5. Step 4: Test your build 9.3. Building the Documentation (Optional) 9.4. Using local build of OpenMM alongside conda tools that depend on it 9.4.1. Step 1: Install your tools as usual 9.4.2. Step 2: Remove conda openmm package 9.4.3. Step 3: Install local build of openmm 10. OpenMM Tutorials 10.1. Example Files Overview 10.2. Running Example Files 10.2.1. Visual Studio 10.2.2. Mac OS X/Linux 10.3. HelloArgon Program 10.3.1. Including OpenMM-defined functions 10.3.2. Running a program on GPU platforms 10.3.3. Running a simulation using the OpenMM public API 10.3.4. Error handling for OpenMM 10.3.5. Writing out PDB files 10.3.6. HelloArgon output 10.4. HelloSodiumChloride Program 10.4.1. Simple molecular dynamics system 10.4.2. Interface routines 10.5. HelloEthane Program 11. Platform-Specific Properties 11.1. OpenCL Platform 11.2. CUDA Platform 11.3. CPU Platform 11.4. Determinism 12. Using OpenMM with Software Written in Languages Other than C++ 12.1. C API 12.1.1. Mechanics of using the C API 12.1.2. Mapping from the C++ API to the C API 12.1.3. Exceptions 12.1.4. OpenMM_Vec3 helper type 12.1.5. Array helper types 12.2. Fortran 95 API 12.2.1. Mechanics of using the Fortran API 12.2.2. Mapping from the C++ API to the Fortran API 12.2.3. OpenMM_Vec3 helper type 12.2.4. Array helper types 12.3. Python API 12.3.1. Mapping from the C++ API to the Python API 12.3.2. Mechanics of using the Python API 12.3.3. Units and dimensional analysis 13. Examples of OpenMM Integration 13.1. GROMACS 13.2. TINKER-OpenMM 14. Testing and Validation of OpenMM 14.1. Description of Tests 14.1.1. Unit tests 14.1.2. System tests 14.1.3. Direct comparisons between OpenMM and other programs 14.2. Test Results 14.2.1. Comparison to Reference Platform 14.2.2. Energy Conservation 14.2.3. Comparison to Gromacs 15. AMOEBA Plugin 15.1. OpenMM AMOEBA Supported Forces and Options 15.1.1. Supported Forces and Options 15.1.2. Supported Integrators 15.2. OpenMM AMOEBA Validation 16. Ring Polymer Molecular Dynamics (RPMD) Plugin 17. Drude Plugin Part III: The Theory Behind OpenMM 18. Introduction 18.1. Overview 18.2. Units 18.3. Physical Constants 19. Standard Forces 19.1. HarmonicBondForce 19.2. HarmonicAngleForce 19.3. PeriodicTorsionForce 19.4. RBTorsionForce 19.5. CMAPTorsionForce 19.6. NonbondedForce 19.6.1. Lennard-Jones Interaction 19.6.2. Coulomb Interaction Without Cutoff 19.6.3. Coulomb Interaction With Cutoff 19.6.4. Coulomb Interaction With Ewald Summation 19.6.5. Coulomb Interaction With Particle Mesh Ewald 19.6.6. Lennard-Jones Interaction With Particle Mesh Ewald 19.7. GBSAOBCForce 19.7.1. Generalized Born Term 19.7.2. Surface Area Term 19.8. GayBerneForce 19.9. AndersenThermostat 19.10. MonteCarloBarostat 19.11. MonteCarloAnisotropicBarostat 19.12. MonteCarloMembraneBarostat 19.13. MonteCarloFlexibleBarostat 19.14. CMMotionRemover 19.15. RMSDForce 20. Custom Forces 20.1. CustomBondForce 20.2. CustomAngleForce 20.3. CustomTorsionForce 20.4. CustomNonbondedForce 20.5. CustomExternalForce 20.6. CustomCompoundBondForce 20.7. CustomCentroidBondForce 20.8. CustomManyParticleForce 20.9. CustomGBForce 20.10. CustomHbondForce 20.11. CustomCVForce 20.12. ATMForce 20.13. Writing Custom Expressions 20.14. Setting Parameters 20.15. Parameter Derivatives 21. Integrators 21.1. VerletIntegrator 21.2. LangevinIntegator 21.3. LangevinMiddleIntegrator 21.4. NoseHooverIntegrator 21.5. BrownianIntegrator 21.6. VariableVerletIntegrator 21.7. VariableLangevinIntegrator 21.8. CustomIntegrator 22. Other Features 22.1. Periodic Boundary Conditions 22.2. LocalEnergyMinimizer 22.3. XMLSerializer 22.4. Force Groups 22.5. Virtual Sites 22.6. Random Numbers with Stochastic Integrators and Forces 23. Bibliography Portions copyright (c) 2008-2017 Stanford University and the Authors Contributors: Kyle Beauchamp, Christopher Bruns, John Chodera, Peter Eastman, Mark Friedrichs, Joy P. Ku, Tom Markland, Vijay Pande, Randy Radmer, Michael Sherman, Jason Swails, Lee-Ping Wang Permission is hereby granted, free of charge, to any person obtaining a copy of this document (the âDocumentâ), to deal in the Document without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Document, and to permit persons to whom the Document is furnished to do so, subject to the following conditions: This copyright and permission notice shall be included in all copies or substantial portions of the Document. THE DOCUMENT IS PROVIDED âAS ISâ, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS, CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE DOCUMENT OR THE USE OR OTHER DEALINGS IN THE DOCUMENT.

==================================================

