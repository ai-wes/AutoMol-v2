<div class="body" role="main">
<section id="metadynamics">
<h1>Metadynamics<a class="headerlink" href="#metadynamics" title="Permalink to this headline">Â¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="openmm.app.metadynamics.Metadynamics">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">openmm.app.metadynamics.</span></span><span class="sig-name descname"><span class="pre">Metadynamics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">biasFactor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveFrequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">biasDir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.app.metadynamics.Metadynamics" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Performs metadynamics.</p>
<p>This class implements well-tempered metadynamics, as described in Barducci et al.,
âWell-Tempered Metadynamics: A Smoothly Converging and Tunable Free-Energy Methodâ
(<a class="reference external" href="https://doi.org/10.1103/PhysRevLett.100.020603">https://doi.org/10.1103/PhysRevLett.100.020603</a>).  You specify from one to three
collective variables whose sampling should be accelerated.  A biasing force that
depends on the collective variables is added to the simulation.  Initially the bias
is zero.  As the simulation runs, Gaussian bumps are periodically added to the bias
at the current location of the simulation.  This pushes the simulation away from areas
it has already explored, encouraging it to sample other regions.  At the end of the
simulation, the bias function can be used to calculate the systemâs free energy as a
function of the collective variables.</p>
<p>To use the class you create a Metadynamics object, passing to it the System you want
to simulate and a list of BiasVariable objects defining the collective variables.
It creates a biasing force and adds it to the System.  You then run the simulation
as usual, but call step() on the Metadynamics object instead of on the Simulation.</p>
<p>You can optionally specify a directory on disk where the current bias function should
periodically be written.  In addition, it loads biases from any other files in the
same directory and includes them in the simulation.  It loads files when the
Metqdynamics object is first created, and also checks for any new files every time it
updates its own bias on disk.</p>
<p>This serves two important functions.  First, it lets you stop a metadynamics run and
resume it later.  When you begin the new simulation, it will load the biases computed
in the earlier simulation and continue adding to them.  Second, it provides an easy
way to parallelize metadynamics sampling across many computers.  Just point all of
them to a shared directory on disk.  Each process will save its biases to that
directory, and also load in and apply the biases added by other processes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.app.metadynamics.Metadynamics.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">biasFactor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveFrequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">biasDir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.app.metadynamics.Metadynamics.__init__" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a Metadynamics object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<a class="reference internal" href="openmm.openmm.System.html#openmm.openmm.System" title="openmm.openmm.System"><em>System</em></a>) â the System to simulate.  A CustomCVForce implementing the bias is created and
added to the System.</p></li>
<li><p><strong>variables</strong> (<em>list of BiasVariables</em>) â the collective variables to sample</p></li>
<li><p><strong>temperature</strong> (<em>temperature</em>) â the temperature at which the simulation is being run.  This is used in computing
the free energy.</p></li>
<li><p><strong>biasFactor</strong> (<em>float</em>) â used in scaling the height of the Gaussians added to the bias.  The collective
variables are sampled as if the effective temperature of the simulation were
temperature*biasFactor.</p></li>
<li><p><strong>height</strong> (<em>energy</em>) â the initial height of the Gaussians to add</p></li>
<li><p><strong>frequency</strong> (<em>int</em>) â the interval in time steps at which Gaussians should be added to the bias potential</p></li>
<li><p><strong>saveFrequency</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) â the interval in time steps at which to write out the current biases to disk.  At
the same time it writes biases, it also checks for updated biases written by other
processes and loads them in.  This must be a multiple of frequency.</p></li>
<li><p><strong>biasDir</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) â the directory to which biases should be written, and from which biases written by
other processes should be loaded</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.app.metadynamics.Metadynamics.__init__" title="openmm.app.metadynamics.Metadynamics.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(system,Â variables,Â temperature,Â â¦)</p></td>
<td><p>Create a Metadynamics object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.app.metadynamics.Metadynamics.getCollectiveVariables" title="openmm.app.metadynamics.Metadynamics.getCollectiveVariables"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getCollectiveVariables</span></code></a>(simulation)</p></td>
<td><p>Get the current values of all collective variables in a Simulation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.app.metadynamics.Metadynamics.getFreeEnergy" title="openmm.app.metadynamics.Metadynamics.getFreeEnergy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getFreeEnergy</span></code></a>()</p></td>
<td><p>Get the free energy of the system as a function of the collective variables.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.app.metadynamics.Metadynamics.step" title="openmm.app.metadynamics.Metadynamics.step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">step</span></code></a>(simulation,Â steps)</p></td>
<td><p>Advance the simulation by integrating a specified number of time steps.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.app.metadynamics.Metadynamics.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">simulation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.app.metadynamics.Metadynamics.step" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Advance the simulation by integrating a specified number of time steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>simulation</strong> (<a class="reference internal" href="openmm.app.simulation.Simulation.html#openmm.app.simulation.Simulation" title="openmm.app.simulation.Simulation"><em>Simulation</em></a>) â the Simulation to advance</p></li>
<li><p><strong>steps</strong> (<em>int</em>) â the number of time steps to integrate</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.app.metadynamics.Metadynamics.getFreeEnergy">
<span class="sig-name descname"><span class="pre">getFreeEnergy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#openmm.app.metadynamics.Metadynamics.getFreeEnergy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the free energy of the system as a function of the collective variables.</p>
<p>The result is returned as a N-dimensional NumPy array, where N is the number of collective
variables.  The values are in kJ/mole.  The iâth position along an axis corresponds to
minValue + i*(maxValue-minValue)/gridWidth.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.app.metadynamics.Metadynamics.getCollectiveVariables">
<span class="sig-name descname"><span class="pre">getCollectiveVariables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">simulation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.app.metadynamics.Metadynamics.getCollectiveVariables" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the current values of all collective variables in a Simulation.</p>
</dd></dl>
</dd></dl>
</section>
</div>