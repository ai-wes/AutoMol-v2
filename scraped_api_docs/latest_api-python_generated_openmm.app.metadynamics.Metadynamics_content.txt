MetadynamicsÂ¶ class openmm.app.metadynamics.Metadynamics(system, variables, temperature, biasFactor, height, frequency, saveFrequency=None, biasDir=None)Â¶ Performs metadynamics. This class implements well-tempered metadynamics, as described in Barducci et al., âWell-Tempered Metadynamics: A Smoothly Converging and Tunable Free-Energy Methodâ (https://doi.org/10.1103/PhysRevLett.100.020603). You specify from one to three collective variables whose sampling should be accelerated. A biasing force that depends on the collective variables is added to the simulation. Initially the bias is zero. As the simulation runs, Gaussian bumps are periodically added to the bias at the current location of the simulation. This pushes the simulation away from areas it has already explored, encouraging it to sample other regions. At the end of the simulation, the bias function can be used to calculate the systemâs free energy as a function of the collective variables. To use the class you create a Metadynamics object, passing to it the System you want to simulate and a list of BiasVariable objects defining the collective variables. It creates a biasing force and adds it to the System. You then run the simulation as usual, but call step() on the Metadynamics object instead of on the Simulation. You can optionally specify a directory on disk where the current bias function should periodically be written. In addition, it loads biases from any other files in the same directory and includes them in the simulation. It loads files when the Metqdynamics object is first created, and also checks for any new files every time it updates its own bias on disk. This serves two important functions. First, it lets you stop a metadynamics run and resume it later. When you begin the new simulation, it will load the biases computed in the earlier simulation and continue adding to them. Second, it provides an easy way to parallelize metadynamics sampling across many computers. Just point all of them to a shared directory on disk. Each process will save its biases to that directory, and also load in and apply the biases added by other processes. __init__(system, variables, temperature, biasFactor, height, frequency, saveFrequency=None, biasDir=None)Â¶ Create a Metadynamics object. Parameters system (System) â the System to simulate. A CustomCVForce implementing the bias is created and added to the System. variables (list of BiasVariables) â the collective variables to sample temperature (temperature) â the temperature at which the simulation is being run. This is used in computing the free energy. biasFactor (float) â used in scaling the height of the Gaussians added to the bias. The collective variables are sampled as if the effective temperature of the simulation were temperature*biasFactor. height (energy) â the initial height of the Gaussians to add frequency (int) â the interval in time steps at which Gaussians should be added to the bias potential saveFrequency (int (optional)) â the interval in time steps at which to write out the current biases to disk. At the same time it writes biases, it also checks for updated biases written by other processes and loads them in. This must be a multiple of frequency. biasDir (str (optional)) â the directory to which biases should be written, and from which biases written by other processes should be loaded Methods __init__(system,Â variables,Â temperature,Â â¦) Create a Metadynamics object. getCollectiveVariables(simulation) Get the current values of all collective variables in a Simulation. getFreeEnergy() Get the free energy of the system as a function of the collective variables. step(simulation,Â steps) Advance the simulation by integrating a specified number of time steps. step(simulation, steps)Â¶ Advance the simulation by integrating a specified number of time steps. Parameters simulation (Simulation) â the Simulation to advance steps (int) â the number of time steps to integrate getFreeEnergy()Â¶ Get the free energy of the system as a function of the collective variables. The result is returned as a N-dimensional NumPy array, where N is the number of collective variables. The values are in kJ/mole. The iâth position along an axis corresponds to minValue + i*(maxValue-minValue)/gridWidth. getCollectiveVariables(simulation)Â¶ Get the current values of all collective variables in a Simulation.