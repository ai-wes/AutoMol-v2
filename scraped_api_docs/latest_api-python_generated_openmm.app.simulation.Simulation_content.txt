SimulationÂ¶ class openmm.app.simulation.Simulation(topology, system, integrator, platform=None, platformProperties=None, state=None)Â¶ Simulation provides a simplified API for running simulations with OpenMM and reporting results. A Simulation ties together various objects used for running a simulation: a Topology, System, Integrator, and Context. To use it, you provide the Topology, System, and Integrator, and it creates the Context automatically. Simulation also maintains a list of âreporterâ objects that record or analyze data as the simulation runs, such as writing coordinates to files or displaying structures on the screen. For example, the following line will cause a file called âoutput.pdbâ to be created, and a structure written to it every 1000 time steps: simulation.reporters.append(PDBReporter(âoutput.pdbâ, 1000)) __init__(topology, system, integrator, platform=None, platformProperties=None, state=None)Â¶ Create a Simulation. Parameters topology (Topology) â A Topology describing the the system to simulate system (System or XML file name) â The OpenMM System object to simulate (or the name of an XML file with a serialized System) integrator (Integrator or XML file name) â The OpenMM Integrator to use for simulating the System (or the name of an XML file with a serialized System) platform (Platform=None) â If not None, the OpenMM Platform to use platformProperties (map=None) â If not None, a set of platform-specific properties to pass to the Contextâs constructor. This argument may only be used if a specific Platform is specified. state (XML file name=None) â The name of an XML file containing a serialized State. If not None, the information stored in state will be transferred to the generated Simulation object. Methods __init__(topology,Â system,Â integrator[,Â â¦]) Create a Simulation. loadCheckpoint(file) Load a checkpoint file that was created with saveCheckpoint(). loadState(file) Load a State file that was created with saveState(). minimizeEnergy([tolerance,Â maxIterations,Â â¦]) Perform a local energy minimization on the system. runForClockTime(time[,Â checkpointFile,Â â¦]) Advance the simulation by integrating time steps until a fixed amount of clock time has elapsed. saveCheckpoint(file) Save a checkpoint of the simulation to a file. saveState(file) Save the current state of the simulation to a file. step(steps) Advance the simulation by integrating a specified number of time steps. Attributes currentStep The index of the current time step. property currentStepÂ¶ The index of the current time step. minimizeEnergy(tolerance=Quantity(value=10, unit=kilojoule / nanometer * mole), maxIterations=0, reporter=None)Â¶ Perform a local energy minimization on the system. Parameters tolerance (force) â This specifies how precisely the energy minimum must be located. Minimization is halted once the root-mean-square value of all force components reaches this tolerance. maxIterations (int) â The maximum number of iterations to perform. If this is 0, minimization is continued until the results converge without regard to how many iterations it takes. reporter (MinimizationReporter = None) â an optional reporter to invoke after each iteration. This can be used to monitor the progress of minimization or to stop minimization early. step(steps)Â¶ Advance the simulation by integrating a specified number of time steps. runForClockTime(time, checkpointFile=None, stateFile=None, checkpointInterval=None)Â¶ Advance the simulation by integrating time steps until a fixed amount of clock time has elapsed. This is useful when you have a limited amount of computer time available, and want to run the longest simulation possible in that time. This method will continue taking time steps until the specified clock time has elapsed, then return. It also can automatically write out a checkpoint and/or state file before returning, so you can later resume the simulation. Another option allows it to write checkpoints or states at regular intervals, so you can resume even if the simulation is interrupted before the time limit is reached. Parameters time (time) â the amount of time to run for. If no units are specified, it is assumed to be a number of hours. checkpointFile (string or file=None) â if specified, a checkpoint file will be written at the end of the simulation (and optionally at regular intervals before then) by passing this to saveCheckpoint(). stateFile (string or file=None) â if specified, a state file will be written at the end of the simulation (and optionally at regular intervals before then) by passing this to saveState(). checkpointInterval (time=None) â if specified, checkpoints and/or states will be written at regular intervals during the simulation, in addition to writing a final version at the end. If no units are specified, this is assumed to be in hours. saveCheckpoint(file)Â¶ Save a checkpoint of the simulation to a file. The output is a binary file that contains a complete representation of the current state of the Simulation. It includes both publicly visible data such as the particle positions and velocities, and also internal data such as the states of random number generators. Reloading the checkpoint will put the Simulation back into precisely the same state it had before, so it can be exactly continued. A checkpoint file is highly specific to the Simulation it was created from. It can only be loaded into another Simulation that has an identical System, uses the same Platform and OpenMM version, and is running on identical hardware. If you need a more portable way to resume simulations, consider using saveState() instead. Parameters file (string or file) â a File-like object to write the checkpoint to, or alternatively a filename loadCheckpoint(file)Â¶ Load a checkpoint file that was created with saveCheckpoint(). Parameters file (string or file) â a File-like object to load the checkpoint from, or alternatively a filename saveState(file)Â¶ Save the current state of the simulation to a file. The output is an XML file containing a serialized State object. It includes all publicly visible data, including positions, velocities, and parameters. Reloading the State will put the Simulation back into approximately the same state it had before. Unlike saveCheckpoint(), this does not store internal data such as the states of random number generators. Therefore, you should not expect the following trajectory to be identical to what would have been produced with the original Simulation. On the other hand, this means it is portable across different Platforms or hardware. Parameters file (string or file) â a File-like object to write the state to, or alternatively a filename loadState(file)Â¶ Load a State file that was created with saveState(). Parameters file (string or file) â a File-like object to load the state from, or alternatively a filename