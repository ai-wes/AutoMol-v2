<div class="body" role="main">
<section id="nosehooverchain">
<h1>NoseHooverChain<a class="headerlink" href="#nosehooverchain" title="Permalink to this headline">Â¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">openmm.openmm.</span></span><span class="sig-name descname"><span class="pre">NoseHooverChain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This class defines a chain of Nose-Hoover particles to be used as a heat bath to scale the velocities of a collection of particles subject to thermostating. The heat bath is propagated using the multi time step approach detailed in</p>
<ol class="upperalpha simple" start="7">
<li><ol class="upperalpha simple" start="10">
<li><p>Martyna, M. E. Tuckerman, D. J. Tobias and M. L. Klein, Mol. Phys. 87, 1117 (1996).</p></li>
</ol>
</li>
</ol>
<p>where the total number of timesteps used to propagate the chain in each step is the number of MTS steps multiplied by the number of terms in the Yoshida-Suzuki decomposition.</p>
<p>Two types of NHC may be created. The first is a simple thermostat that couples with a given subset of the atoms within a system, controling their absolute motion. The second is more elaborate and can thermostat tethered pairs of atoms and in this case two thermostats are created: one that controls the absolute center of mass velocity of each pair and another that controls their motion relative to one another.</p>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relativeTemperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collisionFrequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relativeCollisionFrequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numDOFs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chainLength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numMTS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numYoshidaSuzuki</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chainID</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thermostatedAtoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thermostatedPairs</span></span></em><span class="sig-paren">)</span> → <a class="reference internal" href="#openmm.openmm.NoseHooverChain" title="openmm.openmm.NoseHooverChain"><span class="pre">NoseHooverChain</span></a><a class="headerlink" href="#openmm.openmm.NoseHooverChain.__init__" title="Permalink to this definition">Â¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span> → <a class="reference internal" href="#openmm.openmm.NoseHooverChain" title="openmm.openmm.NoseHooverChain"><span class="pre">NoseHooverChain</span></a></dt>
<dd><p>Create a NoseHooverChain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>temperature</strong> (<em>double</em>) â the temperature of the heat bath for absolute motion (in Kelvin)</p></li>
<li><p><strong>collisionFrequency</strong> (<em>double</em>) â the collision frequency for absolute motion (in 1/ps)</p></li>
<li><p><strong>relativeTemperature</strong> (<em>double</em>) â the temperature of the heat bath for relative motion(in Kelvin). This is only used if the list of thermostated pairs is not empty.</p></li>
<li><p><strong>relativeCollisionFrequency</strong> (<em>double</em>) â the collision frequency for relative motion(in 1/ps). This is only used if the list of thermostated pairs is not empty.</p></li>
<li><p><strong>numDOFs</strong> (<em>int</em>) â the number of degrees of freedom in the particles that interact with this chain</p></li>
<li><p><strong>chainLength</strong> (<em>int</em>) â the length of (number of particles in) this heat bath</p></li>
<li><p><strong>numMTS</strong> (<em>int</em>) â the number of multi time steps used to propagate this chain</p></li>
<li><p><strong>numYoshidaSuzuki</strong> (<em>int</em>) â the number of Yoshida Suzuki steps used to propagate this chain (1, 3, 5, or 7).</p></li>
<li><p><strong>chainID</strong> (<em>int</em>) â the chain id used to distinguish this Nose-Hoover chain from others that may be used to control a different set of particles, e.g. for Drude oscillators</p></li>
<li><p><strong>thermostatedAtoms</strong> (<em>vector&lt; int &gt;</em>) â the list of atoms to be handled by this thermostat</p></li>
<li><p><strong>thermostatedPairs</strong> (<em>vector&lt; std::pair&lt; int</em><em>, </em><em>int &gt; &gt;</em>) â the list of connected pairs to be thermostated; their absolute center of mass motion will be thermostated independently from their motion relative to one another.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.__init__" title="openmm.openmm.NoseHooverChain.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(-&gt;Â NoseHooverChain)</p></td>
<td><p>Create a NoseHooverChain.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getChainID" title="openmm.openmm.NoseHooverChain.getChainID"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getChainID</span></code></a>(self)</p></td>
<td><p>Get the chain id used to identify this chain</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getChainLength" title="openmm.openmm.NoseHooverChain.getChainLength"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getChainLength</span></code></a>(self)</p></td>
<td><p>Get the chain length of this heat bath.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getCollisionFrequency" title="openmm.openmm.NoseHooverChain.getCollisionFrequency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getCollisionFrequency</span></code></a>(self)</p></td>
<td><p>Get the collision frequency for treating absolute particle motion (in 1/ps).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getNumDegreesOfFreedom" title="openmm.openmm.NoseHooverChain.getNumDegreesOfFreedom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getNumDegreesOfFreedom</span></code></a>(self)</p></td>
<td><p>Get the number of degrees of freedom in the particles controled by this heat bath.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getNumMultiTimeSteps" title="openmm.openmm.NoseHooverChain.getNumMultiTimeSteps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getNumMultiTimeSteps</span></code></a>(self)</p></td>
<td><p>Get the number of steps used in the multi time step propagation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getNumYoshidaSuzukiTimeSteps" title="openmm.openmm.NoseHooverChain.getNumYoshidaSuzukiTimeSteps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getNumYoshidaSuzukiTimeSteps</span></code></a>(self)</p></td>
<td><p>Get the number of steps used in the Yoshida-Suzuki decomposition for multi time step propagation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getRelativeCollisionFrequency" title="openmm.openmm.NoseHooverChain.getRelativeCollisionFrequency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getRelativeCollisionFrequency</span></code></a>(self)</p></td>
<td><p>Get the collision frequency for treating relative particle motion (in 1/ps).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getRelativeTemperature" title="openmm.openmm.NoseHooverChain.getRelativeTemperature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getRelativeTemperature</span></code></a>(self)</p></td>
<td><p>Get the temperature of the heat bath for treating relative particle motion (in Kelvin).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getTemperature" title="openmm.openmm.NoseHooverChain.getTemperature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getTemperature</span></code></a>(self)</p></td>
<td><p>Get the temperature of the heat bath for treating absolute particle motion (in Kelvin).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getThermostatedAtoms" title="openmm.openmm.NoseHooverChain.getThermostatedAtoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getThermostatedAtoms</span></code></a>(self)</p></td>
<td><p>Get the atom ids of all atoms that are thermostated</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getThermostatedPairs" title="openmm.openmm.NoseHooverChain.getThermostatedPairs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getThermostatedPairs</span></code></a>(self)</p></td>
<td><p>Get the list of any connected pairs to be handled by this thermostat.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.getYoshidaSuzukiWeights" title="openmm.openmm.NoseHooverChain.getYoshidaSuzukiWeights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getYoshidaSuzukiWeights</span></code></a>(self)</p></td>
<td><p>Get the weights used in the Yoshida Suzuki multi time step decomposition (dimensionless)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.setCollisionFrequency" title="openmm.openmm.NoseHooverChain.setCollisionFrequency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setCollisionFrequency</span></code></a>(self,Â frequency)</p></td>
<td><p>Set the collision frequency for treating absolute particle motion.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.setNumDegreesOfFreedom" title="openmm.openmm.NoseHooverChain.setNumDegreesOfFreedom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setNumDegreesOfFreedom</span></code></a>(self,Â numDOF)</p></td>
<td><p>Set the number of degrees of freedom in the particles controled by this heat bath.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.setRelativeCollisionFrequency" title="openmm.openmm.NoseHooverChain.setRelativeCollisionFrequency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setRelativeCollisionFrequency</span></code></a>(self,Â frequency)</p></td>
<td><p>Set the collision frequency for treating relative particle motion if this thermostat has been set up to handle connected pairs of atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.setRelativeTemperature" title="openmm.openmm.NoseHooverChain.setRelativeTemperature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setRelativeTemperature</span></code></a>(self,Â temperature)</p></td>
<td><p>Set the temperature of the heat bath for treating relative motion if this thermostat has been set up to treat connected pairs of atoms.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.setTemperature" title="openmm.openmm.NoseHooverChain.setTemperature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setTemperature</span></code></a>(self,Â temperature)</p></td>
<td><p>Set the temperature of the heat bath for treating absolute particle motion.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.setThermostatedAtoms" title="openmm.openmm.NoseHooverChain.setThermostatedAtoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setThermostatedAtoms</span></code></a>(self,Â atomIDs)</p></td>
<td><p>Set list of atoms that are handled by this thermostat</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.setThermostatedPairs" title="openmm.openmm.NoseHooverChain.setThermostatedPairs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setThermostatedPairs</span></code></a>(self,Â pairIDs)</p></td>
<td><p>In case this thermostat handles the kinetic energy of Drude particles set the atom IDs of all parent atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.usesPeriodicBoundaryConditions" title="openmm.openmm.NoseHooverChain.usesPeriodicBoundaryConditions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">usesPeriodicBoundaryConditions</span></code></a>(self)</p></td>
<td><p>Returns whether or not this force makes use of periodic boundary conditions.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#openmm.openmm.NoseHooverChain.thisown" title="openmm.openmm.NoseHooverChain.thisown"><code class="xref py py-obj docutils literal notranslate"><span class="pre">thisown</span></code></a></p></td>
<td><p>The membership flag</p></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.thisown">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">thisown</span></span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.thisown" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The membership flag</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getTemperature">
<span class="sig-name descname"><span class="pre">getTemperature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">double</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getTemperature" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the temperature of the heat bath for treating absolute particle motion (in Kelvin).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the temperature of the heat bath, measured in Kelvin.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>double</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.setTemperature">
<span class="sig-name descname"><span class="pre">setTemperature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.setTemperature" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the temperature of the heat bath for treating absolute particle motion. This will affect any new Contexts you create, but not ones that already exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>temperature</strong> (<em>double</em>) â the temperature of the heat bath (in Kelvin)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getRelativeTemperature">
<span class="sig-name descname"><span class="pre">getRelativeTemperature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">double</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getRelativeTemperature" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the temperature of the heat bath for treating relative particle motion (in Kelvin).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the temperature of the heat bath, measured in Kelvin.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>double</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.setRelativeTemperature">
<span class="sig-name descname"><span class="pre">setRelativeTemperature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.setRelativeTemperature" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the temperature of the heat bath for treating relative motion if this thermostat has been set up to treat connected pairs of atoms. This will affect any new Contexts you create, but not ones that already exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>temperature</strong> (<em>double</em>) â the temperature of the heat bath for relative motion (in Kelvin)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getCollisionFrequency">
<span class="sig-name descname"><span class="pre">getCollisionFrequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">double</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getCollisionFrequency" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the collision frequency for treating absolute particle motion (in 1/ps).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the collision frequency, measured in 1/ps.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>double</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.setCollisionFrequency">
<span class="sig-name descname"><span class="pre">setCollisionFrequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.setCollisionFrequency" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the collision frequency for treating absolute particle motion. This will affect any new Contexts you create, but not those that already exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> (<em>double</em>) â the collision frequency (in 1/ps)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getRelativeCollisionFrequency">
<span class="sig-name descname"><span class="pre">getRelativeCollisionFrequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">double</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getRelativeCollisionFrequency" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the collision frequency for treating relative particle motion (in 1/ps).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the collision frequency, measured in 1/ps.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>double</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.setRelativeCollisionFrequency">
<span class="sig-name descname"><span class="pre">setRelativeCollisionFrequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.setRelativeCollisionFrequency" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the collision frequency for treating relative particle motion if this thermostat has been set up to handle connected pairs of atoms. This will affect any new Contexts you create, but not those that already exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frequency</strong> (<em>double</em>) â the collision frequency (in 1/ps)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getNumDegreesOfFreedom">
<span class="sig-name descname"><span class="pre">getNumDegreesOfFreedom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">int</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getNumDegreesOfFreedom" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the number of degrees of freedom in the particles controled by this heat bath.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of degrees of freedom.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.setNumDegreesOfFreedom">
<span class="sig-name descname"><span class="pre">setNumDegreesOfFreedom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numDOF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.setNumDegreesOfFreedom" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the number of degrees of freedom in the particles controled by this heat bath. This will affect any new Contexts you create, but not those that already exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>numDOF</strong> (<em>int</em>) â the number of degrees of freedom.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getChainLength">
<span class="sig-name descname"><span class="pre">getChainLength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">int</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getChainLength" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the chain length of this heat bath.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the chain length.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getNumMultiTimeSteps">
<span class="sig-name descname"><span class="pre">getNumMultiTimeSteps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">int</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getNumMultiTimeSteps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the number of steps used in the multi time step propagation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of multi time steps.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getNumYoshidaSuzukiTimeSteps">
<span class="sig-name descname"><span class="pre">getNumYoshidaSuzukiTimeSteps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">int</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getNumYoshidaSuzukiTimeSteps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the number of steps used in the Yoshida-Suzuki decomposition for multi time step propagation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of multi time steps in the Yoshida-Suzuki decomposition.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getChainID">
<span class="sig-name descname"><span class="pre">getChainID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">int</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getChainID" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the chain id used to identify this chain</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the chain id</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getThermostatedAtoms">
<span class="sig-name descname"><span class="pre">getThermostatedAtoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">vectori</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getThermostatedAtoms" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the atom ids of all atoms that are thermostated</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>ids of all atoms that are being handled by this thermostat</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>vector&lt; int &gt;</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.setThermostatedAtoms">
<span class="sig-name descname"><span class="pre">setThermostatedAtoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atomIDs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.setThermostatedAtoms" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set list of atoms that are handled by this thermostat</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atomIDs</strong> (<em>vector&lt; int &gt;</em>) â </p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getThermostatedPairs">
<span class="sig-name descname"><span class="pre">getThermostatedPairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">vectorpairii</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getThermostatedPairs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the list of any connected pairs to be handled by this thermostat. If this is a regular thermostat, returns an empty vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of connected pairs.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>vector&lt; std::pair&lt; int, int &gt; &gt;</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.setThermostatedPairs">
<span class="sig-name descname"><span class="pre">setThermostatedPairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pairIDs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.setThermostatedPairs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>In case this thermostat handles the kinetic energy of Drude particles set the atom IDs of all parent atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pairIDs</strong> (<em>vector&lt; std::pair&lt; int</em><em>, </em><em>int &gt; &gt;</em>) â the list of connected pairs to thermostat.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.getYoshidaSuzukiWeights">
<span class="sig-name descname"><span class="pre">getYoshidaSuzukiWeights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">vectord</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.getYoshidaSuzukiWeights" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the weights used in the Yoshida Suzuki multi time step decomposition (dimensionless)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the weights for the Yoshida-Suzuki integration</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>vector&lt; double &gt;</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="openmm.openmm.NoseHooverChain.usesPeriodicBoundaryConditions">
<span class="sig-name descname"><span class="pre">usesPeriodicBoundaryConditions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span> → <span class="pre">bool</span><a class="headerlink" href="#openmm.openmm.NoseHooverChain.usesPeriodicBoundaryConditions" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns whether or not this force makes use of periodic boundary conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if force uses PBC and false otherwise</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
</div>